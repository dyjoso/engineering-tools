<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Stress Transformation Tool</title>
    <link rel="icon" type="image/png" href="icon.png">
    <style>
        :root {
            --primary-color: #0068c9;
            --bg-color: #f0f0f0;
            --card-bg-color: #ffffff;
            --text-color: #333;
            --border-color: #ccc;
            --box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
            --font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            --orange-btn: #fa9e61;
            --green-btn: #B4CEA1;
            --result-bg: #d5e2ca;
        }

        body {
            font-family: var(--font-family);
            background-color: var(--bg-color);
            color: var(--text-color);
            margin: 0;
            padding: 0.5rem;
            display: flex;
            justify-content: center;
            font-size: 14px;
        }

        .app-container {
            width: 100%;
            max-width: 950px;
            background-color: var(--card-bg-color);
            padding: 15px;
            border-radius: 8px;
            box-shadow: var(--box-shadow);
            border: 1px solid var(--border-color);
        }

        h1 {
            text-align: center;
            font-size: 1.4em;
            margin-top: 0;
            margin-bottom: 12px;
            color: var(--primary-color);
        }

        h3 {
            font-size: 0.95em;
            margin: 0 0 6px 0;
            color: var(--text-color);
        }

        .tab-buttons {
            display: flex;
            gap: 8px;
            margin-bottom: 12px;
        }

        .tab-btn {
            flex: 1;
            padding: 7px 10px;
            font-size: 0.9em;
            border: 1px solid #bbb;
            border-radius: 4px;
            cursor: pointer;
            background: #e7e7e7;
            transition: 0.2s;
            font-family: var(--font-family);
        }

        .tab-btn.active {
            background: var(--primary-color);
            color: white;
            border-color: #0056b3;
        }

        .panel {
            display: none;
            animation: fadeIn 0.3s;
        }

        .panel.active {
            display: block;
        }

        .input-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 8px;
            margin-bottom: 10px;
        }

        .input-group {
            display: flex;
            flex-direction: column;
        }

        label {
            font-size: 1.1em;
            font-weight: bold;
            margin-bottom: 3px;
        }

        input[type="number"] {
            padding: 4px;
            border: 1px solid #ccc;
            border-radius: 4px;
            box-sizing: border-box;
            width: 100%;
            text-align: center;
        }

        button.calc-btn {
            width: 100%;
            padding: 7px;
            background: var(--orange-btn);
            color: white;
            border: 1px solid #e08e51;
            border-radius: 4px;
            font-size: 0.9em;
            font-weight: bold;
            cursor: pointer;
            transition: 0.2s;
            font-family: var(--font-family);
        }

        button.calc-btn:hover {
            background: #e08e51;
        }

        .output-area {
            display: flex;
            flex-wrap: wrap;
            gap: 12px;
            margin-top: 12px;
        }

        .results-box {
            flex: 1;
            min-width: 220px;
            padding: 10px 12px;
            background: var(--result-bg);
            border-radius: 6px;
            border: 1px solid #b0c9a0;
        }

        /* Compact label/value grid inside results */
        .results-grid {
            display: grid;
            grid-template-columns: auto 1fr;
            gap: 3px 10px;
            align-items: center;
        }

        .results-grid .res-label {
            font-weight: bold;
            text-align: right;
            white-space: nowrap;
            font-size: 0.9em;
        }

        .results-grid .res-value {
            font-family: monospace;
            font-size: 0.9em;
            background: rgba(255, 255, 255, 0.55);
            border-radius: 3px;
            padding: 2px 5px;
        }

        canvas {
            background: #fff;
            border: 1px solid #eee;
            border-radius: 6px;
            max-width: 100%;
            width: 100%;
            height: auto;
        }

        .canvas-container {
            display: flex;
            flex-wrap: wrap;
            gap: 12px;
            width: 100%;
        }

        .canvas-item {
            flex: 1;
            min-width: 260px;
            display: flex;
            flex-direction: column;
        }

        .canvas-item label {
            text-align: center;
            margin-bottom: 5px;
            color: #666;
            font-size: 0.85em;
            font-weight: normal;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
            }

            to {
                opacity: 1;
            }
        }
    </style>
</head>

<body>

    <div class="app-container">
        <h1>Stress Transformation Tool</h1>
        <div class="tab-buttons">
            <button class="tab-btn active" onclick="showTab('2d-panel', this)">2D Stress Transformation</button>
            <button class="tab-btn" onclick="showTab('3d-panel', this)">3D Principal Stresses</button>
        </div>

        <div id="2d-panel" class="panel active">
            <div class="input-grid">
                <div class="input-group"><label>σx</label><input type="number" id="sx2" value="80"></div>
                <div class="input-group"><label>σy</label><input type="number" id="sy2" value="20"></div>
                <div class="input-group"><label>τxy</label><input type="number" id="txy2" value="40"></div>
                <div class="input-group"><label
                        title="Stress components will be reported for an element rotated by this angle counterclockwise">Angle
                        θ (°) ⓘ</label><input type="number" id="thetaInput" value="30">
                </div>
            </div>
            <button class="calc-btn" onclick="solve2D()">Calculate Stress State</button>

            <div class="output-area">
                <div id="res2D" class="results-box">Results will appear here...</div>
                <div class="canvas-container">
                    <div class="canvas-item">
                        <label>Mohr's Circle</label>
                        <canvas id="mohrCanvas" width="400" height="400"></canvas>
                    </div>
                    <div class="canvas-item">
                        <label>Stress Element</label>
                        <canvas id="elementCanvas" width="400" height="400"></canvas>
                    </div>
                </div>
            </div>
        </div>

        <div id="3d-panel" class="panel">
            <div class="input-grid">
                <div class="input-group"><label>σx</label><input type="number" id="sx3" value="100"></div>
                <div class="input-group"><label>σy</label><input type="number" id="sy3" value="50"></div>
                <div class="input-group"><label>σz</label><input type="number" id="sz3" value="25"></div>
                <div class="input-group"><label>τxy</label><input type="number" id="txy3" value="10"></div>
                <div class="input-group"><label>τyz</label><input type="number" id="tyz3" value="20"></div>
                <div class="input-group"><label>τxz</label><input type="number" id="txz3" value="15"></div>
            </div>
            <button class="calc-btn" onclick="solve3D()">Calculate 3D Eigenvalues</button>
            <div class="output-area">
                <div id="res3D" class="results-box">Results will appear here...</div>
                <div class="canvas-container">
                    <div class="canvas-item" style="flex: 2;">
                        <label>3D Mohr's Circles</label>
                        <canvas id="mohr3DCanvas" width="500" height="400"></canvas>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        function showTab(id, btn) {
            document.querySelectorAll('.panel').forEach(p => p.classList.remove('active'));
            document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
            document.getElementById(id).classList.add('active');
            btn.classList.add('active');
        }

        function solve2D() {
            const sx = parseFloat(document.getElementById('sx2').value);
            const sy = parseFloat(document.getElementById('sy2').value);
            const txy = parseFloat(document.getElementById('txy2').value);
            const thetaDeg = parseFloat(document.getElementById('thetaInput').value);
            const thetaRad = (thetaDeg * Math.PI) / 180;

            // Principal Stresses
            const avg = (sx + sy) / 2;
            const R = Math.sqrt(Math.pow((sx - sy) / 2, 2) + Math.pow(txy, 2));
            const s1 = avg + R;
            const s2 = avg - R;
            const thetaP = 0.5 * Math.atan2(2 * txy, (sx - sy)) * (180 / Math.PI);

            // Transformation at Angle θ
            const sxTheta = avg + (sx - sy) / 2 * Math.cos(2 * thetaRad) + txy * Math.sin(2 * thetaRad);
            const syTheta = avg - (sx - sy) / 2 * Math.cos(2 * thetaRad) - txy * Math.sin(2 * thetaRad);
            const txyTheta = -(sx - sy) / 2 * Math.sin(2 * thetaRad) + txy * Math.cos(2 * thetaRad);

            // Von Mises
            const svm = Math.sqrt(Math.pow(sx, 2) - sx * sy + Math.pow(sy, 2) + 3 * Math.pow(txy, 2));

            document.getElementById('res2D').innerHTML = `
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 12px;">
                    <div>
                        <h3>Principal Stresses</h3>
                        <div class="results-grid">
                            <span class="res-label">σ₁ =</span><span class="res-value">${s1.toFixed(3)}</span>
                            <span class="res-label">σ₂ =</span><span class="res-value">${s2.toFixed(3)}</span>
                            <span class="res-label">τ_max =</span><span class="res-value">${R.toFixed(3)}</span>
                            <span class="res-label">θₚ =</span><span class="res-value">${thetaP.toFixed(2)}°</span>
                            <span class="res-label">σ_vm =</span><span class="res-value">${svm.toFixed(3)}</span>
                        </div>
                    </div>
                    <div>
                        <h3>At θ = ${thetaDeg}°</h3>
                        <div class="results-grid">
                            <span class="res-label">σ_x' =</span><span class="res-value">${sxTheta.toFixed(3)}</span>
                            <span class="res-label">σ_y' =</span><span class="res-value">${syTheta.toFixed(3)}</span>
                            <span class="res-label">τ_x'y' =</span><span class="res-value">${txyTheta.toFixed(3)}</span>
                        </div>
                    </div>
                </div>
            `;

            drawMohr(sx, sy, txy, avg, R, s1, s2, sxTheta, txyTheta, thetaDeg);
            drawElement(sx, sy, txy, sxTheta, syTheta, txyTheta, thetaDeg);
        }

        function drawMohr(sx, sy, txy, avg, R, s1, s2, sxTheta, txyTheta, thetaDeg) {
            const canvas = document.getElementById('mohrCanvas');
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            const margin = 50;
            const width = canvas.width;
            const height = canvas.height;

            const minX = Math.min(s2, 0, sxTheta) - R * 0.3;
            const maxX = Math.max(s1, 0, sxTheta) + R * 0.3;
            const minY = -R * 1.5;
            const maxY = R * 1.5;

            const rangeX = maxX - minX || 10;
            const rangeY = maxY - minY || 10;
            const scale = Math.min((width - 2 * margin) / rangeX, (height - 2 * margin) / rangeY);

            const toX = (val) => margin + (val - minX) * scale + (width - 2 * margin - rangeX * scale) / 2;
            const toY = (val) => height - (margin + (val - minY) * scale + (height - 2 * margin - rangeY * scale) / 2);

            const cx = toX(avg);
            const cy = toY(0);
            const rPx = R * scale;

            // Draw Axes
            ctx.strokeStyle = '#ccc';
            ctx.beginPath();
            ctx.moveTo(0, cy); ctx.lineTo(width, cy);
            ctx.moveTo(toX(0), 0); ctx.lineTo(toX(0), height);
            ctx.stroke();

            // Draw Circle
            ctx.beginPath();
            ctx.arc(cx, cy, rPx, 0, 2 * Math.PI);
            ctx.strokeStyle = '#0056b3';
            ctx.lineWidth = 2;
            ctx.stroke();

            // Draw Original State
            const x1 = toX(sx); const y1 = toY(-txy);
            const x2 = toX(sy); const y2 = toY(txy);
            ctx.fillStyle = '#666';
            ctx.beginPath(); ctx.arc(x1, y1, 4, 0, 7); ctx.fill();
            ctx.beginPath(); ctx.arc(x2, y2, 4, 0, 7); ctx.fill();
            ctx.setLineDash([5, 5]);
            ctx.strokeStyle = '#999';
            ctx.beginPath(); ctx.moveTo(x1, y1); ctx.lineTo(x2, y2); ctx.stroke();

            // Draw Transformed State
            const xt1 = toX(sxTheta); const yt1 = toY(-txyTheta);
            const xt2 = toX(2 * avg - sxTheta); const yt2 = toY(txyTheta);
            ctx.fillStyle = '#dc3545';
            ctx.setLineDash([]);
            ctx.beginPath(); ctx.arc(xt1, yt1, 5, 0, 7); ctx.fill();
            ctx.beginPath(); ctx.arc(xt2, yt2, 5, 0, 7); ctx.fill();
            ctx.strokeStyle = '#dc3545';
            ctx.beginPath(); ctx.moveTo(xt1, yt1); ctx.lineTo(xt2, yt2); ctx.stroke();

            // Labels
            ctx.fillStyle = '#333';
            ctx.font = '12px Arial';
            ctx.fillText('σ₁', toX(s1), cy + 15);
            ctx.fillText('σ₂', toX(s2), cy + 15);
            ctx.fillText(`θ=${thetaDeg}°`, xt1, yt1 - 10);
        }

        function drawElement(sx, sy, txy, sxT, syT, txyT, theta) {
            const canvas = document.getElementById('elementCanvas');
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            const cx = canvas.width / 2;
            const cy = canvas.height / 2;
            const size = 100;
            const rad = (theta * Math.PI) / 180;

            const maxStress = Math.max(Math.abs(sxT), Math.abs(syT), Math.abs(txyT));

            // Draw Rotated Element
            ctx.save();
            ctx.translate(cx, cy);
            ctx.rotate(-rad); // Rotate CW for visualization if theta is CCW

            ctx.strokeStyle = '#0056b3';
            ctx.lineWidth = 2;
            ctx.strokeRect(-size / 2, -size / 2, size, size);

            // Stress Arrows
            const drawArrow = (x, y, angle, len, color, label) => {
                if (Math.abs(len) < 1e-6) return;
                ctx.save();
                ctx.translate(x, y);
                ctx.rotate(angle);
                ctx.strokeStyle = color;
                ctx.fillStyle = color;

                const arrowLenMag = maxStress > 0 ? (Math.abs(len) / maxStress) * size : 0;
                const arrowLen = arrowLenMag * (len > 0 ? 1 : -1);

                ctx.beginPath();
                ctx.moveTo(0, 0); ctx.lineTo(arrowLen, 0);
                ctx.stroke();

                // Tip
                ctx.beginPath();
                ctx.moveTo(arrowLen, 0);
                ctx.lineTo(arrowLen - 5 * Math.sign(arrowLen), 3);
                ctx.lineTo(arrowLen - 5 * Math.sign(arrowLen), -3);
                ctx.fill();

                ctx.fillStyle = '#333';
                ctx.fillText(label, arrowLen + 5 * Math.sign(arrowLen), 0);
                ctx.restore();
            };

            // Normal Stresses (rotated)
            drawArrow(size / 2, 0, 0, sxT, '#dc3545', ''); // x' face
            drawArrow(-size / 2, 0, Math.PI, sxT, '#dc3545', '');
            drawArrow(0, -size / 2, -Math.PI / 2, syT, '#28a745', ''); // y' face
            drawArrow(0, size / 2, Math.PI / 2, syT, '#28a745', '');

            // Shear Stresses (rotated)
            const sLen = txyT;
            drawArrow(size / 2, -size / 2 + 10, -Math.PI / 2, sLen, '#fd7e14', ''); // right face
            drawArrow(-size / 2, size / 2 - 10, Math.PI / 2, sLen, '#fd7e14', ''); // left face
            drawArrow(size / 2 - 10, -size / 2, 0, sLen, '#fd7e14', ''); // top face
            drawArrow(-size / 2 + 10, size / 2, Math.PI, sLen, '#fd7e14', ''); // bottom face

            ctx.restore();

            // Draw axis indicator
            ctx.setLineDash([2, 2]);
            ctx.strokeStyle = '#ccc';
            ctx.strokeRect(cx - size / 2, cy - size / 2, size, size);
            ctx.setLineDash([]);
        }

        function solve3D() {
            const sx = parseFloat(document.getElementById('sx3').value);
            const sy = parseFloat(document.getElementById('sy3').value);
            const sz = parseFloat(document.getElementById('sz3').value);
            const txy = parseFloat(document.getElementById('txy3').value);
            const tyz = parseFloat(document.getElementById('tyz3').value);
            const txz = parseFloat(document.getElementById('txz3').value);

            const I1 = sx + sy + sz;
            const I2 = (sx * sy + sy * sz + sz * sx) - (txy ** 2 + tyz ** 2 + txz ** 2);
            const I3 = sx * (sy * sz - tyz ** 2) - txy * (txy * sz - tyz * txz) + txz * (txy * tyz - sy * txz);

            const Q = (3 * I2 - Math.pow(I1, 2)) / 9;
            const R = (9 * I1 * I2 - 27 * I3 - 2 * Math.pow(I1, 3)) / 54;

            let s1, s2, s3;
            const disc = Math.pow(Q, 3) + Math.pow(R, 2);

            if (disc <= 0) {
                const theta = Math.acos(R / Math.sqrt(-Math.pow(Q, 3)));
                s1 = 2 * Math.sqrt(-Q) * Math.cos(theta / 3) + I1 / 3;
                s2 = 2 * Math.sqrt(-Q) * Math.cos((theta + 2 * Math.PI) / 3) + I1 / 3;
                s3 = 2 * Math.sqrt(-Q) * Math.cos((theta + 4 * Math.PI) / 3) + I1 / 3;
            }

            const sorted = [s1, s2, s3].sort((a, b) => b - a);
            const svm3D = Math.sqrt(0.5 * (Math.pow(sorted[0] - sorted[1], 2) + Math.pow(sorted[1] - sorted[2], 2) + Math.pow(sorted[2] - sorted[0], 2)));

            document.getElementById('res3D').innerHTML = `
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 12px;">
                    <div>
                        <h3>Principal Stresses</h3>
                        <div class="results-grid">
                            <span class="res-label">σ₁ =</span><span class="res-value">${sorted[0].toFixed(3)}</span>
                            <span class="res-label">σ₂ =</span><span class="res-value">${sorted[1].toFixed(3)}</span>
                            <span class="res-label">σ₃ =</span><span class="res-value">${sorted[2].toFixed(3)}</span>
                        </div>
                    </div>
                    <div>
                        <h3>Analysis</h3>
                        <div class="results-grid">
                            <span class="res-label">τ_max =</span><span class="res-value">${((sorted[0] - sorted[2]) / 2).toFixed(3)}</span>
                            <span class="res-label">σ_vm =</span><span class="res-value">${svm3D.toFixed(3)}</span>
                        </div>
                    </div>
                </div>
            `;

            draw3DMohr(sorted[0], sorted[1], sorted[2]);
        }

        function draw3DMohr(s1, s2, s3) {
            const canvas = document.getElementById('mohr3DCanvas');
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            const margin = 50;
            const width = canvas.width;
            const height = canvas.height;

            const minX = Math.min(s3, 0) - (s1 - s3) * 0.2;
            const maxX = Math.max(s1, 0) + (s1 - s3) * 0.2;
            const R_max = (s1 - s3) / 2;
            const minY = -R_max * 1.5;
            const maxY = R_max * 1.5;

            const rangeX = maxX - minX || 10;
            const rangeY = maxY - minY || 10;
            const scale = Math.min((width - 2 * margin) / rangeX, (height - 2 * margin) / rangeY);

            const toX = (val) => margin + (val - minX) * scale + (width - 2 * margin - rangeX * scale) / 2;
            const toY = (val) => height - (margin + (val - minY) * scale + (height - 2 * margin - rangeY * scale) / 2);

            const cy = toY(0);

            // Draw Axes
            ctx.strokeStyle = '#ccc';
            ctx.beginPath();
            ctx.moveTo(0, cy); ctx.lineTo(width, cy);
            ctx.moveTo(toX(0), 0); ctx.lineTo(toX(0), height);
            ctx.stroke();

            const drawC = (sa, sb, color) => {
                const center = (sa + sb) / 2;
                const r = Math.abs(sa - sb) / 2;
                ctx.beginPath();
                ctx.arc(toX(center), cy, r * scale, 0, 2 * Math.PI);
                ctx.strokeStyle = color;
                ctx.lineWidth = 2;
                ctx.stroke();
            };

            drawC(s1, s3, '#0056b3');
            drawC(s1, s2, '#28a745');
            drawC(s2, s3, '#dc3545');

            ctx.fillStyle = '#333';
            ctx.font = '12px Arial';
            ctx.fillText('σ₁', toX(s1), cy + 15);
            ctx.fillText('σ₂', toX(s2), cy + 15);
            ctx.fillText('σ₃', toX(s3), cy + 15);
        }

        // Initialize
        solve2D();
    </script>
</body>

</html>