<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rigid Body Reaction Force Calculator</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/11.8.0/math.min.js"></script>
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.163.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.163.0/examples/jsm/"
            }
        }
    </script>
    <style>
        body {
            font-family: 'Arial', sans-serif;
            background-color: #e8e8e8;
            margin: 0;
            padding: 8px;
        }

        .app-container {
            max-width: 800px;
            margin: 0 auto;
            background-color: white;
            padding: 12px;
            border-radius: 4px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        h1 {
            text-align: center;
            font-size: 24px;
            font-weight: bold;
            margin: 0 0 8px 0;
            color: #333;
        }

        .button-bar {
            display: flex;
            gap: 4px;
            margin-bottom: 12px;
            flex-wrap: wrap;
        }

        .button-bar button {
            flex: 1;
            min-width: 120px;
            padding: 6px 12px;
            font-size: 13px;
            font-weight: 500;
            border: 1px solid #ccc;
            background: linear-gradient(to bottom, #f8f8f8, #e8e8e8);
            cursor: pointer;
            border-radius: 3px;
        }

        .button-bar button:hover {
            background: linear-gradient(to bottom, #e8e8e8, #d8d8d8);
        }

        .button-bar button:active {
            background: linear-gradient(to bottom, #d8d8d8, #e8e8e8);
        }

        .section {
            margin-bottom: 12px;
            background: #fafafa;
            padding: 5px;
            border: 1px solid #eee;
        }

        .section-title {
            font-weight: bold;
            font-size: 16px;
            margin-bottom: 4px;
            color: #333;
            border-bottom: 2px solid #ddd;
            padding-bottom: 2px;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            font-size: 12px;
            margin-bottom: 4px;
        }

        th {
            background-color: #d4d4d4;
            border: 1px solid #999;
            padding: 4px 6px;
            text-align: center;
            font-weight: bold;
            font-size: 13px;
        }

        td {
            border: 1px solid #ccc;
            padding: 2px 4px;
            text-align: center;
        }

        input[type="number"] {
            width: 100%;
            padding: 2px 2px;
            border: none;
            font-size: 12px;
            text-align: center;
            box-sizing: border-box;
            background-color: transparent;
            outline: none;
            -moz-appearance: textfield;
        }

        input[type="number"]::-webkit-outer-spin-button,
        input[type="number"]::-webkit-inner-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }

        input[type="number"]:focus {
            background-color: #ffffcc;
            outline: 1px solid #4CAF50;
        }

        .output-cell {
            background-color: #c8e6c9;
            font-weight: bold;
        }

        th.output-cell {
            font-weight: bold;
        }

        .add-btn {
            padding: 4px 12px;
            font-size: 12px;
            background-color: #4caf50;
            color: white;
            border: none;
            border-radius: 3px;
            cursor: pointer;
        }

        .add-btn:hover {
            background-color: #45a049;
        }

        .remove-btn {
            padding: 0px 4px;
            font-size: 13px;
            background-color: #9e9e9e;
            color: #333;
            border: none;
            border-radius: 2px;
            cursor: pointer;
        }

        .remove-btn:hover {
            background-color: #da190b;
        }

        #visualization-container {
            width: 100%;
            height: 700px;
            background-color: #f0f0f0;
            border: 1px solid #ccc;
            border-radius: 3px;
            margin-bottom: 8px;
            cursor: grab;
            position: relative;
            overflow: hidden;
        }

        #visualization-container:active {
            cursor: grabbing;
        }

        .view-controls {
            display: flex;
            gap: 6px;
            margin-bottom: 8px;
            align-items: center;
        }

        .view-btn {
            padding: 4px 10px;
            font-size: 12px;
            background-color: #e0e0e0;
            border: 1px solid #aaa;
            border-radius: 3px;
            cursor: pointer;
        }

        .view-btn:hover {
            background-color: #d0d0d0;
        }

        .displacements-box {
            background-color: #e3f2fd;
            border: 1px solid #90caf9;
            border-radius: 3px;
            padding: 8px;
            font-size: 12px;
        }

        .displacements-box h4 {
            font-size: 14px;
            font-weight: bold;
            margin: 0 0 4px 0;
            color: #1976d2;
        }

        .disp-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 4px 8px;
        }

        .toggle-label {
            display: flex;
            align-items: center;
            cursor: pointer;
            font-size: 12px;
        }

        .toggle-switch {
            position: relative;
            display: inline-block;
            width: 32px;
            height: 18px;
            background-color: #ccc;
            border-radius: 9px;
            transition: background-color 0.2s;
            margin-left: 6px;
        }

        .toggle-switch::after {
            content: '';
            position: absolute;
            width: 14px;
            height: 14px;
            border-radius: 50%;
            background-color: white;
            top: 2px;
            left: 2px;
            transition: transform 0.2s;
        }

        .toggle-label input {
            display: none;
        }

        .toggle-label input:checked+.toggle-switch {
            background-color: #2196f3;
        }

        .toggle-label input:checked+.toggle-switch::after {
            transform: translateX(14px);
        }

        .error-message {
            background-color: #ffebee;
            border: 1px solid #ef5350;
            color: #c62828;
            padding: 8px;
            border-radius: 3px;
            font-size: 12px;
            margin-bottom: 8px;
        }

        .index-cell {
            font-weight: bold;
            color: #555;
        }

        /* Updated Label Styles for Centered White Text 
           The .point-label class is now applied to the inner div.
        */
        .point-label {
            /* Center the text perfectly on the coordinate */
            transform: translate(-50%, -50%);
        }

        .point-label {
            background-color: rgba(255, 255, 255, 0.85);
            padding: 1px 2px;
            font-family: Arial, sans-serif;
            font-size: 13px;
            font-weight: bold;
            color: #000;
            pointer-events: none;
            user-select: none;
            white-space: nowrap;
            transform: translate(-50%, -50%);
    </style>
</head>

<body>
    <div class="app-container">
        <h1>Rigid Body Reaction Force Calculator</h1>

        <div class="button-bar">
            <button id="calculate-btn"
                style="background: linear-gradient(to bottom, #f44848, #c62828); color: white; border-color: #b71c1c;">Calculate</button>
            <button id="plot-btn"
                style="background: linear-gradient(to bottom, #e4f2fd, #97aab9); color: black; border-color: #1565C0;">Plot</button>
            <button id="load-config-btn"
                style="background: linear-gradient(to bottom, #e4f2fd, #97aab9); color: black; border-color: #1565C0;">Load
                Data</button>
            <button id="save-config-btn"
                style="background: linear-gradient(to bottom, #e4f2fd, #97aab9); color: black; border-color: #1565C0;">Save
                Data</button>
            <button id="displacements-btn">Displacements</button>
            <input type="file" id="file-input" style="display: none;" accept=".txt,.json">
        </div>

        <div id="error-message" class="error-message" style="display: none;"></div>

        <div class="section">
            <div class="section-title">Applied Loads</div>
            <table id="loads-table">
                <thead>
                    <tr>
                        <th style="width: 50px;">#</th>
                        <th>X</th>
                        <th>Y</th>
                        <th>Z</th>
                        <th>FX</th>
                        <th>FY</th>
                        <th>FZ</th>
                        <th style="width: 40px;"></th>
                    </tr>
                </thead>
                <tbody id="loads-tbody">
                    <tr data-load-index="1">
                        <td class="index-cell">L1</td>
                        <td><input type="number" step="any" class="coord-x" value="1"></td>
                        <td><input type="number" step="any" class="coord-y" value="1"></td>
                        <td><input type="number" step="any" class="coord-z" value="0"></td>
                        <td><input type="number" step="any" class="force-px" value="0"></td>
                        <td><input type="number" step="any" class="force-py" value="0"></td>
                        <td><input type="number" step="any" class="force-pz" value="-100"></td>
                        <td><button class="remove-btn" onclick="removeLoad(this)">×</button></td>
                    </tr>
                </tbody>
            </table>
            <button class="add-btn" onclick="addLoad()">+ Add Load</button>
        </div>

        <div class="section">
            <div class="section-title">General Supports (3-DOF Springs)</div>
            <table id="supports-table">
                <thead>
                    <tr>
                        <th style="width: 50px;">#</th>
                        <th>X</th>
                        <th>Y</th>
                        <th>Z</th>
                        <th>KX</th>
                        <th>KY</th>
                        <th>KZ</th>
                        <th class="output-cell">RX</th>
                        <th class="output-cell">RY</th>
                        <th class="output-cell">RZ</th>
                        <th style="width: 40px;"></th>
                    </tr>
                </thead>
                <tbody id="supports-tbody">
                    <tr data-support-index="1">
                        <td class="index-cell">S1</td>
                        <td><input type="number" step="any" class="coord-x" value="0"></td>
                        <td><input type="number" step="any" class="coord-y" value="0"></td>
                        <td><input type="number" step="any" class="coord-z" value="0"></td>
                        <td><input type="number" step="any" class="stiff-kx" value="1"></td>
                        <td><input type="number" step="any" class="stiff-ky" value="1"></td>
                        <td><input type="number" step="any" class="stiff-kz" value="1"></td>
                        <td class="output-cell reaction-rx">-</td>
                        <td class="output-cell reaction-ry">-</td>
                        <td class="output-cell reaction-rz">-</td>
                        <td><button class="remove-btn" onclick="removeSupport(this)">×</button></td>
                    </tr>
                </tbody>
            </table>
            <button class="add-btn" onclick="addSupport()">+ Add General Support</button>
        </div>

        <div class="section">
            <div class="section-title">Directional Supports (Tie Rod Elements)</div>
            <table id="tierods-table">
                <thead>
                    <tr>
                        <th rowspan="2" style="width: 50px;">Point</th>
                        <th colspan="3">Attachment (On Body)</th>
                        <th colspan="3">Anchor (Fixed in Space)</th>
                        <th rowspan="2">K Axial</th>
                        <th colspan="3" class="output-cell">Reaction Components</th>
                        <th rowspan="2" style="width: 40px;"></th>
                    </tr>
                    <tr>
                        <th style="font-size: 10px;">X</th>
                        <th style="font-size: 10px;">Y</th>
                        <th style="font-size: 10px;">Z</th>
                        <th style="font-size: 10px;">X</th>
                        <th style="font-size: 10px;">Y</th>
                        <th style="font-size: 10px;">Z</th>
                        <th class="output-cell" style="font-size: 10px;">RX</th>
                        <th class="output-cell" style="font-size: 10px;">RY</th>
                        <th class="output-cell" style="font-size: 10px;">RZ</th>
                    </tr>
                </thead>
                <tbody id="tierods-tbody">
                </tbody>
            </table>
            <button class="add-btn" onclick="addTieRod()">+ Add Tie Rod</button>
        </div>

        <div id="displacements-section" style="display: none;">
            <div class="displacements-box">
                <h4>Global Rigid Body Displacements (Origin)</h4>
                <div class="disp-grid" id="displacements-grid">
                    <span>δx: -</span>
                    <span>δy: -</span>
                    <span>δz: -</span>
                    <span>θx: - rad</span>
                    <span>θy: - rad</span>
                    <span>θz: - rad</span>
                </div>
            </div>
        </div>

        <div id="plot-section" style="display: none;">
            <div class="view-controls">
                <button class="view-btn" id="view-top-btn">Top</button>
                <button class="view-btn" id="view-front-btn">Front</button>
                <button class="view-btn" id="view-right-btn">Right</button>
                <label class="toggle-label">
                    Ortho
                    <input type="checkbox" id="ortho-toggle">
                    <span class="toggle-switch"></span>
                </label>
            </div>
            <div id="visualization-container"></div>
        </div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { Line2 } from 'three/addons/lines/Line2.js';
        import { LineMaterial } from 'three/addons/lines/LineMaterial.js';
        import { LineGeometry } from 'three/addons/lines/LineGeometry.js';
        import { CSS2DRenderer, CSS2DObject } from 'three/addons/renderers/CSS2DRenderer.js';

        // --- Global Variables ---
        const loadsTbody = document.getElementById('loads-tbody');
        const supportsTbody = document.getElementById('supports-tbody');
        const tieRodsTbody = document.getElementById('tierods-tbody');

        const calculateBtn = document.getElementById('calculate-btn');
        const plotBtn = document.getElementById('plot-btn');
        const displacementsBtn = document.getElementById('displacements-btn');
        const saveConfigBtn = document.getElementById('save-config-btn');
        const loadConfigBtn = document.getElementById('load-config-btn');
        const fileInput = document.getElementById('file-input');
        const errorMessageDiv = document.getElementById('error-message');
        const visualizationContainer = document.getElementById('visualization-container');
        const plotSection = document.getElementById('plot-section');
        const displacementsSection = document.getElementById('displacements-section');
        const displacementsGrid = document.getElementById('displacements-grid');

        let lastCalculationResults = null;

        // --- three.js Variables ---
        let scene, perspectiveCamera, orthographicCamera, camera, renderer, labelRenderer, controls, visualizationGroup, axesHelper;
        let resizeObserver;
        const initialCameraPosition = new THREE.Vector3(5, 5, 5);
        let isOrthographic = false;
        let threeInitialized = false;

        // --- Add/Remove Functions ---
        window.addLoad = function () {
            const newIndex = loadsTbody.children.length + 1;
            const row = loadsTbody.insertRow();
            row.setAttribute('data-load-index', newIndex);
            row.innerHTML = `
                <td class="index-cell">L${newIndex}</td>
                <td><input type="number" step="any" class="coord-x" value="0"></td>
                <td><input type="number" step="any" class="coord-y" value="0"></td>
                <td><input type="number" step="any" class="coord-z" value="0"></td>
                <td><input type="number" step="any" class="force-px" value="0"></td>
                <td><input type="number" step="any" class="force-py" value="0"></td>
                <td><input type="number" step="any" class="force-pz" value="0"></td>
                <td><button class="remove-btn" onclick="removeLoad(this)">×</button></td>
            `;
        }

        window.removeLoad = function (btn) {
            if (loadsTbody.children.length <= 1) {
                alert('You need at least one load point defined.');
                return;
            }
            btn.closest('tr').remove();
            updateLoadIndices();
        }

        function updateLoadIndices() {
            Array.from(loadsTbody.children).forEach((row, index) => {
                row.setAttribute('data-load-index', index + 1);
                row.cells[0].textContent = index + 1;
            });
        }

        window.addSupport = function () {
            const newIndex = supportsTbody.children.length + 1;
            const row = supportsTbody.insertRow();
            row.setAttribute('data-support-index', newIndex);
            row.innerHTML = `
                <td class="index-cell">S${newIndex}</td>
                <td><input type="number" step="any" class="coord-x" value="0"></td>
                <td><input type="number" step="any" class="coord-y" value="0"></td>
                <td><input type="number" step="any" class="coord-z" value="0"></td>
                <td><input type="number" step="any" class="stiff-kx" value="1"></td>
                <td><input type="number" step="any" class="stiff-ky" value="1"></td>
                <td><input type="number" step="any" class="stiff-kz" value="1"></td>
                <td class="output-cell reaction-rx">-</td>
                <td class="output-cell reaction-ry">-</td>
                <td class="output-cell reaction-rz">-</td>
                <td><button class="remove-btn" onclick="removeSupport(this)">×</button></td>
            `;
        }

        window.removeSupport = function (btn) {
            btn.closest('tr').remove();
            updateSupportIndices();
        }

        function updateSupportIndices() {
            Array.from(supportsTbody.children).forEach((row, index) => {
                row.setAttribute('data-support-index', index + 1);
                row.cells[0].textContent = index + 1;
            });
        }

        window.addTieRod = function () {
            const newIndex = tieRodsTbody.children.length + 1;
            const row = tieRodsTbody.insertRow();
            row.setAttribute('data-tierod-index', newIndex);
            row.innerHTML = `
                <td class="index-cell">TR${newIndex}</td>
                <td><input type="number" step="any" class="att-x" value="0"></td>
                <td><input type="number" step="any" class="att-y" value="0"></td>
                <td><input type="number" step="any" class="att-z" value="0"></td>
                <td><input type="number" step="any" class="anc-x" value="0"></td>
                <td><input type="number" step="any" class="anc-y" value="1"></td>
                <td><input type="number" step="any" class="anc-z" value="0"></td>
                <td><input type="number" step="any" class="stiff-axial" value="1"></td>
                <td class="output-cell reaction-rx">-</td>
                <td class="output-cell reaction-ry">-</td>
                <td class="output-cell reaction-rz">-</td>
                <td><button class="remove-btn" onclick="removeTieRod(this)">×</button></td>
            `;
        }

        window.removeTieRod = function (btn) {
            btn.closest('tr').remove();
            updateTieRodIndices();
        }

        function updateTieRodIndices() {
            Array.from(tieRodsTbody.children).forEach((row, index) => {
                row.setAttribute('data-tierod-index', index + 1);
                row.cells[0].textContent = index + 1;
            });
        }


        // --- Calculation Logic ---
        function calculateReactions() {
            errorMessageDiv.style.display = 'none';
            errorMessageDiv.textContent = '';

            supportsTbody.querySelectorAll('.reaction-rx, .reaction-ry, .reaction-rz').forEach(cell => {
                cell.textContent = '-';
            });
            tieRodsTbody.querySelectorAll('.reaction-rx, .reaction-ry, .reaction-rz').forEach(cell => {
                cell.textContent = '-';
            });

            let currentSupportsData = [];
            let currentLoadsData = [];
            let currentCalculatedReactions = [];
            let currentDisplacements = [];

            try {
                const supportRows = supportsTbody.querySelectorAll('tr');
                supportRows.forEach((row, index) => {
                    const x = parseFloat(row.querySelector('.coord-x').value);
                    const y = parseFloat(row.querySelector('.coord-y').value);
                    const z = parseFloat(row.querySelector('.coord-z').value);
                    const kx = parseFloat(row.querySelector('.stiff-kx').value);
                    const ky = parseFloat(row.querySelector('.stiff-ky').value);
                    const kz = parseFloat(row.querySelector('.stiff-kz').value);

                    if (isNaN(x) || isNaN(y) || isNaN(z) || isNaN(kx) || isNaN(ky) || isNaN(kz)) throw new Error(`Invalid input for General Support #${index + 1}.`);
                    if (kx < 0 || ky < 0 || kz < 0) throw new Error(`Stiffness values cannot be negative for General Support #${index + 1}.`);

                    currentSupportsData.push({ index: index + 1, type: 'general', point: { x, y, z }, kx, ky, kz });
                });

                const tieRodRows = tieRodsTbody.querySelectorAll('tr');
                tieRodRows.forEach((row, index) => {
                    const ax = parseFloat(row.querySelector('.att-x').value);
                    const ay = parseFloat(row.querySelector('.att-y').value);
                    const az = parseFloat(row.querySelector('.att-z').value);
                    const nx = parseFloat(row.querySelector('.anc-x').value);
                    const ny = parseFloat(row.querySelector('.anc-y').value);
                    const nz = parseFloat(row.querySelector('.anc-z').value);
                    const kAxial = parseFloat(row.querySelector('.stiff-axial').value);

                    if (isNaN(ax) || isNaN(ay) || isNaN(az) || isNaN(nx) || isNaN(ny) || isNaN(nz) || isNaN(kAxial)) throw new Error(`Invalid input for Tie Rod #${index + 1}.`);
                    if (kAxial < 0) throw new Error(`Axial stiffness cannot be negative for Tie Rod #${index + 1}.`);
                    if (Math.abs(ax - nx) < 1e-9 && Math.abs(ay - ny) < 1e-9 && Math.abs(az - nz) < 1e-9) throw new Error(`Attachment and Anchor points cannot be identical for Tie Rod #${index + 1}.`);

                    currentSupportsData.push({ index: index + 1, type: 'tie-rod', attachPoint: { x: ax, y: ay, z: az }, anchorPoint: { x: nx, y: ny, z: nz }, kAxial });
                });

                const loadRows = loadsTbody.querySelectorAll('tr');
                loadRows.forEach((row, index) => {
                    const x = parseFloat(row.querySelector('.coord-x').value);
                    const y = parseFloat(row.querySelector('.coord-y').value);
                    const z = parseFloat(row.querySelector('.coord-z').value);
                    const px = parseFloat(row.querySelector('.force-px').value);
                    const py = parseFloat(row.querySelector('.force-py').value);
                    const pz = parseFloat(row.querySelector('.force-pz').value);

                    if (isNaN(x) || isNaN(y) || isNaN(z) || isNaN(px) || isNaN(py) || isNaN(pz)) throw new Error(`Invalid input for Load #${index + 1}.`);
                    currentLoadsData.push({ index: index + 1, x, y, z, px, py, pz });
                });

                if (currentSupportsData.length === 0) throw new Error("At least one support (General or Tie Rod) must be defined.");
                if (currentLoadsData.length === 0) throw new Error("At least one load point must be defined.");

                let F_ext = math.zeros(6, 1);
                currentLoadsData.forEach(load => {
                    F_ext = math.add(F_ext, math.matrix([
                        [load.px], [load.py], [load.pz],
                        [load.y * load.pz - load.z * load.py],
                        [load.z * load.px - load.x * load.pz],
                        [load.x * load.py - load.y * load.px]
                    ]));
                });

                let K_global = math.zeros(6, 6);
                currentSupportsData.forEach(support => {
                    let Ki, Ti, attachX, attachY, attachZ;
                    if (support.type === 'general') {
                        const { x, y, z } = support.point;
                        attachX = x; attachY = y; attachZ = z;
                        Ki = math.diag([support.kx, support.ky, support.kz]);
                    } else {
                        const { x: ax, y: ay, z: az } = support.attachPoint;
                        const { x: nx, y: ny, z: nz } = support.anchorPoint;
                        attachX = ax; attachY = ay; attachZ = az;
                        const dx = ax - nx, dy = ay - ny, dz = az - nz;
                        const len = Math.sqrt(dx * dx + dy * dy + dz * dz);
                        if (len < 1e-9) throw new Error(`Zero length Tie Rod detected.`);
                        const ux = dx / len, uy = dy / len, uz = dz / len;
                        const u = math.matrix([[ux], [uy], [uz]]);
                        const uuT = math.multiply(u, math.transpose(u));
                        Ki = math.multiply(uuT, support.kAxial);
                    }
                    Ti = math.matrix([
                        [1, 0, 0, 0, attachZ, -attachY],
                        [0, 1, 0, -attachZ, 0, attachX],
                        [0, 0, 1, attachY, -attachX, 0]
                    ]);
                    support.Ki = Ki; support.Ti = Ti;
                    K_global = math.add(K_global, math.multiply(math.transpose(Ti), Ki, Ti));
                });

                let K_inv;
                try {
                    K_inv = math.inv(K_global);
                } catch (error) {
                    throw new Error("Cannot calculate reactions. Global stiffness matrix is singular.");
                }
                const D_matrix = math.multiply(K_inv, F_ext);
                currentDisplacements = D_matrix.valueOf().flat();

                currentSupportsData.forEach(support => {
                    const { Ki, Ti } = support;
                    const Ri_body_on_support_matrix = math.multiply(Ki, Ti, D_matrix);
                    const Ri_support_on_body_matrix = math.multiply(Ri_body_on_support_matrix, -1);
                    const reactionForces = Ri_support_on_body_matrix.valueOf().flat();
                    const reactionPoint = (support.type === 'general') ? support.point : support.attachPoint;

                    currentCalculatedReactions.push({
                        index: support.index,
                        type: support.type,
                        x: reactionPoint.x, y: reactionPoint.y, z: reactionPoint.z,
                        rx: reactionForces[0], ry: reactionForces[1], rz: reactionForces[2],
                        anchorPoint: support.type === 'tie-rod' ? support.anchorPoint : undefined
                    });
                });

                lastCalculationResults = { reactions: currentCalculatedReactions, displacements: currentDisplacements, supports: currentSupportsData, loads: currentLoadsData };
                displayReactions(currentCalculatedReactions);
                displayDisplacements(currentDisplacements);

            } catch (error) {
                console.error("Calculation Error:", error);
                errorMessageDiv.textContent = `Error: ${error.message}`;
                errorMessageDiv.style.display = 'block';
                lastCalculationResults = null;
            }
        }

        function formatReactionValue(val) {
            const absVal = Math.abs(val);
            if (absVal !== 0 && (absVal >= 1e6 || absVal < 1e-3)) return val.toPrecision(6);
            const sigFigNum = parseFloat(val.toPrecision(6));
            const factor = Math.pow(10, 3);
            return (Math.round(sigFigNum * factor) / factor).toString();
        }

        function displayReactions(reactions) {
            reactions.forEach(r => {
                let row = (r.type === 'general') ? supportsTbody.querySelector(`tr[data-support-index="${r.index}"]`) : tieRodsTbody.querySelector(`tr[data-tierod-index="${r.index}"]`);
                if (row) {
                    row.querySelector('.reaction-rx').textContent = formatReactionValue(r.rx);
                    row.querySelector('.reaction-ry').textContent = formatReactionValue(r.ry);
                    row.querySelector('.reaction-rz').textContent = formatReactionValue(r.rz);
                }
            });
        }

        function displayDisplacements(displacements) {
            displacementsGrid.innerHTML = `
                <span>δx: ${displacements[0].toExponential(3)}</span> <span>δy: ${displacements[1].toExponential(3)}</span> <span>δz: ${displacements[2].toExponential(3)}</span>
                <span>θx: ${displacements[3].toExponential(3)} rad</span> <span>θy: ${displacements[4].toExponential(3)} rad</span> <span>θz: ${displacements[5].toExponential(3)} rad</span>
            `;
        }

        // --- Configuration ---
        function saveConfiguration() {
            const supports = [];
            supportsTbody.querySelectorAll('tr').forEach(row => {
                supports.push({ type: 'general', x: row.querySelector('.coord-x').value, y: row.querySelector('.coord-y').value, z: row.querySelector('.coord-z').value, kx: row.querySelector('.stiff-kx').value, ky: row.querySelector('.stiff-ky').value, kz: row.querySelector('.stiff-kz').value });
            });
            tieRodsTbody.querySelectorAll('tr').forEach(row => {
                supports.push({ type: 'tie-rod', ax: row.querySelector('.att-x').value, ay: row.querySelector('.att-y').value, az: row.querySelector('.att-z').value, nx: row.querySelector('.anc-x').value, ny: row.querySelector('.anc-y').value, nz: row.querySelector('.anc-z').value, kAxial: row.querySelector('.stiff-axial').value });
            });
            const loads = [];
            loadsTbody.querySelectorAll('tr').forEach(row => {
                loads.push({ x: row.querySelector('.coord-x').value, y: row.querySelector('.coord-y').value, z: row.querySelector('.coord-z').value, px: row.querySelector('.force-px').value, py: row.querySelector('.force-py').value, pz: row.querySelector('.force-pz').value });
            });
            const config = { supports, loads };
            const blob = new Blob([JSON.stringify(config, null, 2)], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url; a.download = 'rigid_body_config.txt';
            document.body.appendChild(a); a.click(); document.body.removeChild(a); URL.revokeObjectURL(url);
        }

        function loadConfiguration(event) {
            const file = event.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = function (e) {
                try {
                    const config = JSON.parse(e.target.result);
                    supportsTbody.innerHTML = ''; tieRodsTbody.innerHTML = ''; loadsTbody.innerHTML = '';
                    if (config.supports) {
                        config.supports.forEach((s) => {
                            if (s.type === 'tie-rod') {
                                addTieRod(); const row = tieRodsTbody.lastElementChild;
                                row.querySelector('.att-x').value = s.ax; row.querySelector('.att-y').value = s.ay; row.querySelector('.att-z').value = s.az;
                                row.querySelector('.anc-x').value = s.nx; row.querySelector('.anc-y').value = s.ny; row.querySelector('.anc-z').value = s.nz;
                                row.querySelector('.stiff-axial').value = s.kAxial;
                            } else {
                                addSupport(); const row = supportsTbody.lastElementChild;
                                row.querySelector('.coord-x').value = s.x; row.querySelector('.coord-y').value = s.y; row.querySelector('.coord-z').value = s.z;
                                row.querySelector('.stiff-kx').value = s.kx; row.querySelector('.stiff-ky').value = s.ky; row.querySelector('.stiff-kz').value = s.kz;
                            }
                        });
                    }
                    if (config.loads) {
                        config.loads.forEach((l) => {
                            addLoad(); const row = loadsTbody.lastElementChild;
                            row.querySelector('.coord-x').value = l.x; row.querySelector('.coord-y').value = l.y; row.querySelector('.coord-z').value = l.z;
                            row.querySelector('.force-px').value = l.px; row.querySelector('.force-py').value = l.py; row.querySelector('.force-pz').value = l.pz;
                        });
                    }
                    fileInput.value = '';
                } catch (error) { alert('Failed to parse file.'); }
            };
            reader.readAsText(file);
        }

        // --- Three.js ---
        function initThreeJS() {
            if (threeInitialized) return;

            const width = visualizationContainer.clientWidth;
            const height = visualizationContainer.clientHeight;

            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xf0f0f0);

            perspectiveCamera = new THREE.PerspectiveCamera(50, width / height, 0.1, 2000);
            perspectiveCamera.position.copy(initialCameraPosition);

            const frustumSize = 10;
            const aspect = width / height;
            orthographicCamera = new THREE.OrthographicCamera(
                frustumSize * aspect / -2, frustumSize * aspect / 2,
                frustumSize / 2, frustumSize / -2,
                0.1, 2000
            );
            orthographicCamera.position.copy(initialCameraPosition);

            camera = perspectiveCamera;
            isOrthographic = false;
            document.getElementById('ortho-toggle').checked = false;

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(width, height);
            renderer.domElement.style.width = '100%';
            renderer.domElement.style.height = '100%';
            visualizationContainer.appendChild(renderer.domElement);

            labelRenderer = new CSS2DRenderer();
            labelRenderer.setSize(width, height);
            labelRenderer.domElement.style.position = 'absolute';
            labelRenderer.domElement.style.top = '0px';
            labelRenderer.domElement.style.left = '0px';
            labelRenderer.domElement.style.width = '100%';
            labelRenderer.domElement.style.height = '100%';
            labelRenderer.domElement.style.pointerEvents = 'none';
            visualizationContainer.appendChild(labelRenderer.domElement);

            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.screenSpacePanning = true;

            const ambientLight = new THREE.AmbientLight(0xcccccc, 0.8);
            scene.add(ambientLight);
            const directionalLight1 = new THREE.DirectionalLight(0xffffff, 0.6);
            directionalLight1.position.set(1, 1, 0.5).normalize();
            scene.add(directionalLight1);

            axesHelper = new THREE.AxesHelper(1);
            scene.add(axesHelper);

            visualizationGroup = new THREE.Group();
            scene.add(visualizationGroup);

            resizeObserver = new ResizeObserver(() => {
                onWindowResize();
            });
            resizeObserver.observe(visualizationContainer);

            animate();
            threeInitialized = true;
        }

        function onWindowResize() {
            if (!camera || !renderer || !labelRenderer || !visualizationContainer) return;

            const width = visualizationContainer.clientWidth;
            const height = visualizationContainer.clientHeight;

            camera.aspect = width / height;
            camera.updateProjectionMatrix();

            if (isOrthographic) {
                const aspect = width / height;
                const frustumSize = (orthographicCamera.top - orthographicCamera.bottom);
                const newWidth = frustumSize * aspect;
                orthographicCamera.left = -newWidth / 2;
                orthographicCamera.right = newWidth / 2;
                orthographicCamera.updateProjectionMatrix();
            }

            renderer.setSize(width, height, false);
            labelRenderer.setSize(width, height);
        }

        function animate() {
            requestAnimationFrame(animate);
            if (controls) controls.update();
            if (renderer && scene && camera) {
                renderer.render(scene, camera);
                if (labelRenderer) labelRenderer.render(scene, camera);
            }
        }

        function clearVisualization() {
            if (visualizationGroup) {
                while (visualizationGroup.children.length > 0) {
                    const child = visualizationGroup.children[0];
                    visualizationGroup.remove(child);
                    if (child.geometry) child.geometry.dispose();
                    if (child.material) {
                        if (Array.isArray(child.material)) child.material.forEach(m => m.dispose());
                        else child.material.dispose();
                    }
                    if (child.isLine2 && child.geometry) child.geometry.dispose();
                }
            }
        }

        // Updated helper to create a label
        function createLabel(text, positionVector) {
            // Create a wrapper div to handle the CSS2DObject positioning (top-left at coordinate)
            const wrapperDiv = document.createElement('div');

            // Create the inner div that centers the text
            const innerDiv = document.createElement('div');
            innerDiv.className = 'point-label';
            innerDiv.textContent = text;

            wrapperDiv.appendChild(innerDiv);

            const label = new CSS2DObject(wrapperDiv);
            label.position.copy(positionVector);
            return label;
        }

        function updateVisualization(supportsInput, loadsInput, reactionsResult) {
            clearVisualization();
            if (!supportsInput || !loadsInput || !reactionsResult || !visualizationGroup) return;

            let allPoints = [];
            reactionsResult.forEach(r => {
                allPoints.push(new THREE.Vector3(r.x, r.y, r.z));
                if (r.anchorPoint) allPoints.push(new THREE.Vector3(r.anchorPoint.x, r.anchorPoint.y, r.anchorPoint.z));
            });
            loadsInput.forEach(l => allPoints.push(new THREE.Vector3(l.x, l.y, l.z)));

            let maxPointDistance = 0;
            if (allPoints.length >= 2) {
                for (let i = 0; i < allPoints.length; i++) {
                    for (let j = i + 1; j < allPoints.length; j++) maxPointDistance = Math.max(maxPointDistance, allPoints[i].distanceTo(allPoints[j]));
                }
            }
            if (maxPointDistance < 1e-6) maxPointDistance = 10.0;

            const pointRadius = maxPointDistance / 40.0;
            const anchorSize = pointRadius * 1.2;
            const targetVisualLength = maxPointDistance * 0.50;
            let maxReactionMagnitude = 0;
            reactionsResult.forEach(r => maxReactionMagnitude = Math.max(maxReactionMagnitude, Math.sqrt(r.rx ** 2 + r.ry ** 2 + r.rz ** 2)));
            const reactionScaleFactor = (maxReactionMagnitude > 1e-9) ? targetVisualLength / maxReactionMagnitude : 0;
            const fixedLoadLength = targetVisualLength;

            const supportMaterial = new THREE.MeshStandardMaterial({ color: 0x007bff, roughness: 0.5 });
            const loadMaterial = new THREE.MeshStandardMaterial({ color: 0xffa500, roughness: 0.5 });
            const anchorMaterial = new THREE.MeshStandardMaterial({ color: 0x6c757d, roughness: 0.7 });
            const tieRodLineMaterial = new LineMaterial({ color: 0x6c757d, linewidth: 2, dashed: false, resolution: new THREE.Vector2(visualizationContainer.clientWidth, visualizationContainer.clientHeight) });

            reactionsResult.forEach(r => {
                const reactionPointVec = new THREE.Vector3(r.x, r.y, r.z);
                const supportMesh = new THREE.Mesh(new THREE.SphereGeometry(pointRadius, 16, 16), supportMaterial);
                supportMesh.position.copy(reactionPointVec);
                visualizationGroup.add(supportMesh);

                // Add Label (Centered)
                const labelText = r.type === 'general' ? `S${r.index}` : `TR${r.index}`;
                // Use exact position, no offset
                const label = createLabel(labelText, reactionPointVec);
                visualizationGroup.add(label);

                if (r.type === 'tie-rod' && r.anchorPoint) {
                    const anchorPointVec = new THREE.Vector3(r.anchorPoint.x, r.anchorPoint.y, r.anchorPoint.z);
                    const anchorMesh = new THREE.Mesh(new THREE.BoxGeometry(anchorSize, anchorSize, anchorSize), anchorMaterial);
                    anchorMesh.position.copy(anchorPointVec);
                    visualizationGroup.add(anchorMesh);
                    const points = [reactionPointVec.x, reactionPointVec.y, reactionPointVec.z, anchorPointVec.x, anchorPointVec.y, anchorPointVec.z];
                    const lineGeom = new LineGeometry();
                    lineGeom.setPositions(points);
                    const tieRodLine = new Line2(lineGeom, tieRodLineMaterial);
                    tieRodLine.computeLineDistances(); tieRodLine.scale.set(1, 1, 1);
                    visualizationGroup.add(tieRodLine);
                }
                const reactionVec = new THREE.Vector3(r.rx, r.ry, r.rz);
                const reactionMag = reactionVec.length();
                if (reactionMag > 1e-9 && reactionScaleFactor > 0) {
                    const direction = reactionVec.normalize();
                    const length = reactionMag * reactionScaleFactor;
                    const arrowHelper = new THREE.ArrowHelper(direction, reactionPointVec, length, 0xdc3545, Math.max(length * 0.2, pointRadius * 0.5), Math.max(length * 0.1, pointRadius * 0.25));
                    visualizationGroup.add(arrowHelper);
                }
            });

            loadsInput.forEach(l => {
                const loadPointVec = new THREE.Vector3(l.x, l.y, l.z);
                const loadMesh = new THREE.Mesh(new THREE.SphereGeometry(pointRadius, 16, 16), loadMaterial);
                loadMesh.position.copy(loadPointVec);
                visualizationGroup.add(loadMesh);

                // Add Label (Centered)
                const label = createLabel(`L${l.index}`, loadPointVec);
                visualizationGroup.add(label);

                const forceVec = new THREE.Vector3(l.px, l.py, l.pz);
                const forceMag = forceVec.length();
                if (forceMag > 1e-9) {
                    const direction = forceVec.normalize();
                    const length = fixedLoadLength;
                    const arrowHelper = new THREE.ArrowHelper(direction, loadPointVec, length, 0x28a745, Math.max(length * 0.2, pointRadius * 0.5), Math.max(length * 0.1, pointRadius * 0.25));
                    visualizationGroup.add(arrowHelper);
                }
            });

            const box = new THREE.Box3().setFromObject(visualizationGroup);
            if (!box.isEmpty()) {
                const size = box.getSize(new THREE.Vector3());
                const maxDim = Math.max(size.x, size.y, size.z);
                scene.remove(axesHelper);
                axesHelper = new THREE.AxesHelper(maxDim > 0 ? maxDim * 0.6 : 1);
                scene.add(axesHelper);
            }
        }

        function setView(axis) {
            if (!camera || !controls || visualizationGroup.children.length === 0) return;
            const box = new THREE.Box3().setFromObject(visualizationGroup);
            if (box.isEmpty()) return;
            const center = box.getCenter(new THREE.Vector3());
            const size = box.getSize(new THREE.Vector3());
            const maxDim = Math.max(size.x, size.y, size.z);
            let viewAxisNormal = new THREE.Vector3(); let upVector = new THREE.Vector3(0, 1, 0);
            switch (axis) {
                case 'Y': viewAxisNormal.set(0, 1, 0); upVector.set(0, 0, -1); break;
                case 'Z': viewAxisNormal.set(0, 0, 1); upVector.set(0, 1, 0); break;
                case 'X': viewAxisNormal.set(1, 0, 0); upVector.set(0, 1, 0); break;
            }
            const distance = maxDim * 2;
            camera.position.copy(viewAxisNormal).multiplyScalar(distance).add(center);
            camera.up.copy(upVector); camera.lookAt(center); camera.updateProjectionMatrix();
            controls.target.copy(center); controls.update();
        }

        function handleOrthoToggle(event) {
            const useOrtho = event.target.checked;
            if (useOrtho === isOrthographic) return;
            const oldCamera = camera;
            if (useOrtho) {
                camera = orthographicCamera;
                isOrthographic = true;
                const distance = perspectiveCamera.position.distanceTo(controls.target);
                const visibleHeight = 2 * Math.tan(THREE.MathUtils.degToRad(perspectiveCamera.fov / 2)) * distance;
                const visibleWidth = visibleHeight * perspectiveCamera.aspect;
                camera.left = -visibleWidth / 2; camera.right = visibleWidth / 2; camera.top = visibleHeight / 2; camera.bottom = -visibleHeight / 2; camera.zoom = 1;
            } else {
                camera = perspectiveCamera;
                isOrthographic = false;
            }
            camera.position.copy(oldCamera.position); camera.up.copy(oldCamera.up); camera.lookAt(controls.target); camera.updateProjectionMatrix();
            controls.object = camera; controls.update();
        }

        calculateBtn.addEventListener('click', calculateReactions);
        plotBtn.addEventListener('click', () => {
            if (!lastCalculationResults) { alert('Please calculate first.'); return; }
            plotSection.style.display = 'block'; displacementsSection.style.display = 'none';
            if (!threeInitialized) initThreeJS();
            updateVisualization(lastCalculationResults.supports, lastCalculationResults.loads, lastCalculationResults.reactions);
        });
        displacementsBtn.addEventListener('click', () => {
            if (!lastCalculationResults) { alert('Please calculate first.'); return; }
            displacementsSection.style.display = 'block'; plotSection.style.display = 'none';
        });
        saveConfigBtn.addEventListener('click', saveConfiguration);
        loadConfigBtn.addEventListener('click', () => fileInput.click());
        fileInput.addEventListener('change', loadConfiguration);
        document.getElementById('view-top-btn').addEventListener('click', () => setView('Y'));
        document.getElementById('view-front-btn').addEventListener('click', () => setView('Z'));
        document.getElementById('view-right-btn').addEventListener('click', () => setView('X'));
        document.getElementById('ortho-toggle').addEventListener('change', handleOrthoToggle);

    </script>
</body>

</html>