<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rigid Body Reaction Force Calculator</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/11.8.0/math.min.js"></script>
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.163.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.163.0/examples/jsm/"
            }
        }
    </script>
    <style>
        body {
            font-family: 'Arial', sans-serif;
            background-color: #e8e8e8;
            margin: 0;
            padding: 8px;
        }

        .container {
            max-width: 1000px;
            margin: 0 auto;
            background-color: white;
            padding: 12px;
            border-radius: 4px;
        }

        h1 {
            text-align: center;
            font-size: 18px;
            font-weight: bold;
            margin: 0 0 8px 0;
            color: #333;
        }

        .button-bar {
            display: flex;
            gap: 4px;
            margin-bottom: 12px;
            flex-wrap: wrap;
        }

        .button-bar button {
            flex: 1;
            min-width: 120px;
            padding: 6px 12px;
            font-size: 13px;
            font-weight: 500;
            border: 1px solid #ccc;
            background: linear-gradient(to bottom, #f8f8f8, #e8e8e8);
            cursor: pointer;
            border-radius: 3px;
        }

        .button-bar button:hover {
            background: linear-gradient(to bottom, #e8e8e8, #d8d8d8);
        }

        .button-bar button:active {
            background: linear-gradient(to bottom, #d8d8d8, #e8e8e8);
        }

        .section {
            margin-bottom: 12px;
        }

        .section-title {
            font-weight: bold;
            font-size: 14px;
            margin-bottom: 4px;
            color: #333;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            font-size: 12px;
            margin-bottom: 4px;
        }

        th {
            background-color: #d4d4d4;
            border: 1px solid #999;
            padding: 4px 6px;
            text-align: center;
            font-weight: bold;
            font-size: 12px;
        }

        td {
            border: 1px solid #ccc;
            padding: 2px 4px;
            text-align: center;
        }

        input[type="number"] {
            width: 100%;
            padding: 2px 2px;
            border: none;
            font-size: 12px;
            text-align: center;
            box-sizing: border-box;
            background-color: transparent;
            outline: none;
            -moz-appearance: textfield;
            /* Firefox */
        }

        /* Chrome, Safari, Edge, Opera */
        input[type="number"]::-webkit-outer-spin-button,
        input[type="number"]::-webkit-inner-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }

        input[type="number"]:focus {
            background-color: #ffffcc;
            outline: 1px solid #4CAF50;
        }

        .output-cell {
            background-color: #c8e6c9;
            font-weight: 500;
        }

        .add-btn {
            padding: 4px 12px;
            font-size: 12px;
            background-color: #4caf50;
            color: white;
            border: none;
            border-radius: 3px;
            cursor: pointer;
        }

        .add-btn:hover {
            background-color: #45a049;
        }

        .remove-btn {
            padding: 0px 4px;
            font-size: 13px;
            background-color: #9e9e9e;
            color: #333;
            border: none;
            border-radius: 2px;
            cursor: pointer;
        }

        .remove-btn:hover {
            background-color: #da190b;
        }

        #visualization-container {
            width: 100%;
            height: 350px;
            background-color: #f0f0f0;
            border: 1px solid #ccc;
            border-radius: 3px;
            margin-bottom: 8px;
            cursor: grab;
            position: relative;
        }

        #visualization-container:active {
            cursor: grabbing;
        }

        .view-controls {
            display: flex;
            gap: 6px;
            margin-bottom: 8px;
            align-items: center;
        }

        .view-btn {
            padding: 4px 10px;
            font-size: 12px;
            background-color: #e0e0e0;
            border: 1px solid #aaa;
            border-radius: 3px;
            cursor: pointer;
        }

        .view-btn:hover {
            background-color: #d0d0d0;
        }

        .displacements-box {
            background-color: #e3f2fd;
            border: 1px solid #90caf9;
            border-radius: 3px;
            padding: 8px;
            font-size: 12px;
        }

        .displacements-box h4 {
            font-size: 12px;
            font-weight: bold;
            margin: 0 0 4px 0;
            color: #1976d2;
        }

        .disp-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 4px 8px;
        }

        .toggle-label {
            display: flex;
            align-items: center;
            cursor: pointer;
            font-size: 12px;
        }

        .toggle-switch {
            position: relative;
            display: inline-block;
            width: 32px;
            height: 18px;
            background-color: #ccc;
            border-radius: 9px;
            transition: background-color 0.2s;
            margin-left: 6px;
        }

        .toggle-switch::after {
            content: '';
            position: absolute;
            width: 14px;
            height: 14px;
            border-radius: 50%;
            background-color: white;
            top: 2px;
            left: 2px;
            transition: transform 0.2s;
        }

        .toggle-label input {
            display: none;
        }

        .toggle-label input:checked+.toggle-switch {
            background-color: #2196f3;
        }

        .toggle-label input:checked+.toggle-switch::after {
            transform: translateX(14px);
        }

        .error-message {
            background-color: #ffebee;
            border: 1px solid #ef5350;
            color: #c62828;
            padding: 8px;
            border-radius: 3px;
            font-size: 12px;
            margin-bottom: 8px;
        }

        .index-cell {
            font-weight: bold;
            color: #555;
        }
    </style>
</head>

<body>
    <div class="container">
        <h1>Rigid Body Reaction Force Calculator</h1>

        <div class="button-bar">
            <button id="calculate-btn"
                style="background: linear-gradient(to bottom, #f44848, #c62828); color: white; border-color: #b71c1c;">Calculate</button>
            <button id="plot-btn"
                style="background: linear-gradient(to bottom, #e4f2fd, #97aab9); color: black; border-color: #1565C0;">Plot</button>
            <button id="load-config-btn"
                style="background: linear-gradient(to bottom, #e4f2fd, #97aab9); color: black; border-color: #1565C0;">Load
                Data</button>
            <button id="save-config-btn"
                style="background: linear-gradient(to bottom, #e4f2fd, #97aab9); color: black; border-color: #1565C0;">Save
                Data</button>
            <button id="displacements-btn">Displacements</button>
            <input type="file" id="file-input" style="display: none;" accept=".txt,.json">
        </div>

        <div id="error-message" class="error-message" style="display: none;"></div>

        <div class="section">
            <div class="section-title">Load Point Coordinates
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                Applied Loads</div>
            <table id="loads-table">
                <thead>
                    <tr>
                        <th style="width: 60px;">Load #</th>
                        <th>X</th>
                        <th>Y</th>
                        <th>Z</th>
                        <th>PX</th>
                        <th>PY</th>
                        <th>PZ</th>
                        <th style="width: 40px;"></th>
                    </tr>
                </thead>
                <tbody id="loads-tbody">
                    <tr data-load-index="1">
                        <td class="index-cell">1</td>
                        <td><input type="number" step="any" class="coord-x" value="1"></td>
                        <td><input type="number" step="any" class="coord-y" value="1"></td>
                        <td><input type="number" step="any" class="coord-z" value="0"></td>
                        <td><input type="number" step="any" class="force-px" value="0"></td>
                        <td><input type="number" step="any" class="force-py" value="0"></td>
                        <td><input type="number" step="any" class="force-pz" value="-100"></td>
                        <td><button class="remove-btn" onclick="removeLoad(this)">×</button></td>
                    </tr>
                </tbody>
            </table>
            <button class="add-btn" onclick="addLoad()">+ Add Load</button>
        </div>

        <div class="section">
            <div class="section-title">Support Point Coordinates &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Support
                Point Stiffness &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Support Point Reaction Loads</div>
            <table id="supports-table">
                <thead>
                    <tr>
                        <th style="width: 60px;">Support #</th>
                        <th>X</th>
                        <th>Y</th>
                        <th>Z</th>
                        <th>KX</th>
                        <th>KY</th>
                        <th>KZ</th>
                        <th class="output-cell" style="font-weight: bold;">RX</th>
                        <th class="output-cell" style="font-weight: bold;">RY</th>
                        <th class="output-cell" style="font-weight: bold;">RZ</th>
                        <th style="width: 40px;"></th>
                    </tr>
                </thead>
                <tbody id="supports-tbody">
                    <tr data-support-index="1">
                        <td class="index-cell">1</td>
                        <td><input type="number" step="any" class="coord-x" value="0"></td>
                        <td><input type="number" step="any" class="coord-y" value="0"></td>
                        <td><input type="number" step="any" class="coord-z" value="0"></td>
                        <td><input type="number" step="any" class="stiff-kx" value="1000"></td>
                        <td><input type="number" step="any" class="stiff-ky" value="1000"></td>
                        <td><input type="number" step="any" class="stiff-kz" value="1000"></td>
                        <td class="output-cell reaction-rx">-</td>
                        <td class="output-cell reaction-ry">-</td>
                        <td class="output-cell reaction-rz">-</td>
                        <td><button class="remove-btn" onclick="removeSupport(this)">×</button></td>
                    </tr>
                    <tr data-support-index="2">
                        <td class="index-cell">2</td>
                        <td><input type="number" step="any" class="coord-x" value="2"></td>
                        <td><input type="number" step="any" class="coord-y" value="0"></td>
                        <td><input type="number" step="any" class="coord-z" value="0"></td>
                        <td><input type="number" step="any" class="stiff-kx" value="1000"></td>
                        <td><input type="number" step="any" class="stiff-ky" value="1000"></td>
                        <td><input type="number" step="any" class="stiff-kz" value="1000"></td>
                        <td class="output-cell reaction-rx">-</td>
                        <td class="output-cell reaction-ry">-</td>
                        <td class="output-cell reaction-rz">-</td>
                        <td><button class="remove-btn" onclick="removeSupport(this)">×</button></td>
                    </tr>
                    <tr data-support-index="3">
                        <td class="index-cell">3</td>
                        <td><input type="number" step="any" class="coord-x" value="1"></td>
                        <td><input type="number" step="any" class="coord-y" value="1"></td>
                        <td><input type="number" step="any" class="coord-z" value="0"></td>
                        <td><input type="number" step="any" class="stiff-kx" value="1000"></td>
                        <td><input type="number" step="any" class="stiff-ky" value="1000"></td>
                        <td><input type="number" step="any" class="stiff-kz" value="1000"></td>
                        <td class="output-cell reaction-rx">-</td>
                        <td class="output-cell reaction-ry">-</td>
                        <td class="output-cell reaction-rz">-</td>
                        <td><button class="remove-btn" onclick="removeSupport(this)">×</button></td>
                    </tr>
                </tbody>
            </table>
            <button class="add-btn" onclick="addSupport()">+ Add Support</button>
        </div>

        <div id="displacements-section" style="display: none;">
            <div class="displacements-box">
                <h4>Global Rigid Body Displacements (Origin)</h4>
                <div class="disp-grid" id="displacements-grid">
                    <span>δx: -</span>
                    <span>δy: -</span>
                    <span>δz: -</span>
                    <span>θx: - rad</span>
                    <span>θy: - rad</span>
                    <span>θz: - rad</span>
                </div>
            </div>
        </div>

        <div id="plot-section" style="display: none;">
            <div class="view-controls">
                <button class="view-btn" id="view-top-btn">Top</button>
                <button class="view-btn" id="view-front-btn">Front</button>
                <button class="view-btn" id="view-right-btn">Right</button>
                <label class="toggle-label">
                    Ortho
                    <input type="checkbox" id="ortho-toggle">
                    <span class="toggle-switch"></span>
                </label>
            </div>
            <div id="visualization-container"></div>
        </div>
    </div>

    <script type="module">
        // --- Import three.js modules ---
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { Line2 } from 'three/addons/lines/Line2.js';
        import { LineMaterial } from 'three/addons/lines/LineMaterial.js';
        import { LineGeometry } from 'three/addons/lines/LineGeometry.js';

        // --- Global Variables ---
        const loadsTbody = document.getElementById('loads-tbody');
        const supportsTbody = document.getElementById('supports-tbody');
        const calculateBtn = document.getElementById('calculate-btn');
        const plotBtn = document.getElementById('plot-btn');
        const displacementsBtn = document.getElementById('displacements-btn');
        const saveConfigBtn = document.getElementById('save-config-btn');
        const loadConfigBtn = document.getElementById('load-config-btn');
        const fileInput = document.getElementById('file-input');
        const errorMessageDiv = document.getElementById('error-message');
        const visualizationContainer = document.getElementById('visualization-container');
        const plotSection = document.getElementById('plot-section');
        const displacementsSection = document.getElementById('displacements-section');
        const displacementsGrid = document.getElementById('displacements-grid');

        let lastCalculationResults = null;

        // --- three.js Variables ---
        let scene, perspectiveCamera, orthographicCamera, camera, renderer, controls, visualizationGroup, axesHelper;
        const initialCameraPosition = new THREE.Vector3(5, 5, 5);
        let isOrthographic = false;
        let threeInitialized = false;

        // --- Add/Remove Functions ---
        window.addLoad = function () {
            const newIndex = loadsTbody.children.length + 1;
            const row = loadsTbody.insertRow();
            row.setAttribute('data-load-index', newIndex);
            row.innerHTML = `
                <td class="index-cell">${newIndex}</td>
                <td><input type="number" step="any" class="coord-x" value="0"></td>
                <td><input type="number" step="any" class="coord-y" value="0"></td>
                <td><input type="number" step="any" class="coord-z" value="0"></td>
                <td><input type="number" step="any" class="force-px" value="0"></td>
                <td><input type="number" step="any" class="force-py" value="0"></td>
                <td><input type="number" step="any" class="force-pz" value="0"></td>
                <td><button class="remove-btn" onclick="removeLoad(this)">×</button></td>
            `;
        }

        window.removeLoad = function (btn) {
            if (loadsTbody.children.length <= 1) {
                alert('You need at least one load point defined.');
                return;
            }
            btn.closest('tr').remove();
            updateLoadIndices();
        }

        function updateLoadIndices() {
            Array.from(loadsTbody.children).forEach((row, index) => {
                row.setAttribute('data-load-index', index + 1);
                row.cells[0].textContent = index + 1;
            });
        }

        window.addSupport = function () {
            const newIndex = supportsTbody.children.length + 1;
            const row = supportsTbody.insertRow();
            row.setAttribute('data-support-index', newIndex);
            row.innerHTML = `
                <td class="index-cell">${newIndex}</td>
                <td><input type="number" step="any" class="coord-x" value="0"></td>
                <td><input type="number" step="any" class="coord-y" value="0"></td>
                <td><input type="number" step="any" class="coord-z" value="0"></td>
                <td><input type="number" step="any" class="stiff-kx" value="1000"></td>
                <td><input type="number" step="any" class="stiff-ky" value="1000"></td>
                <td><input type="number" step="any" class="stiff-kz" value="1000"></td>
                <td class="output-cell reaction-rx">-</td>
                <td class="output-cell reaction-ry">-</td>
                <td class="output-cell reaction-rz">-</td>
                <td><button class="remove-btn" onclick="removeSupport(this)">×</button></td>
            `;
        }

        window.removeSupport = function (btn) {
            if (supportsTbody.children.length <= 1) {
                alert('You need at least one support point defined.');
                return;
            }
            btn.closest('tr').remove();
            updateSupportIndices();
        }

        function updateSupportIndices() {
            Array.from(supportsTbody.children).forEach((row, index) => {
                row.setAttribute('data-support-index', index + 1);
                row.cells[0].textContent = index + 1;
            });
        }

        // --- Calculation Logic ---
        function calculateReactions() {
            errorMessageDiv.style.display = 'none';
            errorMessageDiv.textContent = '';

            // Clear previous reactions
            supportsTbody.querySelectorAll('.reaction-rx, .reaction-ry, .reaction-rz').forEach(cell => {
                cell.textContent = '-';
            });

            let currentSupportsData = [];
            let currentLoadsData = [];
            let currentCalculatedReactions = [];
            let currentDisplacements = [];

            try {
                // 1. Read Support Data
                const supportRows = supportsTbody.querySelectorAll('tr');
                supportRows.forEach((row, index) => {
                    const x = parseFloat(row.querySelector('.coord-x').value);
                    const y = parseFloat(row.querySelector('.coord-y').value);
                    const z = parseFloat(row.querySelector('.coord-z').value);
                    const kx = parseFloat(row.querySelector('.stiff-kx').value);
                    const ky = parseFloat(row.querySelector('.stiff-ky').value);
                    const kz = parseFloat(row.querySelector('.stiff-kz').value);

                    if (isNaN(x) || isNaN(y) || isNaN(z) || isNaN(kx) || isNaN(ky) || isNaN(kz)) {
                        throw new Error(`Invalid input for Support #${index + 1}.`);
                    }
                    if (kx < 0 || ky < 0 || kz < 0) {
                        throw new Error(`Stiffness values cannot be negative for Support #${index + 1}.`);
                    }

                    currentSupportsData.push({
                        index: index + 1,
                        type: 'general',
                        point: { x, y, z },
                        kx, ky, kz
                    });
                });

                // 2. Read Load Data
                const loadRows = loadsTbody.querySelectorAll('tr');
                loadRows.forEach((row, index) => {
                    const x = parseFloat(row.querySelector('.coord-x').value);
                    const y = parseFloat(row.querySelector('.coord-y').value);
                    const z = parseFloat(row.querySelector('.coord-z').value);
                    const px = parseFloat(row.querySelector('.force-px').value);
                    const py = parseFloat(row.querySelector('.force-py').value);
                    const pz = parseFloat(row.querySelector('.force-pz').value);

                    if (isNaN(x) || isNaN(y) || isNaN(z) || isNaN(px) || isNaN(py) || isNaN(pz)) {
                        throw new Error(`Invalid input for Load #${index + 1}.`);
                    }

                    currentLoadsData.push({ index: index + 1, x, y, z, px, py, pz });
                });

                if (currentSupportsData.length === 0) throw new Error("At least one support point must be defined.");
                if (currentLoadsData.length === 0) throw new Error("At least one load point must be defined.");

                // 3. Build External Force/Moment Vector
                let F_ext = math.zeros(6, 1);
                currentLoadsData.forEach(load => {
                    F_ext = math.add(F_ext, math.matrix([
                        [load.px],
                        [load.py],
                        [load.pz],
                        [load.y * load.pz - load.z * load.py],
                        [load.z * load.px - load.x * load.pz],
                        [load.x * load.py - load.y * load.px]
                    ]));
                });

                // 4. Build Global Stiffness Matrix
                let K_global = math.zeros(6, 6);
                currentSupportsData.forEach(support => {
                    const { x, y, z } = support.point;
                    const Ki = math.diag([support.kx, support.ky, support.kz]);
                    const Ti = math.matrix([
                        [1, 0, 0, 0, z, -y],
                        [0, 1, 0, -z, 0, x],
                        [0, 0, 1, y, -x, 0]
                    ]);
                    support.Ki = Ki;
                    support.Ti = Ti;
                    const Ki_global_contrib = math.multiply(math.transpose(Ti), Ki, Ti);
                    K_global = math.add(K_global, Ki_global_contrib);
                });

                // 5. Solve for Global Displacements
                let K_inv;
                try {
                    K_inv = math.inv(K_global);
                } catch (error) {
                    throw new Error("Cannot calculate reactions. Global stiffness matrix is singular. Supports may not adequately constrain the body.");
                }
                const D_matrix = math.multiply(K_inv, F_ext);
                currentDisplacements = D_matrix.valueOf().flat();

                // 6. Calculate Reaction Forces
                currentSupportsData.forEach(support => {
                    const { Ki, Ti } = support;
                    const Ri_body_on_support_matrix = math.multiply(Ki, Ti, D_matrix);
                    const Ri_support_on_body_matrix = math.multiply(Ri_body_on_support_matrix, -1);
                    const reactionForces = Ri_support_on_body_matrix.valueOf().flat();

                    currentCalculatedReactions.push({
                        index: support.index,
                        x: support.point.x,
                        y: support.point.y,
                        z: support.point.z,
                        rx: reactionForces[0],
                        ry: reactionForces[1],
                        rz: reactionForces[2],
                        type: 'general'
                    });
                });

                // 7. Display Results
                lastCalculationResults = {
                    reactions: currentCalculatedReactions,
                    displacements: currentDisplacements,
                    supports: currentSupportsData,
                    loads: currentLoadsData
                };

                displayReactions(currentCalculatedReactions);
                displayDisplacements(currentDisplacements);

            } catch (error) {
                console.error("Calculation Error:", error);
                errorMessageDiv.textContent = `Error: ${error.message}`;
                errorMessageDiv.style.display = 'block';
                lastCalculationResults = null;
            }
        }

        function displayReactions(reactions) {
            reactions.forEach(r => {
                const row = supportsTbody.querySelector(`tr[data-support-index="${r.index}"]`);
                if (row) {
                    row.querySelector('.reaction-rx').textContent = r.rx.toFixed(3);
                    row.querySelector('.reaction-ry').textContent = r.ry.toFixed(3);
                    row.querySelector('.reaction-rz').textContent = r.rz.toFixed(3);
                }
            });
        }

        function displayDisplacements(displacements) {
            displacementsGrid.innerHTML = `
                <span>δx: ${displacements[0].toExponential(3)}</span>
                <span>δy: ${displacements[1].toExponential(3)}</span>
                <span>δz: ${displacements[2].toExponential(3)}</span>
                <span>θx: ${displacements[3].toExponential(3)} rad</span>
                <span>θy: ${displacements[4].toExponential(3)} rad</span>
                <span>θz: ${displacements[5].toExponential(3)} rad</span>
            `;
        }

        // --- Save/Load Configuration ---
        function saveConfiguration() {
            const supports = [];
            supportsTbody.querySelectorAll('tr').forEach(row => {
                supports.push({
                    type: 'general',
                    x: row.querySelector('.coord-x').value,
                    y: row.querySelector('.coord-y').value,
                    z: row.querySelector('.coord-z').value,
                    kx: row.querySelector('.stiff-kx').value,
                    ky: row.querySelector('.stiff-ky').value,
                    kz: row.querySelector('.stiff-kz').value
                });
            });

            const loads = [];
            loadsTbody.querySelectorAll('tr').forEach(row => {
                loads.push({
                    x: row.querySelector('.coord-x').value,
                    y: row.querySelector('.coord-y').value,
                    z: row.querySelector('.coord-z').value,
                    px: row.querySelector('.force-px').value,
                    py: row.querySelector('.force-py').value,
                    pz: row.querySelector('.force-pz').value
                });
            });

            const config = { supports, loads };
            const blob = new Blob([JSON.stringify(config, null, 2)], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'rigid_body_config.txt';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        function loadConfiguration(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function (e) {
                try {
                    const config = JSON.parse(e.target.result);

                    // Clear existing
                    supportsTbody.innerHTML = '';
                    loadsTbody.innerHTML = '';

                    // Restore Supports
                    if (config.supports && Array.isArray(config.supports)) {
                        config.supports.forEach((s, index) => {
                            const row = supportsTbody.insertRow();
                            row.setAttribute('data-support-index', index + 1);
                            row.innerHTML = `
                                <td class="index-cell">${index + 1}</td>
                                <td><input type="number" step="any" class="coord-x" value="${s.x}"></td>
                                <td><input type="number" step="any" class="coord-y" value="${s.y}"></td>
                                <td><input type="number" step="any" class="coord-z" value="${s.z}"></td>
                                 <td><input type="number" step="any" class="stiff-kx" value="${s.kx}"></td>
                                <td><input type="number" step="any" class="stiff-ky" value="${s.ky}"></td>
                                <td><input type="number" step="any" class="stiff-kz" value="${s.kz}"></td>
                                <td class="output-cell reaction-rx">-</td>
                                <td class="output-cell reaction-ry">-</td>
                                <td class="output-cell reaction-rz">-</td>
                                <td><button class="remove-btn" onclick="removeSupport(this)">×</button></td>
                            `;
                        });
                    }

                    // Restore Loads
                    if (config.loads && Array.isArray(config.loads)) {
                        config.loads.forEach((l, index) => {
                            const row = loadsTbody.insertRow();
                            row.setAttribute('data-load-index', index + 1);
                            row.innerHTML = `
                                <td class="index-cell">${index + 1}</td>
                                <td><input type="number" step="any" class="coord-x" value="${l.x}"></td>
                                <td><input type="number" step="any" class="coord-y" value="${l.y}"></td>
                                <td><input type="number" step="any" class="coord-z" value="${l.z}"></td>
                                <td><input type="number" step="any" class="force-px" value="${l.px}"></td>
                                <td><input type="number" step="any" class="force-py" value="${l.py}"></td>
                                <td><input type="number" step="any" class="force-pz" value="${l.pz}"></td>
                                <td><button class="remove-btn" onclick="removeLoad(this)">×</button></td>
                            `;
                        });
                    }

                    fileInput.value = '';
                } catch (error) {
                    alert('Failed to parse configuration file. Ensure it is a valid JSON/TXT file.');
                    console.error(error);
                }
            };
            reader.readAsText(file);
        }

        // --- Three.js Visualization ---
        function initThreeJS() {
            if (threeInitialized) return;

            const width = visualizationContainer.clientWidth;
            const height = visualizationContainer.clientHeight;

            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xf0f0f0);

            perspectiveCamera = new THREE.PerspectiveCamera(50, width / height, 0.1, 2000);
            perspectiveCamera.position.copy(initialCameraPosition);

            const aspect = width / height;
            const frustumSize = 10;
            orthographicCamera = new THREE.OrthographicCamera(
                frustumSize * aspect / -2, frustumSize * aspect / 2,
                frustumSize / 2, frustumSize / -2,
                0.1, 2000
            );
            orthographicCamera.position.copy(initialCameraPosition);

            camera = perspectiveCamera;
            isOrthographic = false;
            document.getElementById('ortho-toggle').checked = false;

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(width, height);
            renderer.setPixelRatio(window.devicePixelRatio);
            visualizationContainer.appendChild(renderer.domElement);

            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.screenSpacePanning = true;

            const ambientLight = new THREE.AmbientLight(0xcccccc, 0.8);
            scene.add(ambientLight);
            const directionalLight1 = new THREE.DirectionalLight(0xffffff, 0.6);
            directionalLight1.position.set(1, 1, 0.5).normalize();
            scene.add(directionalLight1);

            axesHelper = new THREE.AxesHelper(1);
            scene.add(axesHelper);

            visualizationGroup = new THREE.Group();
            scene.add(visualizationGroup);

            animate();
            threeInitialized = true;
        }

        function animate() {
            requestAnimationFrame(animate);
            if (controls) controls.update();
            if (renderer && scene && camera) {
                renderer.render(scene, camera);
            }
        }

        function clearVisualization() {
            if (visualizationGroup) {
                while (visualizationGroup.children.length > 0) {
                    const child = visualizationGroup.children[0];
                    visualizationGroup.remove(child);
                    if (child.geometry) child.geometry.dispose();
                    if (child.material) {
                        if (Array.isArray(child.material)) {
                            child.material.forEach(m => m.dispose());
                        } else {
                            child.material.dispose();
                        }
                    }
                }
            }
        }

        function updateVisualization(supportsInput, loadsInput, reactionsResult) {
            clearVisualization();
            if (!supportsInput || !loadsInput || !reactionsResult || !visualizationGroup) return;

            let allPoints = [];
            reactionsResult.forEach(r => {
                allPoints.push(new THREE.Vector3(r.x, r.y, r.z));
            });
            loadsInput.forEach(l => {
                allPoints.push(new THREE.Vector3(l.x, l.y, l.z));
            });

            let maxPointDistance = 0;
            if (allPoints.length >= 2) {
                for (let i = 0; i < allPoints.length; i++) {
                    for (let j = i + 1; j < allPoints.length; j++) {
                        maxPointDistance = Math.max(maxPointDistance, allPoints[i].distanceTo(allPoints[j]));
                    }
                }
            }
            if (maxPointDistance < 1e-6) maxPointDistance = 10.0;

            const pointRadius = maxPointDistance / 40.0;

            let maxForceMagnitude = 0;
            reactionsResult.forEach(r => {
                maxForceMagnitude = Math.max(maxForceMagnitude, Math.sqrt(r.rx ** 2 + r.ry ** 2 + r.rz ** 2));
            });
            loadsInput.forEach(l => {
                maxForceMagnitude = Math.max(maxForceMagnitude, Math.sqrt(l.px ** 2 + l.py ** 2 + l.pz ** 2));
            });

            const targetMaxLength = maxPointDistance * 0.50;
            const arrowScaleFactor = (maxForceMagnitude > 1e-9) ? targetMaxLength / maxForceMagnitude : 0;

            const supportMaterial = new THREE.MeshStandardMaterial({ color: 0x007bff, roughness: 0.5 });
            const loadMaterial = new THREE.MeshStandardMaterial({ color: 0xffa500, roughness: 0.5 });

            // Draw Supports and Reactions
            reactionsResult.forEach(r => {
                const reactionPointVec = new THREE.Vector3(r.x, r.y, r.z);
                const supportMesh = new THREE.Mesh(new THREE.SphereGeometry(pointRadius, 16, 16), supportMaterial);
                supportMesh.position.copy(reactionPointVec);
                visualizationGroup.add(supportMesh);

                const reactionVec = new THREE.Vector3(r.rx, r.ry, r.rz);
                const reactionMag = reactionVec.length();
                if (reactionMag > 1e-9 && arrowScaleFactor > 0) {
                    const direction = reactionVec.normalize();
                    const length = reactionMag * arrowScaleFactor;
                    const arrowHelper = new THREE.ArrowHelper(direction, reactionPointVec, length, 0xdc3545,
                        Math.max(length * 0.2, pointRadius * 0.5),
                        Math.max(length * 0.1, pointRadius * 0.25));
                    visualizationGroup.add(arrowHelper);
                }
            });

            // Draw Loads
            loadsInput.forEach(l => {
                const loadPointVec = new THREE.Vector3(l.x, l.y, l.z);
                const loadMesh = new THREE.Mesh(new THREE.SphereGeometry(pointRadius, 16, 16), loadMaterial);
                loadMesh.position.copy(loadPointVec);
                visualizationGroup.add(loadMesh);

                const forceVec = new THREE.Vector3(l.px, l.py, l.pz);
                const forceMag = forceVec.length();
                if (forceMag > 1e-9 && arrowScaleFactor > 0) {
                    const direction = forceVec.normalize();
                    const length = forceMag * arrowScaleFactor;
                    const arrowHelper = new THREE.ArrowHelper(direction, loadPointVec, length, 0x28a745,
                        Math.max(length * 0.2, pointRadius * 0.5),
                        Math.max(length * 0.1, pointRadius * 0.25));
                    visualizationGroup.add(arrowHelper);
                }
            });

            // Adjust Axes
            const box = new THREE.Box3().setFromObject(visualizationGroup);
            if (!box.isEmpty()) {
                const size = box.getSize(new THREE.Vector3());
                const maxDim = Math.max(size.x, size.y, size.z);
                scene.remove(axesHelper);
                axesHelper = new THREE.AxesHelper(maxDim > 0 ? maxDim * 0.6 : 1);
                scene.add(axesHelper);
            }
        }

        function setView(axis) {
            if (!camera || !controls || visualizationGroup.children.length === 0) return;

            const box = new THREE.Box3().setFromObject(visualizationGroup);
            if (box.isEmpty()) return;

            const center = box.getCenter(new THREE.Vector3());
            const size = box.getSize(new THREE.Vector3());
            const maxDim = Math.max(size.x, size.y, size.z);

            let viewAxisNormal = new THREE.Vector3();
            let upVector = new THREE.Vector3(0, 1, 0);

            switch (axis) {
                case 'Y':
                    viewAxisNormal.set(0, 1, 0);
                    upVector.set(0, 0, -1);
                    break;
                case 'Z':
                    viewAxisNormal.set(0, 0, 1);
                    upVector.set(0, 1, 0);
                    break;
                case 'X':
                    viewAxisNormal.set(1, 0, 0);
                    upVector.set(0, 1, 0);
                    break;
            }

            const distance = maxDim * 2;
            camera.position.copy(viewAxisNormal).multiplyScalar(distance).add(center);
            camera.up.copy(upVector);
            camera.lookAt(center);
            camera.updateProjectionMatrix();
            controls.target.copy(center);
            controls.update();
        }

        function handleOrthoToggle(event) {
            const useOrtho = event.target.checked;
            if (useOrtho === isOrthographic) return;

            const oldCamera = camera;

            if (useOrtho) {
                camera = orthographicCamera;
                isOrthographic = true;

                const distance = perspectiveCamera.position.distanceTo(controls.target);
                const visibleHeight = 2 * Math.tan(THREE.MathUtils.degToRad(perspectiveCamera.fov / 2)) * distance;
                const visibleWidth = visibleHeight * perspectiveCamera.aspect;

                camera.left = -visibleWidth / 2;
                camera.right = visibleWidth / 2;
                camera.top = visibleHeight / 2;
                camera.bottom = -visibleHeight / 2;
                camera.zoom = 1;
            } else {
                camera = perspectiveCamera;
                isOrthographic = false;
            }

            camera.position.copy(oldCamera.position);
            camera.up.copy(oldCamera.up);
            camera.lookAt(controls.target);
            camera.updateProjectionMatrix();
            controls.object = camera;
            controls.update();
        }

        // --- Event Listeners ---
        calculateBtn.addEventListener('click', calculateReactions);

        plotBtn.addEventListener('click', () => {
            if (!lastCalculationResults) {
                alert('Please calculate first.');
                return;
            }
            plotSection.style.display = 'block';
            displacementsSection.style.display = 'none';

            if (!threeInitialized) {
                initThreeJS();
            }
            updateVisualization(lastCalculationResults.loads, lastCalculationResults.loads, lastCalculationResults.reactions);
        });

        displacementsBtn.addEventListener('click', () => {
            if (!lastCalculationResults) {
                alert('Please calculate first.');
                return;
            }
            displacementsSection.style.display = 'block';
            plotSection.style.display = 'none';
        });

        saveConfigBtn.addEventListener('click', saveConfiguration);
        loadConfigBtn.addEventListener('click', () => fileInput.click());
        fileInput.addEventListener('change', loadConfiguration);

        document.getElementById('view-top-btn').addEventListener('click', () => setView('Y'));
        document.getElementById('view-front-btn').addEventListener('click', () => setView('Z'));
        document.getElementById('view-right-btn').addEventListener('click', () => setView('X'));
        document.getElementById('ortho-toggle').addEventListener('change', handleOrthoToggle);

    </script>
</body>

</html>