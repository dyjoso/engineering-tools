<title>Generic Beam Analysis Tool</title>
<script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
<style>
    :root {
        --primary: #2563eb;
        --bg: #f8fafc;
        --panel: #ffffff;
        --border: #e2e8f0;
        --text: #0f172a;
        --input-bg: #ffffff;
    }

    body {
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
        background-color: var(--bg);
        margin: 0;
        padding: 20px;
        color: var(--text);
    }

    .container {
        max-width: 1200px;
        margin: 0 auto;
        display: grid;
        grid-template-columns: 350px 1fr;
        gap: 20px;
    }

    /* Sidebar Styles */
    .controls {
        background: var(--panel);
        padding: 20px;
        border-radius: 8px;
        box-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
        height: fit-content;
    }

    h2,
    h3 {
        margin-top: 0;
        color: var(--text);
    }

    .form-group {
        margin-bottom: 15px;
    }

    label {
        display: block;
        font-size: 0.9em;
        font-weight: 600;
        margin-bottom: 5px;
        color: #475569;
    }

    input,
    select {
        width: 100%;
        padding: 8px;
        border: 1px solid var(--border);
        border-radius: 4px;
        box-sizing: border-box;
        background: var(--input-bg);
        color: var(--text);
    }

    .load-item {
        background: #f1f5f9;
        padding: 10px;
        border-radius: 4px;
        margin-bottom: 10px;
        display: flex;
        gap: 10px;
        align-items: flex-end;
    }

    .load-item .form-group {
        margin-bottom: 0;
        flex: 1;
    }

    .btn {
        background: var(--primary);
        color: white;
        border: none;
        padding: 8px 16px;
        border-radius: 4px;
        cursor: pointer;
        font-weight: 500;
        width: 100%;
    }

    .btn:hover {
        opacity: 0.9;
    }

    .btn-red {
        background: #ef4444;
        width: auto;
        height: 34px;
        margin-top: 0;
    }

    /* Main Display Styles */
    .results {
        display: flex;
        flex-direction: column;
        gap: 20px;
    }

    .canvas-container {
        background: var(--panel);
        padding: 20px;
        border-radius: 8px;
        box-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
    }

    #beamViz {
        width: 100%;
        height: 150px;
        border-bottom: 1px solid var(--border);
        margin-bottom: 15px;
    }

    .reaction-box {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 10px;
        margin-bottom: 15px;
        font-family: monospace;
        background: #f1f5f9;
        padding: 10px;
        border-radius: 4px;
        border: 1px solid var(--border);
    }

    @media (max-width: 800px) {
        .container {
            grid-template-columns: 1fr;
        }
    }
</style>
</head>

<body>

    <div class="container">
        <div class="controls">
            <h2>Beam Config</h2>
            <div class="form-group">
                <label>Length (m)</label>
                <input type="number" id="beamLength" value="10" min="1" step="0.1" onchange="updateAnalysis()">
            </div>

            <div class="form-group">
                <label>Left Support</label>
                <select id="leftSupport" onchange="updateAnalysis()">
                    <option value="pinned">Pinned</option>
                    <option value="fixed">Fixed</option>
                    <option value="free">Free</option>
                </select>
            </div>

            <div class="form-group">
                <label>Right Support</label>
                <select id="rightSupport" onchange="updateAnalysis()">
                    <option value="pinned">Pinned</option>
                    <option value="fixed">Fixed</option>
                    <option value="free">Free</option>
                </select>
            </div>

            <hr style="border-color: var(--border);">
            <h3>Loads</h3>
            <div id="loadsContainer"></div>
            <button class="btn" onclick="addLoad()">+ Add Load</button>

            <hr style="border-color: var(--border);">
            <h3>Point Constraints</h3>
            <div id="constraintsContainer"></div>
            <button class="btn" onclick="addConstraint()">+ Add Constraint</button>

            <div style="margin-top: 20px; font-size: 0.8em; color: #64748b;">
                Note: Solves determinate and indeterminate systems.
            </div>
        </div>

        <div class="results">
            <div class="canvas-container">
                <h3>System Visualization & Reactions</h3>
                <canvas id="beamViz"></canvas>
                <div id="reactionOutput" class="reaction-box"></div>
            </div>

            <div class="canvas-container">
                <h3>Shear Force Diagram (kN)</h3>
                <canvas id="shearChart"></canvas>
            </div>

            <div class="canvas-container">
                <h3>Bending Moment Diagram (kNm)</h3>
                <canvas id="momentChart"></canvas>
            </div>

            <div class="canvas-container">
                <h3>Displacement (mm)</h3>
                <canvas id="dispChart"></canvas>
            </div>
        </div>
    </div>

    <script>
        // --- State Management ---
        let loads = [
            { type: 'point', magnitude: 10, location: 5 } // Default load
        ];

        let constraints = []; // { location: number, displacement: number }

        let charts = {};

        // --- Initialization ---
        window.onload = function () {
            renderLoadInputs();
            renderConstraintInputs();
            updateAnalysis();
        };

        // --- Input Handling ---
        function addLoad() {
            loads.push({ type: 'point', magnitude: 10, location: 0, endLocation: 0 });
            renderLoadInputs();
            updateAnalysis();
        }

        function removeLoad(index) {
            loads.splice(index, 1);
            renderLoadInputs();
            updateAnalysis();
        }

        function updateLoad(index, field, value) {
            loads[index][field] = parseFloat(value);
            updateAnalysis();
        }

        function updateLoadType(index, value) {
            loads[index].type = value;
            renderLoadInputs(); // Re-render to show/hide endLocation
            updateAnalysis();
        }

        function renderLoadInputs() {
            const container = document.getElementById('loadsContainer');
            container.innerHTML = '';

            loads.forEach((load, index) => {
                let html = `
                <div class="load-item">
                    <div class="form-group">
                        <label>Type</label>
                        <select onchange="updateLoadType(${index}, this.value)">
                            <option value="point" ${load.type === 'point' ? 'selected' : ''}>Point Load (kN)</option>
                            <option value="moment" ${load.type === 'moment' ? 'selected' : ''}>Moment (kNm)</option>
                            <option value="distributed" ${load.type === 'distributed' ? 'selected' : ''}>Distributed (kN/m)</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label>Magnitude</label>
                        <input type="number" value="${load.magnitude}" step="0.1" onchange="updateLoad(${index}, 'magnitude', this.value)">
                    </div>
                    <div class="form-group">
                        <label>Start (m)</label>
                        <input type="number" value="${load.location}" step="0.1" onchange="updateLoad(${index}, 'location', this.value)">
                    </div>
            `;

                if (load.type === 'distributed') {
                    html += `
                    <div class="form-group">
                        <label>End (m)</label>
                        <input type="number" value="${load.endLocation || load.location + 1}" step="0.1" onchange="updateLoad(${index}, 'endLocation', this.value)">
                    </div>
                `;
                }

                html += `<button class="btn btn-red" onclick="removeLoad(${index})">X</button></div>`;
                container.innerHTML += html;
            });
        }

        function addConstraint() {
            constraints.push({ location: 5, displacement: 0 });
            renderConstraintInputs();
            updateAnalysis();
        }

        function removeConstraint(index) {
            constraints.splice(index, 1);
            renderConstraintInputs();
            updateAnalysis();
        }

        function updateConstraint(index, field, value) {
            constraints[index][field] = parseFloat(value);
            updateAnalysis();
        }

        function renderConstraintInputs() {
            const container = document.getElementById('constraintsContainer');
            container.innerHTML = '';

            constraints.forEach((c, index) => {
                let html = `
                <div class="load-item" style="background: #eff6ff; border: 1px solid #bfdbfe;">
                    <div class="form-group">
                        <label>Location (m)</label>
                        <input type="number" value="${c.location}" step="0.1" onchange="updateConstraint(${index}, 'location', this.value)">
                    </div>
                    <div class="form-group">
                        <label>Disp. (mm)</label>
                        <input type="number" value="${c.displacement}" step="0.1" onchange="updateConstraint(${index}, 'displacement', this.value)">
                    </div>
                    <button class="btn btn-red" onclick="removeConstraint(${index})">X</button>
                </div>`;
                container.innerHTML += html;
            });
        }

        // --- Physics Engine (Matrix Stiffness Method / FEM) ---

        // Matrix Helper Class
        class Matrix {
            constructor(rows, cols) {
                this.rows = rows;
                this.cols = cols;
                this.data = Array(rows).fill().map(() => Array(cols).fill(0));
            }

            static zeros(rows, cols) { return new Matrix(rows, cols); }

            get(r, c) { return this.data[r][c]; }
            set(r, c, val) { this.data[r][c] = val; }
            add(r, c, val) { this.data[r][c] += val; }
        }

        // Linear Solver (Gaussian Elimination)
        function solveLinearSystem(K, F, constrainedDOFs) {
            const n = F.length;
            const freeDOFs = [];
            for (let i = 0; i < n; i++) {
                if (!constrainedDOFs.has(i)) freeDOFs.push(i);
            }

            const dim = freeDOFs.length;
            const A = Array(dim).fill().map(() => Array(dim).fill(0));
            const b = Array(dim).fill(0);

            // Extract submatrix for free DOFs
            for (let i = 0; i < dim; i++) {
                b[i] = F[freeDOFs[i]];
                for (let j = 0; j < dim; j++) {
                    A[i][j] = K.get(freeDOFs[i], freeDOFs[j]);
                }
            }

            // Solve Ax = b
            const x = gaussianElimination(A, b);

            // Construct full displacement vector
            const d = Array(n).fill(0);
            for (let i = 0; i < dim; i++) {
                d[freeDOFs[i]] = x[i];
            }
            return d;
        }

        function gaussianElimination(A, b) {
            const n = b.length;
            for (let i = 0; i < n; i++) {
                // Pivot
                let maxRow = i;
                for (let k = i + 1; k < n; k++) {
                    if (Math.abs(A[k][i]) > Math.abs(A[maxRow][i])) maxRow = k;
                }
                [A[i], A[maxRow]] = [A[maxRow], A[i]];
                [b[i], b[maxRow]] = [b[maxRow], b[i]];

                // Eliminate
                for (let k = i + 1; k < n; k++) {
                    const factor = A[k][i] / A[i][i];
                    b[k] -= factor * b[i];
                    for (let j = i; j < n; j++) {
                        A[k][j] -= factor * A[i][j];
                    }
                }
            }

            // Back Substitution
            const x = Array(n).fill(0);
            for (let i = n - 1; i >= 0; i--) {
                let sum = 0;
                for (let j = i + 1; j < n; j++) {
                    sum += A[i][j] * x[j];
                }
                x[i] = (b[i] - sum) / A[i][i];
            }
            return x;
        }

        function solveBeam(L, leftType, rightType, loadList, constraintList) {
            // 1. Discretization (Nodes)
            let nodes = new Set([0, L]);
            loadList.forEach(l => {
                nodes.add(l.location);
                if (l.type === 'distributed') nodes.add(l.endLocation);
            });

            if (constraintList) {
                constraintList.forEach(c => nodes.add(c.location));
            }

            const sortedNodes = Array.from(nodes).sort((a, b) => a - b);
            // Remove duplicates (tolerance)
            let uniqueNodes = [sortedNodes[0]];
            for (let i = 1; i < sortedNodes.length; i++) {
                if (sortedNodes[i] - uniqueNodes[uniqueNodes.length - 1] > 1e-6) {
                    uniqueNodes.push(sortedNodes[i]);
                }
            }

            // Mesh Refinement: Subdivide large elements
            const maxElLen = L / 50; // Ensure at least 50 elements
            let refinedNodes = [uniqueNodes[0]];
            for (let i = 0; i < uniqueNodes.length - 1; i++) {
                const x1 = uniqueNodes[i];
                const x2 = uniqueNodes[i + 1];
                const L_el = x2 - x1;
                if (L_el > maxElLen) {
                    const nSub = Math.ceil(L_el / maxElLen);
                    for (let k = 1; k < nSub; k++) {
                        refinedNodes.push(x1 + k * L_el / nSub);
                    }
                }
                refinedNodes.push(x2);
            }
            uniqueNodes = refinedNodes;

            const numNodes = uniqueNodes.length;
            const numDOFs = numNodes * 2; // v, theta per node

            // 2. Global Stiffness Matrix & Load Vector
            const K = Matrix.zeros(numDOFs, numDOFs);
            const F = Array(numDOFs).fill(0);

            // Material Properties (Arbitrary constant EI)
            const E = 200e9; // Pa
            const I = 100e-6; // m^4
            const EI = E * I;

            // 3. Assembly
            for (let i = 0; i < numNodes - 1; i++) {
                const x1 = uniqueNodes[i];
                const x2 = uniqueNodes[i + 1];
                const le = x2 - x1;

                // Element Stiffness Matrix (Hermite Beam)
                const k11 = 12 * EI / le ** 3, k12 = 6 * EI / le ** 2;
                const k22 = 4 * EI / le, k23 = 2 * EI / le;

                // Indices in Global Matrix
                // Node i: 2*i, 2*i+1
                // Node i+1: 2*(i+1), 2*(i+1)+1
                const idx = [2 * i, 2 * i + 1, 2 * (i + 1), 2 * (i + 1) + 1];

                const ke = [
                    [k11, k12, -k11, k12],
                    [k12, k22, -k12, k23],
                    [-k11, -k12, k11, -k12],
                    [k12, k23, -k12, k22]
                ];

                for (let r = 0; r < 4; r++) {
                    for (let c = 0; c < 4; c++) {
                        K.add(idx[r], idx[c], ke[r][c]);
                    }
                }

                // Distributed Loads (Fixed End Actions)
                loadList.forEach(l => {
                    if (l.type === 'distributed') {
                        // Check overlap
                        const start = Math.max(x1, l.location);
                        const end = Math.min(x2, l.endLocation);

                        if (end > start + 1e-6) {
                            const w = l.magnitude; // Downward is negative in FEM usually, but let's stick to sign convention
                            // Our sign convention: Up is +y. Load magnitude is usually "force", so down load is -magnitude?
                            // User inputs positive for down load usually. Let's assume input magnitude is DOWN force.
                            // So force = -w.
                            const q = -w;

                            // For UDL over entire element (simplified for now, assuming split nodes handle partials)
                            // Since we added nodes at start/end of loads, any UDL covers the FULL element or NONE of it.
                            if (Math.abs(start - x1) < 1e-6 && Math.abs(end - x2) < 1e-6) {
                                const f1 = q * le / 2;
                                const m1 = q * le ** 2 / 12;
                                const f2 = q * le / 2;
                                const m2 = -q * le ** 2 / 12;

                                F[idx[0]] += f1;
                                F[idx[1]] += m1;
                                F[idx[2]] += f2;
                                F[idx[3]] += m2;
                            }
                        }
                    }
                });
            }

            // Point Loads
            loadList.forEach(l => {
                if (l.type === 'point' || l.type === 'moment') {
                    // Find node index
                    const nIdx = uniqueNodes.findIndex(x => Math.abs(x - l.location) < 1e-6);
                    if (nIdx !== -1) {
                        if (l.type === 'point') F[2 * nIdx] -= l.magnitude; // Downward load input = negative force
                        if (l.type === 'moment') F[2 * nIdx + 1] -= l.magnitude; // Assuming CW input, FEM CCW+ -> -Magnitude
                    }
                }
            });

            // 4. Boundary Conditions
            const constrainedDOFs = new Set();

            // Left Support (Node 0)
            if (leftType === 'pinned') constrainedDOFs.add(0); // Fix v
            if (leftType === 'fixed') { constrainedDOFs.add(0); constrainedDOFs.add(1); } // Fix v, theta

            // Right Support (Last Node)
            const lastNodeIdx = numNodes - 1;
            if (rightType === 'pinned') constrainedDOFs.add(2 * lastNodeIdx);
            if (rightType === 'fixed') { constrainedDOFs.add(2 * lastNodeIdx); constrainedDOFs.add(2 * lastNodeIdx + 1); }

            // Point Constraints
            if (constraintList) {
                constraintList.forEach(c => {
                    const nIdx = uniqueNodes.findIndex(x => Math.abs(x - c.location) < 1e-6);
                    if (nIdx !== -1) {
                        constrainedDOFs.add(2 * nIdx); // Fix v
                        // Handle non-zero displacement?
                        // For now, assume 0. To support non-zero, we need to modify F.
                        // Penalty method or partition. Partition is cleaner but complex code.
                        // Simple approach: Large stiffness penalty.
                        if (c.displacement !== 0) {
                            // Penalty Method
                            const penalty = 1e14 * EI;
                            K.add(2 * nIdx, 2 * nIdx, penalty);
                            F[2 * nIdx] += penalty * (c.displacement / 1000); // Convert mm to m
                            constrainedDOFs.delete(2 * nIdx); // Treat as free but with penalty
                        }
                    }
                });
            }

            // 5. Solve
            const d = solveLinearSystem(K, F, constrainedDOFs);

            // 6. Post-Processing (Internal Forces)
            const xVals = [];
            const shearVals = [];
            const momentVals = [];
            const dispVals = [];

            // Reactions
            // R = K*d - F_equivalent
            // Actually, we can just sum forces/moments at nodes, or use element forces.
            // Let's calculate element forces and string them together.

            let RA = 0, MA = 0, RB = 0, MB = 0;

            for (let i = 0; i < numNodes - 1; i++) {
                const x1 = uniqueNodes[i];
                const x2 = uniqueNodes[i + 1];
                const le = x2 - x1;

                // Element displacements
                const u = [d[2 * i], d[2 * i + 1], d[2 * (i + 1)], d[2 * (i + 1) + 1]];

                // Subdivide element for plotting
                const numSub = 20;
                for (let j = 0; j <= numSub; j++) {
                    // Allow duplicates at nodes for vertical steps in charts
                    // if (i > 0 && j === 0) continue;

                    const xi = j * le / numSub; // Local x
                    const xGlobal = x1 + xi;

                    // Shape functions derivatives for V and M
                    // v(x) = N1*u1 + N2*u2 + N3*u3 + N4*u4
                    // M = EI * v''
                    // V = -EI * v''' (Bernoulli) or dM/dx

                    // N1 = 1 - 3xi^2 + 2xi^3 (xi = x/L)
                    const s = xi / le;

                    // M(x) = EI/L^2 * [ (6s-4)*u1 + (6s-2)*u2*L + (-6s+2)*u3 + (6s-4)*u4*L ] ? 
                    // Let's use standard cubic interpolation derivatives

                    // d2N/dx2
                    const d2N1 = (12 * s - 6) / le ** 2;
                    const d2N2 = (6 * s - 4) / le;
                    const d2N3 = (-12 * s + 6) / le ** 2;
                    const d2N4 = (6 * s - 2) / le;

                    const curvature = d2N1 * u[0] + d2N2 * u[1] + d2N3 * u[2] + d2N4 * u[3];
                    let M = EI * curvature; // Standard FEM: M = EI v''. 
                    // Sign convention: Positive curvature (smile) -> Compression top -> Positive Moment?
                    // Tool convention: Sagging positive? 
                    // Let's check results.

                    // Displacement v(x)
                    // N1 = 1 - 3s^2 + 2s^3
                    // N2 = L(s - 2s^2 + s^3)
                    // N3 = 3s^2 - 2s^3
                    // N4 = L(-s^2 + s^3)
                    const N1 = 1 - 3 * s ** 2 + 2 * s ** 3;
                    const N2 = le * (s - 2 * s ** 2 + s ** 3);
                    const N3 = 3 * s ** 2 - 2 * s ** 3;
                    const N4 = le * (-(s ** 2) + s ** 3);

                    const v = N1 * u[0] + N2 * u[1] + N3 * u[2] + N4 * u[3];

                    // d3N/dx3
                    const d3N1 = 12 / le ** 3;
                    const d3N2 = 6 / le ** 2;
                    const d3N3 = -12 / le ** 3;
                    const d3N4 = 6 / le ** 2;

                    const d3v = d3N1 * u[0] + d3N2 * u[1] + d3N3 * u[2] + d3N4 * u[3];
                    let V = -EI * d3v; // V = -EI v'''

                    // Add Fixed End Actions effects for internal points if UDL exists
                    loadList.forEach(l => {
                        if (l.type === 'distributed') {
                            if (Math.abs(Math.max(x1, l.location) - x1) < 1e-6 && Math.abs(Math.min(x2, l.endLocation) - x2) < 1e-6) {
                                const q = -l.magnitude;
                                // Simply supported beam V and M due to q
                                // V_q = q(L/2 - x)
                                // M_q = qx(L-x)/2
                                // Superposition
                                const x_local = xi;
                                V += q * (le / 2 - x_local);
                                M += (q * x_local / 2) * (le - x_local);
                            }
                        }
                    });

                    xVals.push(xGlobal);
                    shearVals.push(V);
                    momentVals.push(M);
                    dispVals.push(v * 1000); // Convert m to mm
                }
            }

            // Calculate Reactions (Global Equilibrium or Nodal Balance)
            // Reaction = K_row * d - F_equivalent
            // For Node 0:
            const R0_idx = 0;
            let R0_force = 0;
            for (let c = 0; c < numDOFs; c++) R0_force += K.get(0, c) * d[c];
            RA = R0_force - F[0]; // F[0] contains external loads added to node

            const M0_idx = 1;
            let M0_val = 0;
            for (let c = 0; c < numDOFs; c++) M0_val += K.get(1, c) * d[c];
            MA = M0_val - F[1];

            const Rn_idx = 2 * (numNodes - 1);
            let Rn_force = 0;
            for (let c = 0; c < numDOFs; c++) Rn_force += K.get(Rn_idx, c) * d[c];
            RB = Rn_force - F[Rn_idx];

            const Mn_idx = Rn_idx + 1;
            let Mn_val = 0;
            for (let c = 0; c < numDOFs; c++) Mn_val += K.get(Mn_idx, c) * d[c];
            MB = Mn_val - F[Mn_idx];

            // Constraint Reactions
            const constraintReactions = [];
            if (constraintList) {
                constraintList.forEach(c => {
                    const nIdx = uniqueNodes.findIndex(x => Math.abs(x - c.location) < 1e-6);
                    if (nIdx !== -1) {
                        // Calculate Internal Force at this node by summing element forces
                        // F_int = sum(k_e * u_e) for all connected elements
                        let F_int = 0;

                        // Check element to the left (connects nIdx-1 to nIdx)
                        if (nIdx > 0) {
                            const x1 = uniqueNodes[nIdx - 1];
                            const x2 = uniqueNodes[nIdx];
                            const le = x2 - x1;
                            const u = [d[2 * (nIdx - 1)], d[2 * (nIdx - 1) + 1], d[2 * nIdx], d[2 * nIdx + 1]];

                            // Row 2 of stiffness matrix (Vertical force at second node)
                            const k21 = -12 * EI / le ** 3;
                            const k22 = -6 * EI / le ** 2;
                            const k23 = 12 * EI / le ** 3;
                            const k24 = -6 * EI / le ** 2;

                            F_int += k21 * u[0] + k22 * u[1] + k23 * u[2] + k24 * u[3];

                            // Add Fixed End Action from Distributed Load on this element
                            loadList.forEach(l => {
                                if (l.type === 'distributed') {
                                    const start = Math.max(x1, l.location);
                                    const end = Math.min(x2, l.endLocation);
                                    if (Math.abs(start - x1) < 1e-6 && Math.abs(end - x2) < 1e-6) {
                                        const q = -l.magnitude;
                                        // FEA at node 2 (vertical) is qL/2
                                        F_int -= q * le / 2;
                                    }
                                }
                            });
                        }

                        // Check element to the right (connects nIdx to nIdx+1)
                        if (nIdx < numNodes - 1) {
                            const x1 = uniqueNodes[nIdx];
                            const x2 = uniqueNodes[nIdx + 1];
                            const le = x2 - x1;
                            const u = [d[2 * nIdx], d[2 * nIdx + 1], d[2 * (nIdx + 1)], d[2 * (nIdx + 1) + 1]];

                            // Row 0 of stiffness matrix (Vertical force at first node)
                            const k11 = 12 * EI / le ** 3;
                            const k12 = 6 * EI / le ** 2;
                            const k13 = -12 * EI / le ** 3;
                            const k14 = 6 * EI / le ** 2;

                            F_int += k11 * u[0] + k12 * u[1] + k13 * u[2] + k14 * u[3];

                            // Add Fixed End Action
                            loadList.forEach(l => {
                                if (l.type === 'distributed') {
                                    const start = Math.max(x1, l.location);
                                    const end = Math.min(x2, l.endLocation);
                                    if (Math.abs(start - x1) < 1e-6 && Math.abs(end - x2) < 1e-6) {
                                        const q = -l.magnitude;
                                        // FEA at node 1 (vertical) is qL/2
                                        F_int -= q * le / 2;
                                    }
                                }
                            });
                        }

                        // Calculate External Point Load at this node
                        let F_ext = 0;
                        loadList.forEach(l => {
                            if (l.type === 'point' && Math.abs(l.location - c.location) < 1e-6) {
                                F_ext -= l.magnitude; // Downward load is negative
                            }
                        });

                        // Reaction R = F_int - F_ext
                        const R_c = F_int - F_ext;

                        constraintReactions.push({ location: c.location, magnitude: R_c });
                    }
                });
            }

            return { x: xVals, V: shearVals, M: momentVals, disp: dispVals, reactions: { RA, MA: -MA, RB, MB: -MB, constraints: constraintReactions } };
        }

        // --- Main Update Function ---
        function updateAnalysis() {
            const L = parseFloat(document.getElementById('beamLength').value);
            const leftType = document.getElementById('leftSupport').value;
            const rightType = document.getElementById('rightSupport').value;

            const res = solveBeam(L, leftType, rightType, loads, constraints);

            // Update Text
            const rEl = document.getElementById('reactionOutput');
            let html = `
            <div><strong>R_Left (Up):</strong> ${res.reactions.RA.toFixed(2)} kN</div>
            <div><strong>R_Right (Up):</strong> ${res.reactions.RB.toFixed(2)} kN</div>
            ${res.reactions.MA !== 0 ? `<div><strong>M_Left:</strong> ${res.reactions.MA.toFixed(2)} kNm</div>` : ''}
            ${res.reactions.MB !== 0 ? `<div><strong>M_Right:</strong> ${res.reactions.MB.toFixed(2)} kNm</div>` : ''}
            `;

            if (res.reactions.constraints.length > 0) {
                html += `<div style="grid-column: span 2; margin-top: 5px; border-top: 1px solid #ccc; padding-top: 5px;"><strong>Constraint Reactions:</strong></div>`;
                res.reactions.constraints.forEach(c => {
                    html += `<div>@ ${c.location}m: ${c.magnitude.toFixed(2)} kN</div>`;
                });
            }
            rEl.innerHTML = html;

            drawVisualizer(L, leftType, rightType, loads, constraints);
            drawCharts(res.x, res.V, res.M, res.disp);
        }

        // --- Visualization (Canvas) ---
        function drawVisualizer(L, left, right, loadList, constraintList) {
            const canvas = document.getElementById('beamViz');
            const ctx = canvas.getContext('2d');
            const w = canvas.width = canvas.parentElement.offsetWidth;
            const h = canvas.height = 150;

            ctx.clearRect(0, 0, w, h);

            const margin = 50;
            const beamY = h / 2 + 20;
            const beamLenPx = w - 2 * margin;
            const scale = beamLenPx / L;

            // Draw Beam
            ctx.beginPath();
            ctx.lineWidth = 6;
            ctx.strokeStyle = '#cbd5e1';
            ctx.moveTo(margin, beamY);
            ctx.lineTo(margin + beamLenPx, beamY);
            ctx.stroke();

            // Helper: Draw Triangle (Pin)
            function drawPin(x) {
                ctx.beginPath();
                ctx.fillStyle = '#64748b';
                ctx.moveTo(x, beamY + 4);
                ctx.lineTo(x - 10, beamY + 20);
                ctx.lineTo(x + 10, beamY + 20);
                ctx.fill();
            }

            // Helper: Draw Block (Fixed)
            function drawFixed(x, isLeft) {
                ctx.beginPath();
                ctx.lineWidth = 4;
                ctx.strokeStyle = '#64748b';
                ctx.moveTo(x, beamY - 20);
                ctx.lineTo(x, beamY + 20);
                ctx.stroke();
                // Hatches
                for (let i = -20; i < 20; i += 5) {
                    ctx.beginPath();
                    ctx.lineWidth = 1;
                    ctx.moveTo(x, beamY + i);
                    ctx.lineTo(x + (isLeft ? -10 : 10), beamY + i + 5);
                    ctx.stroke();
                }
            }

            // Helper: Draw Roller (Constraint)
            function drawRoller(x) {
                ctx.beginPath();
                ctx.fillStyle = '#2563eb';
                ctx.arc(x, beamY + 10, 8, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.moveTo(x - 10, beamY + 20);
                ctx.lineTo(x + 10, beamY + 20);
                ctx.strokeStyle = '#2563eb';
                ctx.lineWidth = 2;
                ctx.stroke();
            }

            // Draw Supports
            if (left === 'pinned') drawPin(margin);
            if (left === 'fixed') drawFixed(margin, true);
            if (right === 'pinned') drawPin(margin + beamLenPx);
            if (right === 'fixed') drawFixed(margin + beamLenPx, false);

            // Draw Constraints
            if (constraintList) {
                constraintList.forEach(c => {
                    drawRoller(margin + c.location * scale);
                });
            }

            // Draw Loads
            loadList.forEach(l => {
                ctx.fillStyle = '#ef4444';
                ctx.strokeStyle = '#ef4444';
                let startX = margin + l.location * scale;

                if (l.type === 'point') {
                    // Arrow down
                    ctx.beginPath();
                    ctx.moveTo(startX, beamY - 50);
                    ctx.lineTo(startX, beamY - 5);
                    ctx.lineWidth = 2;
                    ctx.stroke();
                    // Arrowhead
                    ctx.beginPath();
                    ctx.moveTo(startX - 5, beamY - 15);
                    ctx.lineTo(startX, beamY - 5);
                    ctx.lineTo(startX + 5, beamY - 15);
                    ctx.fill();
                    // Text
                    ctx.fillText(l.magnitude + "kN", startX - 10, beamY - 55);
                } else if (l.type === 'distributed') {
                    let endX = margin + (l.endLocation || l.location) * scale;
                    ctx.globalAlpha = 0.3;
                    ctx.fillRect(startX, beamY - 30, endX - startX, 28);
                    ctx.globalAlpha = 1.0;
                    ctx.fillText(l.magnitude + "kN/m", startX, beamY - 35);
                }
            });
        }

        // --- Charting ---
        function drawCharts(xVals, shearData, momentData, dispData) {
            // Destroy old charts if exist
            if (charts.shear) charts.shear.destroy();
            if (charts.moment) charts.moment.destroy();
            if (charts.disp) charts.disp.destroy();

            const commonOptions = {
                responsive: true,
                plugins: {
                    legend: { display: false }
                },
                scales: {
                    x: {
                        type: 'linear',
                        title: { display: true, text: 'Length (m)', color: '#64748b' },
                        ticks: { maxTicksLimit: 10, color: '#64748b' },
                        grid: { color: '#e2e8f0' }
                    },
                    y: {
                        title: { display: true, text: 'Magnitude', color: '#64748b' },
                        ticks: { color: '#64748b' },
                        grid: { color: '#e2e8f0' }
                    }
                },
                elements: { point: { radius: 0 } } // Hide points for smooth line
            };

            // Shear Chart
            const ctxS = document.getElementById('shearChart').getContext('2d');
            charts.shear = new Chart(ctxS, {
                type: 'line',
                data: {
                    datasets: [{
                        label: 'Shear Force (kN)',
                        data: xVals.map((x, i) => ({ x: x, y: shearData[i] })),
                        borderColor: '#2563eb',
                        backgroundColor: 'rgba(37, 99, 235, 0.1)',
                        fill: true,
                        borderWidth: 2
                    }]
                },
                options: commonOptions
            });

            // Moment Chart
            const ctxM = document.getElementById('momentChart').getContext('2d');
            charts.moment = new Chart(ctxM, {
                type: 'line',
                data: {
                    datasets: [{
                        label: 'Bending Moment (kNm)',
                        data: xVals.map((x, i) => ({ x: x, y: momentData[i] })),
                        borderColor: '#059669',
                        backgroundColor: 'rgba(5, 150, 105, 0.1)',
                        fill: true,
                        borderWidth: 2
                    }]
                },
                options: commonOptions
            });

            // Displacement Chart
            const ctxD = document.getElementById('dispChart').getContext('2d');
            charts.disp = new Chart(ctxD, {
                type: 'line',
                data: {
                    datasets: [{
                        label: 'Displacement (mm)',
                        data: xVals.map((x, i) => ({ x: x, y: dispData[i] })),
                        borderColor: '#d97706',
                        backgroundColor: 'rgba(217, 119, 6, 0.1)',
                        fill: true,
                        borderWidth: 2
                    }]
                },
                options: commonOptions
            });
        }
    </script>

</body>

</html>