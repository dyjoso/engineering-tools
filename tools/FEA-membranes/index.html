<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=20.0">
    <title>2D Membrane FEA Tool</title>
    <!-- Add defer attribute to library scripts -->
    <script defer src="https://cdn.jsdelivr.net/npm/konva@9.3.6/konva.min.js"
        onerror="console.error('FATAL: Failed to load Konva!')"></script>
    <!-- RE-ADD math.js script tag -->
    <script defer src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/12.4.1/math.min.js"
        onerror="console.error('FATAL: Failed to load Math.js!')"></script>

    <!-- Tailwind might not need defer, but can add for consistency -->
    <script defer src="https://cdn.tailwindcss.com" onerror="console.error('FATAL: Failed to load Tailwind!')"></script>
    <style>
        /* Basic styling */
        body {
            font-family: 'Inter', sans-serif;
        }

        /* ... rest of styles ... */
    </style>
</head>

<body class="bg-gray-100 p-4">

    <h1 class="text-2xl font-bold mb-4 text-center text-gray-800">2D Membrane FEA Tool</h1>

    <div class="flex flex-col md:flex-row gap-4">
        <div class="w-full md:w-1/4 bg-white p-4 rounded-lg shadow overflow-y-auto max-h-[90vh]">
            <h2 class="text-lg font-semibold mb-3 border-b pb-2">Controls - Modes</h2>
            <div class="space-y-2"> <!-- Parent div for mode buttons -->
                <!-- Added Tailwind classes directly -->
                <button id="btn-add-node"
                    class="bg-blue-600 hover:bg-blue-700 text-white font-semibold py-1.5 px-3 rounded-lg shadow-sm hover:shadow transition duration-150 ease-in-out mb-2 w-full text-left disabled:opacity-50 disabled:cursor-not-allowed active">Mode:
                    Add Node</button>
                <button id="btn-select-geo-node"
                    class="bg-blue-600 hover:bg-blue-700 text-white font-semibold py-1.5 px-3 rounded-lg shadow-sm hover:shadow transition duration-150 ease-in-out mb-2 w-full text-left disabled:opacity-50 disabled:cursor-not-allowed">Mode:
                    Select Geo Node</button>
                <button id="btn-select-membrane"
                    class="bg-blue-600 hover:bg-blue-700 text-white font-semibold py-1.5 px-3 rounded-lg shadow-sm hover:shadow transition duration-150 ease-in-out mb-2 w-full text-left disabled:opacity-50 disabled:cursor-not-allowed">Mode:
                    Select Membrane</button>
                <button id="btn-select-fe-box"
                    class="bg-blue-600 hover:bg-blue-700 text-white font-semibold py-1.5 px-3 rounded-lg shadow-sm hover:shadow transition duration-150 ease-in-out mb-2 w-full text-left disabled:opacity-50 disabled:cursor-not-allowed">Mode:
                    Select FE Nodes (Box)</button>
                <button id="btn-mark-spring"
                    class="bg-blue-600 hover:bg-blue-700 text-white font-semibold py-1.5 px-3 rounded-lg shadow-sm hover:shadow transition duration-150 ease-in-out mb-2 w-full text-left disabled:opacity-50 disabled:cursor-not-allowed">Mode:
                    Mark Spring Point</button>
                <button id="btn-delete-item"
                    class="bg-blue-600 hover:bg-blue-700 text-white font-semibold py-1.5 px-3 rounded-lg shadow-sm hover:shadow transition duration-150 ease-in-out mb-2 w-full text-left disabled:opacity-50 disabled:cursor-not-allowed">Mode:
                    Delete Item</button>
                <!-- Added new mode button -->
                <button id="btn-add-rect-membrane"
                    class="bg-blue-600 hover:bg-blue-700 text-white font-semibold py-1.5 px-3 rounded-lg shadow-sm hover:shadow transition duration-150 ease-in-out mb-2 w-full text-left disabled:opacity-50 disabled:cursor-not-allowed">Mode:
                    Add Rect Membrane</button>
                <!-- Added new mode button -->
                <button id="btn-add-spring-grid"
                    class="bg-blue-600 hover:bg-blue-700 text-white font-semibold py-1.5 px-3 rounded-lg shadow-sm hover:shadow transition duration-150 ease-in-out mb-2 w-full text-left disabled:opacity-50 disabled:cursor-not-allowed">Mode:
                    Add Spring Grid</button>
                <div id="spring-grid-input-area" class="p-3 my-2 border border-gray-200 rounded bg-gray-50" hidden>
                    <!-- Input Area Style -->
                    <label for="spring-grid-nx-input"
                        class="block text-sm font-medium text-gray-700 mb-1">Nx:</label><input type="number"
                        id="spring-grid-nx-input" name="spring-grid-nx" min="2" value="4"
                        class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm py-1 px-2 font-mono">
                    <label for="spring-grid-ny-input"
                        class="mt-2 block text-sm font-medium text-gray-700 mb-1">Ny:</label><input type="number"
                        id="spring-grid-ny-input" name="spring-grid-ny" min="2" value="3"
                        class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm py-1 px-2 font-mono">
                    <!-- Removed Confirm Spring Grid button from here -->
                </div>
                <!-- New Edit Node Mode Button -->
                <button id="btn-edit-node-coords"
                    class="bg-blue-600 hover:bg-blue-700 text-white font-semibold py-1.5 px-3 rounded-lg shadow-sm hover:shadow transition duration-150 ease-in-out mb-2 w-full text-left disabled:opacity-50 disabled:cursor-not-allowed">Mode:
                    Edit Node Coords</button>
                <!-- New Input Area for Editing Node Coordinates -->
                <div id="edit-node-coords-input-area" class="p-3 my-2 border border-gray-200 rounded bg-gray-50" hidden>
                    <h4 class="text-md font-semibold mb-2">Edit Coordinates</h4>
                    <p class="text-sm mb-2">Node ID: <span id="edit-node-id-display" class="font-mono">N/A</span></p>
                    <label for="edit-node-x-input" class="block text-sm font-medium text-gray-700 mb-1">New X:</label>
                    <input type="number" id="edit-node-x-input" step="any"
                        class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm py-1 px-2 font-mono">
                    <label for="edit-node-y-input" class="mt-2 block text-sm font-medium text-gray-700 mb-1">New
                        Y:</label>
                    <input type="number" id="edit-node-y-input" step="any"
                        class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm py-1 px-2 font-mono">
                    <button id="btn-apply-node-coords"
                        class="mt-3 w-full bg-indigo-600 hover:bg-indigo-700 text-white font-semibold py-1.5 px-3 rounded-lg shadow-sm hover:shadow">Apply
                        Coordinates</button>
                </div>
            </div> <!-- End parent div for mode buttons -->
            <hr class="my-3 border-gray-300">

            <h2 class="text-lg font-semibold mb-3 border-b pb-2">Controls - Actions</h2>
            <div class="space-y-2">
                <button id="btn-add-membrane"
                    class="bg-blue-600 hover:bg-blue-700 text-white font-semibold py-1.5 px-3 rounded-lg shadow-sm hover:shadow transition duration-150 ease-in-out mb-2 w-full text-left disabled:opacity-50 disabled:cursor-not-allowed">Create
                    Membrane</button>
                <button id="btn-mesh-membranes"
                    class="bg-blue-600 hover:bg-blue-700 text-white font-semibold py-1.5 px-3 rounded-lg shadow-sm hover:shadow transition duration-150 ease-in-out mb-2 w-full text-left disabled:opacity-50 disabled:cursor-not-allowed">Mesh
                    Selected Membranes</button>
                <div id="mesh-input-area" class="p-3 my-2 border border-gray-200 rounded bg-gray-50" hidden>
                    <!-- Input Area Style -->
                    <label for="mesh-m-input" class="block text-sm font-medium text-gray-700 mb-1">Divisions M
                        (X-dir):</label><input type="number" id="mesh-m-input" name="mesh-m" min="1" value="4"
                        class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm py-1 px-2 font-mono">
                    <label for="mesh-n-input" class="mt-2 block text-sm font-medium text-gray-700 mb-1">Divisions N
                        (Y-dir):</label><input type="number" id="mesh-n-input" name="mesh-n" min="1" value="3"
                        class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm py-1 px-2 font-mono">
                    <button id="btn-confirm-mesh"
                        class="mt-3 w-full bg-indigo-600 hover:bg-indigo-700 text-white font-semibold py-1.5 px-3 rounded-lg shadow-sm hover:shadow">Confirm
                        Mesh</button> <!-- Input Area Button Style -->
                </div>
                <button id="btn-add-spring"
                    class="bg-blue-600 hover:bg-blue-700 text-white font-semibold py-1.5 px-3 rounded-lg shadow-sm hover:shadow transition duration-150 ease-in-out mb-2 w-full text-left disabled:opacity-50 disabled:cursor-not-allowed">Create
                    Springs</button>
                <div id="spring-input-area" class="p-3 my-2 border border-gray-200 rounded bg-gray-50" hidden>
                    <!-- Input Area Style -->
                    <label for="spring-k-input" class="block text-sm font-medium text-gray-700 mb-1">Stiffness
                        (k):</label><input type="number" id="spring-k-input" name="spring-k" min="0" step="any"
                        value="1000"
                        class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm py-1 px-2 font-mono">
                    <button id="btn-confirm-springs"
                        class="mt-3 w-full bg-indigo-600 hover:bg-indigo-700 text-white font-semibold py-1.5 px-3 rounded-lg shadow-sm hover:shadow">Confirm
                        Springs</button> <!-- Input Area Button Style -->
                </div>
                <hr class="my-2 border-gray-300">
                <div id="bc-input-area" class="p-3 my-2 border border-gray-200 rounded bg-gray-50" hidden>
                    <!-- Input Area Style -->
                    <h4 class="text-md font-semibold mb-2">Apply Boundary Condition</h4>
                    <label for="bc-type-select" class="block text-sm font-medium text-gray-700 mb-1">Type:</label>
                    <select id="bc-type-select" name="bc-type"
                        class="mb-2 mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm py-1 px-2 font-mono">
                        <option value="none">None (Clear BC)</option>
                        <option value="fixed">Fixed Displacement</option>
                        <option value="enforced">Enforced Displacement</option>
                        <option value="load">Nodal Load</option>
                    </select>
                    <div id="bc-fixed-options" class="sub-options mt-2 pl-3 border-l-2 border-gray-200" hidden> <label
                            class="block text-sm font-medium text-gray-700 mb-1"><input type="checkbox" id="bc-fix-x"
                                class="h-4 w-4 text-indigo-600 border-gray-300 rounded focus:ring-indigo-500 mr-2"> Fix
                            X</label><br> <label class="block text-sm font-medium text-gray-700 mb-1"><input
                                type="checkbox" id="bc-fix-y"
                                class="h-4 w-4 text-indigo-600 border-gray-300 rounded focus:ring-indigo-500 mr-2"> Fix
                            Y</label> </div>
                    <div id="bc-enforced-options" class="sub-options mt-2 pl-3 border-l-2 border-gray-200" hidden>
                        <label class="block text-sm font-medium text-gray-700 mb-1"><input type="checkbox"
                                id="bc-enforce-x"
                                class="h-4 w-4 text-indigo-600 border-gray-300 rounded focus:ring-indigo-500 mr-2">
                            Enforce X:</label> <input type="number" id="bc-dx-input" step="any" placeholder="Dx value"
                            class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm py-1 px-2 font-mono">
                        <label class="mt-2 block text-sm font-medium text-gray-700 mb-1"><input type="checkbox"
                                id="bc-enforce-y"
                                class="h-4 w-4 text-indigo-600 border-gray-300 rounded focus:ring-indigo-500 mr-2">
                            Enforce Y:</label> <input type="number" id="bc-dy-input" step="any" placeholder="Dy value"
                            class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm py-1 px-2 font-mono">
                    </div>
                    <div id="bc-load-options" class="sub-options mt-2 pl-3 border-l-2 border-gray-200" hidden> <label
                            for="bc-fx-input" class="block text-sm font-medium text-gray-700 mb-1">Load Fx:</label>
                        <input type="number" id="bc-fx-input" step="any" placeholder="Fx value"
                            class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm py-1 px-2 font-mono">
                        <label for="bc-fy-input" class="mt-2 block text-sm font-medium text-gray-700 mb-1">Load
                            Fy:</label> <input type="number" id="bc-fy-input" step="any" placeholder="Fy value"
                            class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm py-1 px-2 font-mono">
                    </div>
                    <button id="btn-apply-bc-confirm"
                        class="mt-3 w-full bg-indigo-600 hover:bg-indigo-700 text-white font-semibold py-1.5 px-3 rounded-lg shadow-sm hover:shadow">Apply
                        BC to Selected</button> <!-- Input Area Button Style -->
                </div>
                <hr class="my-2 border-gray-300">
                <!-- ADDED New Per-Membrane Material Properties Area (initially hidden) -->
                <div id="membrane-material-input-area" class="p-3 my-2 border border-gray-200 rounded bg-gray-50"
                    hidden>
                    <h4 class="text-md font-semibold mb-2">Material Properties (Selected Membranes)</h4>
                    <p id="material-note" class="text-xs text-gray-500 mb-2 italic"></p>
                    <label for="mem-mat-prop-e" class="block text-sm font-medium text-gray-700 mb-1">Young's Modulus
                        (E):</label>
                    <input type="number" id="mem-mat-prop-e" value="10.5e6"
                        class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm py-1 px-2 font-mono">
                    <label for="mem-mat-prop-nu" class="mt-2 block text-sm font-medium text-gray-700 mb-1">Poisson's
                        Ratio (nu):</label>
                    <input type="number" id="mem-mat-prop-nu" step="0.01" min="0" max="0.5" value="0.3"
                        class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm py-1 px-2 font-mono">
                    <label for="mem-mat-prop-t" class="mt-2 block text-sm font-medium text-gray-700 mb-1">Thickness
                        (t):</label>
                    <input type="number" id="mem-mat-prop-t" min="0" value="0.05"
                        class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm py-1 px-2 font-mono">
                    <button id="btn-apply-material"
                        class="mt-3 w-full bg-indigo-600 hover:bg-indigo-700 text-white font-semibold py-1.5 px-3 rounded-lg shadow-sm hover:shadow">Apply
                        Properties to Selected</button>
                </div>

                <hr class="my-2 border-gray-300">
                <!-- Note: Special background colors for Solve/Save/Load are handled via !important utilities or specific JS -->
                <button id="btn-solve"
                    class="bg-red-600 hover:bg-red-700 text-white font-semibold py-1.5 px-3 rounded-lg shadow-sm hover:shadow transition duration-150 ease-in-out mb-2 w-full text-left disabled:opacity-50 disabled:cursor-not-allowed">Run
                    Analysis</button>
                <hr class="my-3 border-gray-300">
                <h2 class="text-lg font-semibold mb-3 border-b pb-2">Save / Load</h2>
                <div class="space-y-2">
                    <button id="btn-save-model"
                        class="bg-gray-600 hover:bg-gray-700 text-white font-semibold py-1.5 px-3 rounded-lg shadow-sm hover:shadow transition duration-150 ease-in-out mb-2 w-full text-left disabled:opacity-50 disabled:cursor-not-allowed">Save
                        Model (Copy JSON)</button>
                    <div id="load-model-area" class="p-3 my-2 border border-gray-200 rounded bg-gray-50">
                        <!-- Input Area Style -->
                        <label for="load-textarea" class="block text-sm font-medium text-gray-700 mb-1">Paste Model JSON
                            here:</label>
                        <textarea id="load-textarea" rows="4"
                            class="text-xs mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm py-1 px-2 font-mono"></textarea>
                        <button id="btn-load-text"
                            class="mt-3 w-full bg-gray-600 hover:bg-gray-700 text-white font-semibold py-1.5 px-3 rounded-lg shadow-sm hover:shadow">Load
                            from Text</button> <!-- Special Button Style -->
                    </div>
                </div>
            </div>
            <!-- Added Tailwind classes directly to Results Area elements -->
            <div class="results-area mt-4 pt-4 border-t">
                <h3 class="text-md font-semibold mb-2">Selected Geo Nodes</h3>
                <div id="selection-info"
                    class="text-sm text-gray-600 h-16 overflow-y-auto bg-gray-50 p-2 rounded border">None.</div>
            </div>
            <div class="results-area mt-4 pt-4 border-t">
                <h3 class="text-md font-semibold mb-2">Selected Membranes</h3>
                <div id="membrane-selection-info"
                    class="text-sm text-gray-600 h-16 overflow-y-auto bg-gray-50 p-2 rounded border">None.</div>
            </div>
            <div class="results-area mt-4 pt-4 border-t">
                <h3 class="text-md font-semibold mb-2">Selected FE Nodes</h3>
                <div id="fe-selection-info"
                    class="text-sm text-gray-600 h-16 overflow-y-auto bg-gray-50 p-2 rounded border">None.</div>
            </div>
            <div class="results-area mt-4 pt-4 border-t">
                <h3 class="text-md font-semibold mb-2">Marked Spring Points</h3>
                <div id="spring-points-info"
                    class="text-sm text-gray-600 h-16 overflow-y-auto bg-gray-50 p-2 rounded border">None.</div>
            </div>

            <div class="results-area mt-4 pt-4 border-t">
                <h3 class="text-md font-semibold mb-2">Analysis Results</h3>
                <div class="results-toggle mb-2">
                    <label class="mr-4 text-sm cursor-pointer"><input type="radio" name="results-view" value="springs"
                            id="radio-view-springs" checked class="mr-1 cursor-pointer"> Springs</label>
                    <label class="mr-4 text-sm cursor-pointer"><input type="radio" name="results-view" value="reactions"
                            id="radio-view-reactions" class="mr-1 cursor-pointer"> Reactions</label>
                    <label class="mr-4 text-sm cursor-pointer"><input type="radio" name="results-view" value="stress"
                            id="radio-view-stress" class="mr-1 cursor-pointer"> Stress</label>
                </div>
                <div id="results-springs" class="results-content">
                    <h4>Spring Loads:</h4>
                    <pre
                        class="text-xs bg-gray-100 p-2 rounded border h-20 overflow-y-auto whitespace-pre-wrap">Not run yet.</pre>
                </div>
                <div id="results-reactions" class="results-content" hidden>
                    <h4>Reaction Forces:</h4>
                    <pre
                        class="text-xs bg-gray-100 p-2 rounded border h-20 overflow-y-auto whitespace-pre-wrap">Not run yet.</pre>
                </div>
                <div id="results-stress" class="results-content" hidden>
                    <h4>Membrane Stresses (Von Mises):</h4>
                    <pre
                        class="text-xs bg-gray-100 p-2 rounded border h-20 overflow-y-auto whitespace-pre-wrap">Not run yet.</pre>
                </div>
            </div>

            <div class="mt-4 pt-4 border-t">
                <h3 class="text-md font-semibold mb-2">Status</h3>
                <div id="status-message" class="text-sm text-blue-700"> Initializing... </div>
            </div>
        </div>

        <div class="w-full md:w-3/4">
            <div id="container" class="w-full h-[800px] bg-white rounded-lg shadow" style="min-height: 800px;"></div>
        </div>
    </div>

    <script>
        console.log("Script block started.");

        // --- Global Variables ---
        let stage;
        let backgroundLayer, membraneFillLayer, meshLayer, springLayer, geometryLayer, selectionLayer, stressLayer;
        let currentMode = 'add-node';
        // --- ADDED state variable for the new mode ---
        let rectMembraneFirstCornerNode = null;
        // --- ADDED state for spring grid mode ---
        let springGridFirstCornerPos = null;
        // --- ADDED state for editing node coords ---
        let editingNodeId = null;
        let nodes = [], membranes = [], selectedNodes = [], selectedMembranes = [], geometricSpringNodes = [];
        let feNodes = [], feElements = [], feSprings = [];
        let selectedFeNodes = [];
        let isSelectingBox = false;
        let selectionBoxStart = { x: 0, y: 0 };
        let selectionRect = null;
        let nextNodeId = 1, nextMembraneId = 1, feNodeIdCounter = 1, feElementIdCounter = 1, feSpringIdCounter = 1;
        // --- REMOVED Global Material Variables ---
        let resultsDisplacements = null; let resultsSpringLoads = []; let resultsReactions = []; let resultsElementStresses = [];

        // --- ADDED Default Material Constants ---
        const DEFAULT_MATERIAL_E = 10.5e6;
        const DEFAULT_MATERIAL_NU = 0.3;
        const DEFAULT_MATERIAL_T = 0.05;

        const DEFAULT_NODE_COLOR = 'red', SPRING_NODE_COLOR = 'purple', FE_NODE_COLOR = 'blue', FE_NODE_SELECTED_COLOR = 'orange';
        // --- Define Target Pixel Sizes ---
        const NODE_RADIUS_TARGET_PX = 6;
        const NODE_STROKE_WIDTH_TARGET_PX = 1;
        const FE_NODE_RADIUS_TARGET_PX = 2;
        const FE_NODE_SELECTED_RADIUS_TARGET_PX = 3.5;
        // --- Reduced target line width ---
        const LINE_STROKE_WIDTH_TARGET_PX = 0.75; // For mesh, springs, etc.
        const BC_SYMBOL_SIZE_TARGET_PX = 8;
        const BC_SYMBOL_OFFSET_TARGET_PX = 4; // Offset from node edge
        // --- Fixed Pixel Size/Offset Constants for Spring Labels ---
        const SPRING_LABEL_FIXED_FONT_SIZE = 12; // Font size in screen pixels (e.g., 10px)
        const SPRING_LABEL_SCREEN_OFFSET_X = 6;  // Offset right from node1 in screen pixels
        const SPRING_LABEL_SCREEN_OFFSET_Y = 10;  // Offset 'up' from node1 in screen pixels
        const FE_NODE_RADIUS = 2, FE_NODE_SELECTED_RADIUS = 3.5; // REMOVE these old constants
        const MESH_LINE_COLOR = '#999999', SPRING_LINE_COLOR = 'green', SPRING_LABEL_COLOR = 'darkgreen';
        const MEMBRANE_DEFAULT_OPACITY = 0.5, MEMBRANE_SELECTED_OPACITY = 0.8;
        const MEMBRANE_DEFAULT_STROKE = 'blue', MEMBRANE_SELECTED_STROKE = 'orange';
        // --- Reduced selected membrane stroke width ---
        const MEMBRANE_DEFAULT_STROKE_WIDTH = 1, MEMBRANE_SELECTED_STROKE_WIDTH = 1.5;
        const SPRING_CONN_TOLERANCE_SQ = 4.0;
        const SELECTION_BOX_COLOR = 'rgba(0, 123, 255, 0.3)';
        const SPRING_RESULT_LABEL_OFFSET_PX = 6; // Offset in pixels from node center (adjust as needed)

        // --- Function Definitions ---

        // --- Moved UI Update Functions Higher ---
        function updateStatus(message) { const statusElement = document.getElementById('status-message'); if (statusElement) { statusElement.textContent = message; } else { console.warn("Status message element not found."); } }
        function updateSelectionInfo() { const infoDiv = document.getElementById('selection-info'); if (!infoDiv) return; if (selectedNodes.length === 0) { infoDiv.textContent = 'None.'; } else { infoDiv.innerHTML = `Node IDs (${selectedNodes.length}):<br>`; selectedNodes.forEach((node, index) => { if (node && typeof node.id !== 'undefined') { infoDiv.innerHTML += `${index + 1}. ${node.id} <br>`; } else { infoDiv.innerHTML += `${index + 1}. ? <br>`; console.error("Error displaying node data:", node); } }); } }
        function updateSpringPointsInfo() { const infoDiv = document.getElementById('spring-points-info'); if (!infoDiv) return; if (geometricSpringNodes.length === 0) { infoDiv.textContent = 'None.'; } else { infoDiv.innerHTML = `Node IDs: ${geometricSpringNodes.join(', ')}`; } }
        function updateMembraneSelectionInfo() { const infoDiv = document.getElementById('membrane-selection-info'); if (!infoDiv) return; if (selectedMembranes.length === 0) { infoDiv.textContent = 'None.'; } else { infoDiv.innerHTML = `Membrane IDs: ${selectedMembranes.join(', ')}`; } }
        function updateFeSelectionInfo() { const infoDiv = document.getElementById('fe-selection-info'); if (!infoDiv) return; if (selectedFeNodes.length === 0) { infoDiv.textContent = 'None.'; } else { infoDiv.innerHTML = `Count: ${selectedFeNodes.length}<br>IDs: ${selectedFeNodes.slice(0, 10).join(', ')} ${selectedFeNodes.length > 10 ? '...' : ''}`; } }
        function toggleBcInputArea() { const bcArea = document.getElementById('bc-input-area'); if (!bcArea) return; const hasSelection = selectedFeNodes.length > 0; bcArea.hidden = !hasSelection; if (hasSelection) { document.getElementById('bc-type-select').value = 'none'; handleBcTypeChange(); } }
        function handleBcTypeChange() { const selectedType = document.getElementById('bc-type-select')?.value; document.getElementById('bc-fixed-options')?.setAttribute('hidden', ''); document.getElementById('bc-enforced-options')?.setAttribute('hidden', ''); document.getElementById('bc-load-options')?.setAttribute('hidden', ''); if (selectedType === 'fixed') { document.getElementById('bc-fixed-options')?.removeAttribute('hidden'); } else if (selectedType === 'enforced') { document.getElementById('bc-enforced-options')?.removeAttribute('hidden'); } else if (selectedType === 'load') { document.getElementById('bc-load-options')?.removeAttribute('hidden'); } }

        // --- ADDED Function to update material property display (Moved Higher) ---
        function updateMaterialPropertyDisplay() {
            const materialArea = document.getElementById('membrane-material-input-area');
            const noteP = document.getElementById('material-note');
            const inputE = document.getElementById('mem-mat-prop-e');
            const inputNu = document.getElementById('mem-mat-prop-nu');
            const inputT = document.getElementById('mem-mat-prop-t');

            if (!materialArea || !noteP || !inputE || !inputNu || !inputT) {
                console.error("Material property UI elements not found!");
                return;
            }

            if (selectedMembranes.length > 0) {
                const firstSelectedId = selectedMembranes[0];
                const firstMembrane = findMembraneById(firstSelectedId);
                if (firstMembrane) {
                    inputE.value = firstMembrane.materialE ?? DEFAULT_MATERIAL_E;
                    inputNu.value = firstMembrane.materialNu ?? DEFAULT_MATERIAL_NU;
                    inputT.value = firstMembrane.materialT ?? DEFAULT_MATERIAL_T;
                    if (selectedMembranes.length > 1) {
                        noteP.textContent = `Showing properties for Membrane ${firstSelectedId}. Changes apply to all ${selectedMembranes.length} selected.`;
                    } else {
                        noteP.textContent = `Showing properties for Membrane ${firstSelectedId}.`;
                    }
                    materialArea.hidden = false;
                } else {
                    console.warn(`Could not find membrane data for selected ID ${firstSelectedId}`);
                    materialArea.hidden = true; // Hide if data is inconsistent
                }
            } else {
                materialArea.hidden = true; // Hide if no membranes are selected
                noteP.textContent = '';
            }
        }

        // --- ADDED Handler for applying material properties (Moved Higher) ---
        function handleApplyMaterialProperties() {
            console.log("Applying material properties to selected membranes...");
            if (selectedMembranes.length === 0) {
                updateStatus("No membranes selected to apply properties to.");
                return;
            }

            const inputE = document.getElementById('mem-mat-prop-e');
            const inputNu = document.getElementById('mem-mat-prop-nu');
            const inputT = document.getElementById('mem-mat-prop-t');
            let valid = true;
            const e_val = parseFloat(inputE?.value);
            const nu_val = parseFloat(inputNu?.value);
            const t_val = parseFloat(inputT?.value);

            if (isNaN(e_val) || e_val <= 0) { alert("Invalid Young's Modulus (E). Must be positive number."); valid = false; }
            if (isNaN(nu_val) || nu_val < 0 || nu_val > 0.5) { alert("Invalid Poisson's Ratio (nu). Must be between 0 and 0.5."); valid = false; }
            if (isNaN(t_val) || t_val <= 0) { alert("Invalid Thickness (t). Must be positive number."); valid = false; }

            if (!valid) {
                console.error("Invalid material properties entered.");
                updateStatus("Error: Invalid material properties.");
                return;
            }

            let updatedCount = 0;
            selectedMembranes.forEach(memId => {
                const membrane = findMembraneById(memId);
                if (membrane) {
                    membrane.materialE = e_val;
                    membrane.materialNu = nu_val;
                    membrane.materialT = t_val;
                    updatedCount++;
                    console.log(`Updated material for Membrane ${memId}: E=${e_val}, nu=${nu_val}, t=${t_val}`);
                } else {
                    console.warn(`Could not find membrane ${memId} to update properties.`);
                }
            });

            updateStatus(`Applied properties to ${updatedCount} selected membranes.`);
        }

        // --- Initialization ---
        function initializeKonva() {
            console.log("initializeKonva started...");
            // --- REMOVE Check for numeric.js --- REMOVED IN PREVIOUS STEP
            // if (typeof numeric === 'undefined') { ... }
            // --- End Removed Check ---

            try {
                const container = document.getElementById('container');
                if (!container) { console.error("Container element not found."); return; }
                const width = container.clientWidth; const height = container.clientHeight;
                if (!width || !height) { console.error("Container dimensions zero."); setTimeout(initializeKonva, 100); return; }
                if (typeof Konva === 'undefined') { console.error("Konva library not loaded yet."); setTimeout(initializeKonva, 100); return; }
                // Add check for math.js
                if (typeof math === 'undefined') { console.error("Math.js library not loaded yet."); /* Optionally add alert or status update */ }

                stage = new Konva.Stage({ container: 'container', width: width, height: height, draggable: true });
                backgroundLayer = new Konva.Layer(); stage.add(backgroundLayer);
                membraneFillLayer = new Konva.Layer(); stage.add(membraneFillLayer);
                stressLayer = new Konva.Layer({ opacity: 0.6 }); stage.add(stressLayer);
                meshLayer = new Konva.Layer(); stage.add(meshLayer);
                springLayer = new Konva.Layer(); stage.add(springLayer);
                geometryLayer = new Konva.Layer(); stage.add(geometryLayer);
                selectionLayer = new Konva.Layer(); stage.add(selectionLayer);
                const background = new Konva.Rect({ x: 0, y: 0, width: width, height: height, fill: '#f0f0f0' });
                backgroundLayer.add(background);

                stage.on('click tap', handleStageClick);
                stage.on('mousedown touchstart', handleStageMouseDown);
                stage.on('mousemove touchmove', handleStageMouseMove);
                stage.on('mouseup touchend', handleStageMouseUp);
                stage.on('wheel', handleWheelZoom);

                const safeAddListener = (id, event, handler) => { try { const element = document.getElementById(id); if (element) { if (typeof handler === 'function') { element.addEventListener(event, handler); } else { console.error(`Handler for #${id} is not defined or not a function!`); } } else { console.error(`Element #${id} not found!`); } } catch (err) { console.error(`Error adding listener for #${id}:`, err.message, err.stack); throw err; } };
                safeAddListener('btn-add-node', 'click', () => { console.log("Button Clicked: Add Node"); setMode('add-node'); });
                safeAddListener('btn-select-geo-node', 'click', () => { console.log("Button Clicked: Select Geo Node"); setMode('select-geo-node'); });
                // --- ADDED listener for new mode button ---
                safeAddListener('btn-add-rect-membrane', 'click', () => { console.log("Button Clicked: Add Rect Membrane"); setMode('add-rect-membrane'); });
                // --- ADDED listener for spring grid mode button ---
                safeAddListener('btn-add-spring-grid', 'click', () => { console.log("Button Clicked: Add Spring Grid"); setMode('add-spring-grid'); });
                // --- End of Added Listeners ---
                // --- ADDED listener for edit node coords mode ---
                safeAddListener('btn-edit-node-coords', 'click', () => { console.log("Button Clicked: Edit Node Coords"); setMode('edit-node-coords'); });
                safeAddListener('btn-select-membrane', 'click', () => { console.log("Button Clicked: Select Membrane"); setMode('select-membrane'); });
                safeAddListener('btn-select-fe-box', 'click', () => { console.log("Button Clicked: Select FE Box"); setMode('select-fe-nodes-box'); });
                safeAddListener('btn-mark-spring', 'click', () => { console.log("Button Clicked: Mark Spring"); setMode('mark-spring'); });
                safeAddListener('btn-delete-item', 'click', () => { console.log("Button Clicked: Delete Item"); setMode('delete-item'); });
                safeAddListener('btn-add-membrane', 'click', () => { console.log("Button Clicked: Create Membrane Action"); setMode('add-membrane'); createMembrane(); });
                safeAddListener('btn-mesh-membranes', 'click', () => { console.log("Button Clicked: Mesh Selected"); requestMeshInput(); });
                safeAddListener('btn-confirm-mesh', 'click', () => { console.log("Button Clicked: Confirm Mesh"); handleConfirmMesh(); });
                safeAddListener('btn-add-spring', 'click', () => { console.log("Button Clicked: Create Springs"); requestSpringInput(); });
                safeAddListener('btn-confirm-springs', 'click', () => { console.log("Button Clicked: Confirm Springs"); handleConfirmSprings(); });
                safeAddListener('btn-apply-bc-confirm', 'click', () => { console.log("Button Clicked: Apply BC Confirm"); handleApplyBc(); });
                safeAddListener('bc-type-select', 'change', () => { console.log("Dropdown Changed: BC Type"); handleBcTypeChange(); });
                safeAddListener('btn-apply-material', 'click', () => { console.log("Button Clicked: Apply Material Properties"); handleApplyMaterialProperties(); });
                // --- ADDED listener for apply node coords button ---
                safeAddListener('btn-apply-node-coords', 'click', () => { console.log("Button Clicked: Apply Node Coordinates"); handleApplyNodeCoords(); });
                safeAddListener('btn-solve', 'click', () => { console.log("Button Clicked: Run Analysis"); runAnalysis(); });
                safeAddListener('btn-save-model', 'click', () => { console.log("Button Clicked: Save Model"); handleSaveModel(); });
                safeAddListener('btn-load-text', 'click', () => { console.log("Button Clicked: Load From Text"); handleLoadText(); });

                document.querySelectorAll('input[name="results-view"]').forEach(radio => {
                    safeAddListener(radio.id, 'change', (event) => { console.log(`Radio Changed: ${event.target.id}`); handleResultsViewChange(event); });
                });

                window.addEventListener('resize', resizeCanvas);
                resizeCanvas(); // Initial resize

                // --- Adjust initial view ---
                // Center the view slightly around the origin with a small initial zoom
                const initialScale = 20; // Start slightly zoomed in
                stage.scale({ x: initialScale, y: initialScale });
                stage.position({
                    x: 20, // Center at upper left
                    y: 20
                });
                updateVisualScales(); // Apply scaling to visuals immediately
                stage.batchDraw();
                // --- End initial view adjustment ---

                console.log("Initialization complete.");
                setMode('add-node');
                updateSpringPointsInfo();
                updateMembraneSelectionInfo();
                updateFeSelectionInfo();
                updateResultsDisplay();
                handleResultsViewChange();

            } catch (error) { console.error("Error during Konva initialization or listener binding:", error, error.message, error.stack); updateStatus(`Initialization Error: ${error.message}`); }
        }

        // --- UI & Mode Handling ---
        function resizeCanvas() { const container = document.getElementById('container'); if (!stage || !container) return; const width = container.clientWidth; const height = container.clientHeight; stage.width(width); stage.height(height); const background = backgroundLayer.findOne('Rect'); if (background) { background.width(width); background.height(height); } }
        function setMode(newMode) {
            console.log(`setMode called with: ${newMode}`);
            const meshInputArea = document.getElementById('mesh-input-area');
            const springInputArea = document.getElementById('spring-input-area');
            const bcInputArea = document.getElementById('bc-input-area');
            const materialInputArea = document.getElementById('membrane-material-input-area');
            // --- ADDED Reference to new input area ---
            const springGridInputArea = document.getElementById('spring-grid-input-area');
            // --- ADDED Reference to edit node coords input area ---
            const editCoordsInputArea = document.getElementById('edit-node-coords-input-area');
            const loadArea = document.getElementById('load-model-area');

            // Hide input areas if they are visible
            if (meshInputArea && !meshInputArea.hidden) { meshInputArea.hidden = true; }
            if (springInputArea && !springInputArea.hidden) { springInputArea.hidden = true; }
            if (bcInputArea && !bcInputArea.hidden) { bcInputArea.hidden = true; }
            if (materialInputArea && newMode !== 'select-membrane') { materialInputArea.hidden = true; }
            // --- ADDED Hide spring grid input area ---
            if (springGridInputArea && newMode !== 'add-spring-grid') { springGridInputArea.hidden = true; }
            // --- ADDED Hide edit coords input area ---
            if (editCoordsInputArea && newMode !== 'edit-node-coords') { editCoordsInputArea.hidden = true; }

            // Clear selections based on mode changes
            if (currentMode === 'select-geo-node' && newMode !== 'add-membrane') { clearSelection(false); }
            if (['add-node', 'mark-spring', 'select-membrane', 'select-fe-nodes-box', 'delete-item'].includes(newMode)) { clearSelection(true); } // Clear geo node selection
            if (newMode !== 'select-membrane' && newMode !== 'mesh-membranes') { clearMembraneSelection(); } // This will also hide material area via updateMaterialPropertyDisplay
            if (newMode !== 'select-fe-nodes-box') { clearFeSelection(); } // This will also hide BC area via toggleBcInputArea
            // --- ADDED: Reset rect membrane state when changing modes ---
            if (newMode !== 'add-rect-membrane') {
                rectMembraneFirstCornerNode = null;
            }
            // --- ADDED: Reset spring grid state when changing modes ---
            if (newMode !== 'add-spring-grid') {
                springGridFirstCornerPos = null;
            }
            // --- ADDED: Reset editing node state when changing modes ---
            if (newMode !== 'edit-node-coords') {
                if (editingNodeId !== null) {
                    // Clear visual highlight if any was applied specifically for editing
                    const editedNode = findNodeDataById(editingNodeId);
                    if (editedNode?.konvaCircle) {
                        // Reset to standard non-selected appearance (or selected if it was part of a group selection)
                        const index = selectedNodes.findIndex(n => n.id === editingNodeId);
                        if (index === -1) { // If not part of the general selection
                            editedNode.konvaCircle.stroke('black');
                            editedNode.konvaCircle.strokeWidth(NODE_STROKE_WIDTH_TARGET_PX); // Use target pixel width
                        } else { // If it was selected, keep selected appearance
                            editedNode.konvaCircle.stroke('#007bff');
                            editedNode.konvaCircle.strokeWidth(3); // Selected stroke width (consider scaling this too?)
                        }
                    }
                    editingNodeId = null;
                }
            }
            // --- End Added ---

            const container = document.getElementById('container');
            if (container) {
                container.classList.toggle('crosshair-cursor', newMode === 'select-fe-nodes-box');
                container.classList.toggle('delete-cursor', newMode === 'delete-item');
                // Remove default cursor class if others are active
                if (newMode === 'select-fe-nodes-box' || newMode === 'delete-item') {
                    container.classList.remove('cursor-default');
                } else if (!container.classList.contains('cursor-default')) {
                    container.classList.add('cursor-default');
                }
            }

            currentMode = newMode;
            console.log("Mode changed to:", currentMode);

            // Update button active states visually using Tailwind classes
            const allButtons = document.querySelectorAll('button[id^="btn-"]'); // Select all buttons with IDs starting btn-
            allButtons.forEach(btn => {
                // Skip the buttons inside input areas for this general reset
                if (btn.id === 'btn-confirm-mesh' || btn.id === 'btn-confirm-springs' || btn.id === 'btn-apply-bc-confirm' || btn.id === 'btn-apply-material') {
                    return;
                }
                // Remove all potential active/inactive background/hover states defined directly
                btn.classList.remove(
                    'bg-green-600', 'hover:bg-green-700', 'shadow', // Base active
                    'bg-purple-600', 'hover:bg-purple-700',        // Spring active
                    'bg-teal-600', 'hover:bg-teal-700',            // Membrane active
                    'bg-orange-600', 'hover:bg-orange-700',        // FE Box active
                    '!bg-red-600', '!hover:!bg-red-700',            // Delete active
                    'bg-blue-600', 'hover:bg-blue-700'             // Base inactive
                );
                // Remove potential special colors (Save/Load/Solve) before reapplying base
                btn.classList.remove(
                    '!bg-gray-600', '!hover:!bg-gray-700',         // Save/Load inactive
                    '!bg-red-600', '!hover:!bg-red-700'             // Solve inactive (same as delete active, but needs reset)
                );

                // Reapply base inactive style unless it's Save/Load/Solve
                if (!['btn-save-model', 'btn-load-text', 'btn-solve'].includes(btn.id)) {
                    btn.classList.add('bg-blue-600', 'hover:bg-blue-700');
                } else if (btn.id === 'btn-solve') {
                    btn.classList.add('!bg-red-600', '!hover:!bg-red-700'); // Reapply solve specific color
                } else { // Save/Load
                    btn.classList.add('!bg-gray-600', '!hover:!bg-gray-700'); // Reapply save/load specific color
                }
            });

            const activeButton = document.getElementById(`btn-${newMode.replace(/_/g, '-')}`);
            if (activeButton) {
                // Remove the base inactive style first
                activeButton.classList.remove('bg-blue-600', 'hover:bg-blue-700');
                // Apply specific active style
                if (newMode === 'delete-item') {
                    activeButton.classList.add('!bg-red-600', '!hover:!bg-red-700', 'shadow');
                } else if (newMode === 'mark-spring') {
                    activeButton.classList.add('bg-purple-600', 'hover:bg-purple-700', 'shadow');
                } else if (newMode === 'select-membrane') {
                    activeButton.classList.add('bg-teal-600', 'hover:bg-teal-700', 'shadow');
                    // --- Show material area if membranes are selected ---
                    updateMaterialPropertyDisplay(); // Update display based on current selection
                } else if (newMode === 'select-fe-nodes-box') {
                    activeButton.classList.add('bg-orange-600', 'hover:bg-orange-700', 'shadow');
                } else { // Default active state (e.g., Add Node, Add Rect Membrane)
                    activeButton.classList.add('bg-green-600', 'hover:bg-green-700', 'shadow');
                }
            }

            // --- ADDED: Show spring grid input area if in that mode ---
            if (newMode === 'add-spring-grid' && springGridInputArea) {
                springGridInputArea.hidden = false;
            }
            // --- ADDED: Show edit coords input area IF a node is being edited ---
            if (newMode === 'edit-node-coords' && editCoordsInputArea && editingNodeId !== null) {
                editCoordsInputArea.hidden = false;
            } else if (editCoordsInputArea) {
                editCoordsInputArea.hidden = true; // Ensure hidden if no node selected
            }
            // --- End Added ---

            // Update status message
            switch (currentMode) {
                case 'add-node': updateStatus("Mode: Add Node. Click canvas to add nodes."); break;
                case 'select-geo-node': updateStatus("Mode: Select Geo Node. Click nodes for membrane creation."); break;
                // --- ADDED Status for new mode ---
                case 'add-rect-membrane': updateStatus("Mode: Add Rect Membrane. Click first corner."); break;
                // --- ADJUSTED Status for spring grid mode ---
                case 'add-spring-grid': updateStatus("Mode: Add Spring Grid. Set Nx/Ny above, then click first corner."); break;
                // --- End Adjusted Status ---
                // --- ADDED Status for edit node coords mode ---
                case 'edit-node-coords': updateStatus("Mode: Edit Node Coords. Click a node to edit."); break;
                // --- End Added ---
                case 'select-membrane': updateStatus("Mode: Select Membrane. Click inside membranes to select/deselect/cycle."); break;
                case 'select-fe-nodes-box': updateStatus("Mode: Select FE Nodes. Drag a box to select nodes."); break;
                case 'mark-spring': updateStatus("Mode: Mark Spring Point. Click nodes to mark/unmark."); break;
                case 'delete-item': updateStatus("Mode: Delete Item. Click a Geo Node or Membrane to delete."); break;
                case 'add-membrane':
                    if (selectedNodes.length < 3) {
                        updateStatus("Mode: Add Membrane. Select 3+ nodes in order using 'Select Geo Node' mode, then click button.");
                    } else {
                        updateStatus(`Mode: Add Membrane. ${selectedNodes.length} nodes selected. Click button.`);
                    }
                    break;
                default: updateStatus(`Mode: ${currentMode}`);
            }
        }
        function isPointInsidePolygon(point, polygonVertices) { const x = point.x, y = point.y; let isInside = false; const n = polygonVertices.length; if (n < 3) return false; for (let i = 0, j = n - 1; i < n; j = i++) { const xi = polygonVertices[i].x, yi = polygonVertices[i].y; const xj = polygonVertices[j].x, yj = polygonVertices[j].y; const y_adjusted = y + 1e-9; const intersect = ((yi > y_adjusted) !== (yj > y_adjusted)) && (x < (xj - xi) * (y_adjusted - yi) / (yj - yi) + xi); if (intersect) { isInside = !isInside; } } return isInside; }
        function handleStageClick(e) {
            console.log(`handleStageClick called in mode: ${currentMode}`);
            if (!stage || !geometryLayer || !backgroundLayer) return;
            if (e.target.getParent() === geometryLayer && e.target.getClassName() === 'Circle') { return; } // Ignore clicks on existing nodes
            if (isSelectingBox) return; // Ignore clicks during box selection

            const pos = stage.getPointerPosition();
            if (!pos) return;
            const stagePos = stage.position();
            const scale = stage.scaleX();
            const clickPos = { x: (pos.x - stagePos.x) / scale, y: (pos.y - stagePos.y) / scale };

            // --- Standard Modes ---
            if (currentMode === 'add-node') {
                if (e.target === stage || e.target === backgroundLayer.findOne('Rect')) {
                    addNode(clickPos.x, clickPos.y);
                }
            } else if (currentMode === 'select-membrane' || currentMode === 'delete-item') {
                // Check if click is inside any membrane
                const overlappingMembranes = membranes.filter(m => {
                    if (!m || m.nodeIds.length < 3) return false;
                    const vertices = m.nodeIds.map(id => { const node = findNodeDataById(id); return node ? { x: node.x, y: node.y } : null; }).filter(v => v !== null);
                    if (vertices.length !== m.nodeIds.length) { return false; } // Ensure all nodes found
                    return isPointInsidePolygon(clickPos, vertices);
                });
                console.log(`Found ${overlappingMembranes.length} membranes at click point (manual check).`);

                if (overlappingMembranes.length > 0) {
                    if (currentMode === 'select-membrane') {
                        // Cycle through overlapping membranes or select the first one
                        if (overlappingMembranes.length === 1) {
                            toggleMembraneSelection(overlappingMembranes[0]);
                        } else {
                            // Logic to cycle selection if multiple membranes overlap
                            const overlappingIds = overlappingMembranes.map(m => m.id);
                            const selectedOverlappingId = selectedMembranes.find(id => overlappingIds.includes(id));
                            if (selectedOverlappingId !== undefined) {
                                // Cycle to the next one
                                const currentSelectedMembrane = findMembraneById(selectedOverlappingId);
                                const currentIndex = overlappingMembranes.findIndex(m => m.id === selectedOverlappingId);
                                const nextIndex = (currentIndex + 1) % overlappingMembranes.length;
                                const nextMembraneToSelect = overlappingMembranes[nextIndex];
                                if (currentSelectedMembrane) { toggleMembraneSelection(currentSelectedMembrane); } // Deselect current
                                toggleMembraneSelection(nextMembraneToSelect); // Select next
                                console.log(`Cycled selection from Mem ${selectedOverlappingId} to Mem ${nextMembraneToSelect.id}`);
                            } else {
                                // Select the first one found
                                toggleMembraneSelection(overlappingMembranes[0]);
                                console.log(`Selected first overlapping Mem ${overlappingMembranes[0].id}`);
                            }
                        }
                    } else if (currentMode === 'delete-item') {
                        // Delete the top-most overlapping membrane (or first found)
                        const membraneToDelete = overlappingMembranes[0];
                        console.log("Attempting to delete membrane:", membraneToDelete.id);
                        deleteMembrane(membraneToDelete.id);
                    }
                } else {
                    // Click was on background, clear selections
                    if (e.target === stage || e.target === backgroundLayer.findOne('Rect')) {
                        if (currentMode === 'select-membrane') clearMembraneSelection();
                        if (currentMode === 'select-geo-node' || currentMode === 'mark-spring') clearSelection(false); // Clear visual only
                        if (currentMode === 'select-fe-nodes-box') clearFeSelection();
                    }
                }
            }
            // --- ADDED: Logic for new Rectangular Membrane mode ---
            else if (currentMode === 'add-rect-membrane') {
                if (e.target === stage || e.target === backgroundLayer.findOne('Rect')) {
                    if (rectMembraneFirstCornerNode === null) {
                        // First click: Create first node and store it
                        const node1Data = addNode(clickPos.x, clickPos.y);
                        if (node1Data) {
                            rectMembraneFirstCornerNode = node1Data;
                            updateStatus("Mode: Add Rect Membrane. Click diagonal corner.");
                        } else {
                            updateStatus("Error creating first node. Try again.");
                        }
                    } else {
                        // Second click: Create remaining nodes and the membrane
                        const node2Data = addNode(clickPos.x, clickPos.y); // Diagonal corner
                        if (node2Data) {
                            // Calculate inferred corners
                            const pos3 = { x: rectMembraneFirstCornerNode.x, y: node2Data.y };
                            const pos4 = { x: node2Data.x, y: rectMembraneFirstCornerNode.y };

                            // Create inferred nodes
                            const node3Data = addNode(pos3.x, pos3.y);
                            const node4Data = addNode(pos4.x, pos4.y);

                            if (node3Data && node4Data) {
                                // Create the membrane using the four nodes in correct order
                                // Order: click1, inferred1(same Y as click2), click2, inferred2(same Y as click1)
                                const membraneNodesData = [rectMembraneFirstCornerNode, node3Data, node2Data, node4Data];
                                createMembraneWithNodes(membraneNodesData);
                                updateStatus(`Rectangular Membrane created.`);
                            } else {
                                updateStatus("Error creating inferred nodes. Membrane creation failed.");
                                // Clean up potentially created nodes? Optional.
                                if (node2Data) deleteNode(node2Data.id); // Delete second node if inferrence failed
                                if (node3Data) deleteNode(node3Data.id);
                                if (node4Data) deleteNode(node4Data.id);
                            }
                        } else {
                            updateStatus("Error creating second node. Try again.");
                        }
                        // Reset state regardless of success/failure of second stage
                        rectMembraneFirstCornerNode = null;
                        setMode('add-node'); // Switch back to default mode after attempt
                    }
                }
            }
            // --- ADDED: Logic for Spring Grid mode ---
            else if (currentMode === 'add-spring-grid') {
                if (e.target === stage || e.target === backgroundLayer.findOne('Rect')) {
                    if (springGridFirstCornerPos === null) {
                        // First click: Store position
                        springGridFirstCornerPos = { x: clickPos.x, y: clickPos.y };
                        updateStatus("Mode: Add Spring Grid. Click diagonal corner."); // Update status after first click
                        console.log("Spring Grid: Stored first corner", springGridFirstCornerPos);
                    } else {
                        // Second click: Create the grid
                        const corner1 = springGridFirstCornerPos;
                        const corner2 = clickPos;
                        console.log("Spring Grid: Stored second corner", corner2);

                        const nxInput = document.getElementById('spring-grid-nx-input');
                        const nyInput = document.getElementById('spring-grid-ny-input');
                        const Nx = parseInt(nxInput?.value, 10);
                        const Ny = parseInt(nyInput?.value, 10);

                        // Validate Nx/Ny (No alert, update status instead)
                        if (isNaN(Nx) || isNaN(Ny) || Nx < 2 || Ny < 2) {
                            // --- CHANGED: Update status instead of alert ---
                            updateStatus("Error: Invalid Nx/Ny (>= 2). Set Nx/Ny, then click first corner again.");
                            springGridFirstCornerPos = null; // Reset state, user needs to click first corner again
                            // Keep the mode 'add-spring-grid' and inputs visible
                            return;
                        }

                        console.log(`Creating ${Nx}x${Ny} spring grid...`);
                        let nodesCreated = 0;
                        const dx = (Nx > 1) ? (corner2.x - corner1.x) / (Nx - 1) : 0;
                        const dy = (Ny > 1) ? (corner2.y - corner1.y) / (Ny - 1) : 0;

                        for (let i = 0; i < Nx; i++) {
                            for (let j = 0; j < Ny; j++) {
                                const x = corner1.x + i * dx;
                                const y = corner1.y + j * dy;
                                const newNodeData = addNode(x, y);
                                if (newNodeData) {
                                    toggleSpringPointMarking(newNodeData); // Mark as spring point immediately
                                    nodesCreated++;
                                }
                            }
                        }

                        updateStatus(`Created ${nodesCreated} spring grid points (${Nx}x${Ny}).`);
                        console.log(`Finished creating spring grid.`);

                        // Reset state and switch back to default mode
                        springGridFirstCornerPos = null;
                        setMode('add-node');
                    }
                }
            }
            // --- End Modified Spring Grid Logic ---
            else {
                // Other modes or background click
                if (e.target === stage || e.target === backgroundLayer.findOne('Rect')) {
                    if (currentMode === 'select-geo-node' || currentMode === 'mark-spring') clearSelection(false); // Clear visual only
                    if (currentMode === 'select-fe-nodes-box') clearFeSelection();
                }
            }
        }
        function handleNodeClick(nodeData) {
            console.log(`handleNodeClick called for node ${nodeData?.id} in mode: ${currentMode}`);
            if (!nodeData || !nodeData.konvaCircle) { console.error("Invalid nodeData received in handleNodeClick"); return; }

            // --- ADDED: Logic for Edit Node Coords mode ---
            if (currentMode === 'edit-node-coords') {
                // Clear previous selection highlight if any
                if (editingNodeId !== null && editingNodeId !== nodeData.id) {
                    const previouslyEditedNode = findNodeDataById(editingNodeId);
                    if (previouslyEditedNode?.konvaCircle) {
                        previouslyEditedNode.konvaCircle.stroke('black');
                        previouslyEditedNode.konvaCircle.strokeWidth(NODE_STROKE_WIDTH_TARGET_PX);
                    }
                }

                // Set new editing node
                editingNodeId = nodeData.id;
                console.log(`Selected node ${editingNodeId} for coordinate editing.`);

                // Populate input area
                document.getElementById('edit-node-id-display').textContent = editingNodeId;
                document.getElementById('edit-node-x-input').value = nodeData.x.toFixed(3); // Show current coords
                document.getElementById('edit-node-y-input').value = nodeData.y.toFixed(3);

                // Show input area
                const inputArea = document.getElementById('edit-node-coords-input-area');
                if (inputArea) inputArea.hidden = false;

                // Highlight the selected node (optional, subtle)
                // nodeData.konvaCircle.stroke('darkorange');
                // nodeData.konvaCircle.strokeWidth(2); // Or use a different visual cue

                geometryLayer?.batchDraw();
                updateStatus(`Editing coordinates for Node ${editingNodeId}. Enter new X/Y and click Apply.`);
            }
            // --- End Edit Node Coords Logic ---
            else if (currentMode === 'select-geo-node') {
                toggleNodeSelection(nodeData);
            }
            else if (currentMode === 'mark-spring') {
                toggleSpringPointMarking(nodeData);
            }
            else if (currentMode === 'delete-item') {
                deleteNode(nodeData.id);
            }
        }
        function handleStageMouseDown(e) {
            if (currentMode !== 'select-fe-nodes-box' || !stage) return; stage.stopDrag(); e.evt.preventDefault(); isSelectingBox = true; let pos = stage.getPointerPosition(); if (!pos) { isSelectingBox = false; return; } const stagePos = stage.position(); const scale = stage.scaleX(); selectionBoxStart = { x: (pos.x - stagePos.x) / scale, y: (pos.y - stagePos.y) / scale }; clearFeSelection(); selectionRect = new Konva.Rect({
                x: selectionBoxStart.x, y: selectionBoxStart.y, width: 0, height: 0, fill: SELECTION_BOX_COLOR,
                stroke: 'blue',
                strokeWidth: 1, // Use constant pixel width
                strokeScaleEnabled: false, // Disable scaling with zoom
                visible: true,
            }); selectionLayer.add(selectionRect); selectionLayer.batchDraw();
        }
        function handleStageMouseMove(e) { if (!isSelectingBox || !selectionRect || !stage) return; let currentPos = stage.getPointerPosition(); if (!currentPos) return; const stagePos = stage.position(); const scale = stage.scaleX(); const adjustedPos = { x: (currentPos.x - stagePos.x) / scale, y: (currentPos.y - stagePos.y) / scale }; const width = adjustedPos.x - selectionBoxStart.x; const height = adjustedPos.y - selectionBoxStart.y; selectionRect.setAttrs({ x: width > 0 ? selectionBoxStart.x : adjustedPos.x, y: height > 0 ? selectionBoxStart.y : adjustedPos.y, width: Math.abs(width), height: Math.abs(height), }); selectionLayer.batchDraw(); }
        function handleStageMouseUp(e) { if (!isSelectingBox || !selectionRect || !stage) { return; } isSelectingBox = false; const finalAttrs = selectionRect.getAttrs(); const box = { x: finalAttrs.x, y: finalAttrs.y, width: finalAttrs.width, height: finalAttrs.height }; console.log("Selection box finished:", box); selectedFeNodes = feNodes.filter(feN => feN.x >= box.x && feN.x <= box.x + box.width && feN.y >= box.y && feN.y <= box.y + box.height).map(feN => feN.id); console.log(`Selected ${selectedFeNodes.length} FE nodes.`); selectionRect.destroy(); selectionLayer.batchDraw(); selectionRect = null; updateFeSelectionInfo(); drawMesh(); toggleBcInputArea(); }
        function handleWheelZoom(e) {
            e.evt.preventDefault();
            if (!stage) return;

            const scaleBy = 1.05;
            const oldScale = stage.scaleX();
            const pointer = stage.getPointerPosition();
            if (!pointer) return;

            const mousePointTo = {
                x: (pointer.x - stage.x()) / oldScale,
                y: (pointer.y - stage.y()) / oldScale,
            };

            let direction = e.evt.deltaY < 0 ? 1 : -1;
            let newScale;
            if (direction > 0) {
                newScale = oldScale * scaleBy;
            } else {
                newScale = oldScale / scaleBy;
            }
            // --- Changed min/max zoom levels ---
            newScale = Math.max(1, Math.min(newScale, 200)); // Clamp scale: Min 1x, Max 200x

            const newPos = {
                x: pointer.x - mousePointTo.x * newScale,
                y: pointer.y - mousePointTo.y * newScale,
            };

            stage.scale({ x: newScale, y: newScale });
            stage.position(newPos);

            // --- ADDED: Update visuals for new scale ---
            updateVisualScales();
            // --- End Added ---

            stage.batchDraw();
        }

        // --- Function to update scale-dependent visuals ---
        function updateVisualScales() {
            if (!stage) return;
            const scale = stage.scaleX(); // Get the NEW scale after zoom

            // Update geometric nodes (Radius only)
            nodes.forEach(node => {
                if (node.konvaCircle) {
                    node.konvaCircle.radius(NODE_RADIUS_TARGET_PX / scale);
                }
            });

            // Update FE nodes / BCs (by redrawing mesh layer which uses scale)
            drawMesh();

            // --- Update Spring Labels for Fixed Screen Size ---
            if (springLayer) {
                const springLabels = springLayer.find('Text'); // Find all labels

                springLabels.forEach(textNode => {
                    const node1Id = textNode.getAttr('node1Id'); // Get associated node
                    const node1 = findFeNodeById(node1Id);

                    if (node1) {
                        // Calculate NEW world offset based on FIXED screen offset and NEW scale
                        const worldOffsetX = SPRING_LABEL_SCREEN_OFFSET_X / scale;
                        const worldOffsetY = SPRING_LABEL_SCREEN_OFFSET_Y / scale;

                        // Update counter-scaling to match the new stage scale
                        textNode.scaleX(1 / scale);
                        textNode.scaleY(1 / scale);

                        // Update world position based on node1's current pos and NEW world offset
                        textNode.position({
                            x: node1.x + worldOffsetX,
                            y: node1.y - worldOffsetY // Still subtract Y offset for 'up'
                        });

                        // NOTE: textNode.fontSize() is NOT changed here - it remains fixed
                    }
                });
            } // End if (springLayer)

            // Batch draw layers that had visual updates
            geometryLayer?.batchDraw(); // Nodes updated
            // meshLayer is redrawn by drawMesh()
            springLayer?.batchDraw();   // Labels updated
        }
        // --- End Added Function ---

        function addNode(x, y, loadedId = null) {
            const useLoadedId = loadedId !== null;
            const nodeId = useLoadedId ? loadedId : nextNodeId++;
            if (typeof Konva === 'undefined' || !Konva.Circle) { console.error("Konva.Circle not available."); updateStatus("Error: Konva library component missing."); return null; }

            // --- Calculate initial radius based on current scale ---
            const currentScale = stage ? stage.scaleX() : 1.0; // Get current scale or default to 1
            const initialRadius = NODE_RADIUS_TARGET_PX / currentScale;
            const initialStrokeWidth = NODE_STROKE_WIDTH_TARGET_PX; // Use target pixel width

            const konvaCircle = new Konva.Circle({
                x: x,
                y: y,
                radius: initialRadius, // Use scaled radius
                fill: DEFAULT_NODE_COLOR,
                stroke: 'black',
                strokeWidth: initialStrokeWidth,
                strokeScaleEnabled: false, // Keep stroke width constant in pixels
                draggable: true,
                id: `node-${nodeId}`
            });
            const nodeData = { id: nodeId, konvaCircle: konvaCircle, x: x, y: y }; if (!findNodeDataById(nodeId)) { nodes.push(nodeData); } else if (!useLoadedId) { console.warn(`Node ID ${nodeId} conflict!`); } /* ID counter updated in handleLoadText */ konvaCircle.on('click tap', (e) => { e.cancelBubble = true; handleNodeClick(nodeData); }); konvaCircle.on('dragend', () => { nodeData.x = konvaCircle.x(); nodeData.y = konvaCircle.y(); const movedNodeId = nodeData.id; console.log(`Node ${movedNodeId} moved to (${nodeData.x.toFixed(1)}, ${nodeData.y.toFixed(1)})`); updateConnectedMembranes(movedNodeId); updateSelectionInfo(); konvaCircle.moveToTop(); clearMeshForAffectedMembranes(movedNodeId); drawMesh(); drawSprings(); }); geometryLayer.add(konvaCircle); return nodeData;
        }
        function findNodeDataById(id) { return nodes.find(n => n.id === id); }
        function findFeNodeById(id) { return feNodes.find(n => n.id === id); }
        function findFeElementById(id) { return feElements.find(el => el.id === id); }
        function findMembraneById(id) { return membranes.find(m => m.id === id); }
        function updateConnectedMembranes(nodeId) { membranes.forEach(mem => { if (mem.nodeIds.includes(nodeId)) { const points = []; let geometryIsValid = true; mem.nodeIds.forEach(nId => { const nodeData = findNodeDataById(nId); if (nodeData && nodeData.konvaCircle) { points.push(nodeData.konvaCircle.x(), nodeData.konvaCircle.y()); } else { geometryIsValid = false; } }); if (geometryIsValid && mem.konvaShape && points.length === mem.nodeIds.length * 2) { mem.konvaShape.points(points); } else { console.warn(`Membrane ${mem.id} fill shape could not be updated.`); } } }); if (membraneFillLayer) membraneFillLayer.batchDraw(); }
        function toggleNodeSelection(nodeData) { if (!nodeData || !nodeData.konvaCircle) { console.error("Invalid node data passed to toggleNodeSelection:", nodeData); return; } const index = selectedNodes.findIndex(n => n.id === nodeData.id); if (index > -1) { selectedNodes.splice(index, 1); nodeData.konvaCircle.stroke('black'); nodeData.konvaCircle.strokeWidth(1); console.log(`Node ${nodeData.id} deselected.`); } else { selectedNodes.push(nodeData); nodeData.konvaCircle.stroke('#007bff'); nodeData.konvaCircle.strokeWidth(3); console.log(`Node ${nodeData.id} selected.`); } if (geometryLayer) geometryLayer.batchDraw(); updateSelectionInfo(); }
        function clearSelection(clearData = true) { selectedNodes.forEach(nodeData => { if (nodeData && nodeData.konvaCircle) { nodeData.konvaCircle.stroke('black'); nodeData.konvaCircle.strokeWidth(1); } }); if (clearData) { selectedNodes = []; console.log("Selection data cleared."); } if (geometryLayer) geometryLayer.batchDraw(); updateSelectionInfo(); console.log("Selection visual cleared."); }
        function toggleSpringPointMarking(nodeData) { if (!nodeData || !nodeData.konvaCircle) return; const index = geometricSpringNodes.indexOf(nodeData.id); if (index > -1) { geometricSpringNodes.splice(index, 1); nodeData.konvaCircle.fill(DEFAULT_NODE_COLOR); updateStatus(`Unmarked node ${nodeData.id} as spring point.`); console.log(`Unmarked node ${nodeData.id} for springs.`); } else { geometricSpringNodes.push(nodeData.id); nodeData.konvaCircle.fill(SPRING_NODE_COLOR); updateStatus(`Marked node ${nodeData.id} as spring point.`); console.log(`Marked node ${nodeData.id} for springs.`); } if (geometryLayer) geometryLayer.batchDraw(); updateSpringPointsInfo(); }
        function toggleMembraneSelection(membraneData) {
            if (!membraneData || !membraneData.konvaShape) return;
            const index = selectedMembranes.indexOf(membraneData.id);
            if (index > -1) {
                selectedMembranes.splice(index, 1);
                membraneData.konvaShape.opacity(MEMBRANE_DEFAULT_OPACITY);
                membraneData.konvaShape.stroke(MEMBRANE_DEFAULT_STROKE);
                membraneData.konvaShape.strokeWidth(MEMBRANE_DEFAULT_STROKE_WIDTH);
                console.log(`Membrane ${membraneData.id} deselected.`);
            } else {
                selectedMembranes.push(membraneData.id);
                membraneData.konvaShape.opacity(MEMBRANE_SELECTED_OPACITY);
                membraneData.konvaShape.stroke(MEMBRANE_SELECTED_STROKE);
                membraneData.konvaShape.strokeWidth(MEMBRANE_SELECTED_STROKE_WIDTH);
                console.log(`Membrane ${membraneData.id} selected.`);
            }
            membraneFillLayer.batchDraw();
            updateMembraneSelectionInfo();
            // --- Update material display on selection change ---
            updateMaterialPropertyDisplay();
        }
        function clearMembraneSelection() {
            selectedMembranes.forEach(memId => {
                const membrane = findMembraneById(memId);
                if (membrane && membrane.konvaShape) {
                    membrane.konvaShape.opacity(MEMBRANE_DEFAULT_OPACITY);
                    membrane.konvaShape.stroke(MEMBRANE_DEFAULT_STROKE);
                    membrane.konvaShape.strokeWidth(MEMBRANE_DEFAULT_STROKE_WIDTH);
                }
            });
            selectedMembranes = [];
            if (membraneFillLayer) membraneFillLayer.batchDraw();
            updateMembraneSelectionInfo();
            // --- Update material display when selection is cleared ---
            updateMaterialPropertyDisplay();
            console.log("Membrane selection cleared.");
        }
        function clearFeSelection() { if (selectedFeNodes.length > 0) { selectedFeNodes = []; console.log("FE Node selection cleared."); updateFeSelectionInfo(); drawMesh(); toggleBcInputArea(); } }
        function updateStatus(message) { const statusElement = document.getElementById('status-message'); if (statusElement) { statusElement.textContent = message; } else { console.warn("Status message element not found."); } }
        function updateSelectionInfo() { const infoDiv = document.getElementById('selection-info'); if (!infoDiv) return; if (selectedNodes.length === 0) { infoDiv.textContent = 'None.'; } else { infoDiv.innerHTML = `Node IDs (${selectedNodes.length}):<br>`; selectedNodes.forEach((node, index) => { if (node && typeof node.id !== 'undefined') { infoDiv.innerHTML += `${index + 1}. ${node.id} <br>`; } else { infoDiv.innerHTML += `${index + 1}. ? <br>`; console.error("Error displaying node data:", node); } }); } }
        function updateSpringPointsInfo() { const infoDiv = document.getElementById('spring-points-info'); if (!infoDiv) return; if (geometricSpringNodes.length === 0) { infoDiv.textContent = 'None.'; } else { infoDiv.innerHTML = `Node IDs: ${geometricSpringNodes.join(', ')}`; } }
        function updateMembraneSelectionInfo() { const infoDiv = document.getElementById('membrane-selection-info'); if (!infoDiv) return; if (selectedMembranes.length === 0) { infoDiv.textContent = 'None.'; } else { infoDiv.innerHTML = `Membrane IDs: ${selectedMembranes.join(', ')}`; } }
        function updateFeSelectionInfo() { const infoDiv = document.getElementById('fe-selection-info'); if (!infoDiv) return; if (selectedFeNodes.length === 0) { infoDiv.textContent = 'None.'; } else { infoDiv.innerHTML = `Count: ${selectedFeNodes.length}<br>IDs: ${selectedFeNodes.slice(0, 10).join(', ')} ${selectedFeNodes.length > 10 ? '...' : ''}`; } }
        function toggleBcInputArea() { const bcArea = document.getElementById('bc-input-area'); if (!bcArea) return; const hasSelection = selectedFeNodes.length > 0; bcArea.hidden = !hasSelection; if (hasSelection) { document.getElementById('bc-type-select').value = 'none'; handleBcTypeChange(); } }
        function handleBcTypeChange() { const selectedType = document.getElementById('bc-type-select')?.value; document.getElementById('bc-fixed-options')?.setAttribute('hidden', ''); document.getElementById('bc-enforced-options')?.setAttribute('hidden', ''); document.getElementById('bc-load-options')?.setAttribute('hidden', ''); if (selectedType === 'fixed') { document.getElementById('bc-fixed-options')?.removeAttribute('hidden'); } else if (selectedType === 'enforced') { document.getElementById('bc-enforced-options')?.removeAttribute('hidden'); } else if (selectedType === 'load') { document.getElementById('bc-load-options')?.removeAttribute('hidden'); } }
        function createMembrane() {
            if (currentMode !== 'add-membrane') { updateStatus("Switch to 'Add Membrane' mode first."); return; } if (selectedNodes.length < 3) { updateStatus(`Select at least 3 nodes first using 'Select Geo Node' mode.`); return; } console.log(`Attempting to create ${selectedNodes.length}-sided membrane from selection`);
            // --- Call the refactored function ---
            const success = createMembraneWithNodes(selectedNodes);
            if (success) {
                clearSelection(true); // Clear selection only if membrane creation was successful
            }
        }

        // --- REFACTORED: createMembrane to accept node data array ---
        function createMembraneWithNodes(nodesDataArray) {
            if (!nodesDataArray || nodesDataArray.length < 3) {
                console.error("Invalid node data array passed to createMembraneWithNodes:", nodesDataArray);
                updateStatus("Error: Invalid nodes for membrane creation.");
                return false; // Indicate failure
            }
            console.log(`Attempting to create ${nodesDataArray.length}-sided membrane with nodes: ${nodesDataArray.map(n => n.id).join(',')}`);

            let nodesAreValid = true;
            const nodeIds = [];
            const points = [];
            const uniqueNodeIds = new Set();

            for (const nodeData of nodesDataArray) {
                if (!nodeData || !nodeData.id || typeof nodeData.x !== 'number' || typeof nodeData.y !== 'number') {
                    console.error("Invalid node data found in array:", nodeData);
                    nodesAreValid = false;
                    break;
                }
                if (uniqueNodeIds.has(nodeData.id)) {
                    console.error("Duplicate node ID found in array:", nodeData.id);
                    updateStatus("Error: Duplicate nodes provided for membrane.");
                    nodesAreValid = false;
                    break;
                }
                uniqueNodeIds.add(nodeData.id);
                nodeIds.push(nodeData.id);
                points.push(nodeData.x, nodeData.y);
            }

            if (!nodesAreValid) {
                console.error("Membrane creation failed due to invalid node data.");
                updateStatus("Error: Invalid node data for membrane.");
                return false; // Indicate failure
            }

            if (typeof Konva === 'undefined' || !Konva.Line) {
                console.error("Konva.Line is not available.");
                alert("Error: Konva.Line constructor not found!");
                return false; // Indicate failure
            }

            let membraneFillShape;
            try {
                membraneFillShape = new Konva.Line({
                    points: points,
                    fill: 'rgba(173, 216, 230, 0.5)',
                    stroke: MEMBRANE_DEFAULT_STROKE,
                    strokeWidth: MEMBRANE_DEFAULT_STROKE_WIDTH, // Use base pixel width
                    strokeScaleEnabled: false, // <--- ADD THIS LINE
                    closed: true,
                    listening: false,
                    draggable: false,
                    opacity: MEMBRANE_DEFAULT_OPACITY,
                    name: 'membrane'
                });
            } catch (error) {
                console.error("Error creating Konva.Line for membrane fill:", error);
                return false; // Indicate failure
            }

            const membraneId = nextMembraneId++;
            const newMembrane = {
                id: membraneId,
                nodeIds: nodeIds,
                konvaShape: membraneFillShape,
                isMeshed: false,
                // Initialize with default material properties
                materialE: DEFAULT_MATERIAL_E,
                materialNu: DEFAULT_MATERIAL_NU,
                materialT: DEFAULT_MATERIAL_T
            };
            membranes.push(newMembrane);

            if (membraneFillLayer) {
                membraneFillLayer.add(membraneFillShape);
                membraneFillLayer.batchDraw();
            } else {
                console.error("Membrane fill layer not available.");
                membranes.pop(); // Rollback if layer is missing
                return false; // Indicate failure
            }

            console.log(`Membrane ${membraneId} created (${nodeIds.length} nodes: ${nodeIds.join(', ')})`);
            updateStatus(`Membrane ${membraneId} created.`);
            return true; // Indicate success
        }
        // --- End Refactored Function ---

        function requestMeshInput() { console.log("Mesh button clicked. Requesting input."); const meshInputArea = document.getElementById('mesh-input-area'); const meshSeparator = document.getElementById('mesh-input-separator'); if (selectedMembranes.length === 0) { alert("Please select one or more membranes first using 'Select Membrane' mode."); updateStatus("Select membranes before meshing."); return; } if (meshInputArea) { meshInputArea.hidden = false; if (meshSeparator) meshSeparator.hidden = false; updateStatus("Enter M(X-dir) x N(Y-dir) divisions and click Confirm."); } else { console.error("Mesh input area not found!"); updateStatus("Error: UI component missing."); } }
        function handleConfirmMesh() { console.log("Confirm Mesh button clicked."); const mInput = document.getElementById('mesh-m-input'); const nInput = document.getElementById('mesh-n-input'); const meshInputArea = document.getElementById('mesh-input-area'); const meshSeparator = document.getElementById('mesh-input-separator'); if (!mInput || !nInput || !meshInputArea) { console.error("Mesh input fields or area not found!"); alert("Error: Cannot find mesh input UI elements."); return; } const M = parseInt(mInput.value, 10); const N = parseInt(nInput.value, 10); console.log("Read M:", M, "Read N:", N); if (isNaN(M) || isNaN(N) || M <= 0 || N <= 0) { alert("Invalid divisions. Both M and N must be positive integers."); updateStatus("Invalid mesh divisions entered."); return; } meshInputArea.hidden = true; if (meshSeparator) meshSeparator.hidden = true; performMeshing(M, N); }
        function performMeshing(M, N) { if (selectedMembranes.length === 0) { console.log("No membranes selected for meshing."); updateStatus("No membranes selected to mesh."); return; } console.log(`Attempting to mesh ${selectedMembranes.length} selected membranes with ${M}x${N} divisions.`); updateStatus(`Meshing selected membranes (${M}x${N})...`); let meshedCount = 0; let skippedCount = 0; let nonQuadCount = 0; selectedMembranes.forEach(membraneId => { const membrane = findMembraneById(membraneId); if (!membrane) { console.warn(`Selected membrane ID ${membraneId} not found.`); skippedCount++; return; } if (membrane.nodeIds.length !== 4) { console.log(`Skipping membrane ${membrane.id}: Not 4-sided.`); nonQuadCount++; return; } if (membrane.isMeshed) { console.log(`Skipping membrane ${membrane.id}: Already meshed.`); skippedCount++; return; } generateStructuredMesh(membrane, M, N); meshedCount++; }); drawMesh(); let meshStatus = `Meshing complete. Meshed: ${meshedCount}.`; if (nonQuadCount > 0) meshStatus += ` Skipped ${nonQuadCount} (not 4-sided).`; if (skippedCount > 0) meshStatus += ` Skipped ${skippedCount} (already meshed/not found).`; updateStatus(meshStatus); console.log(meshStatus); }
        function clearMeshForAffectedMembranes(movedNodeId) { console.log(`Checking for meshes affected by moved node ${movedNodeId}`); const affectedMembranes = membranes.filter(m => m.nodeIds.includes(movedNodeId) && m.isMeshed); if (affectedMembranes.length === 0) { console.log("No currently meshed membranes affected."); return; } console.log(`Found ${affectedMembranes.length} affected meshed membranes:`, affectedMembranes.map(m => m.id)); const feNodesToRemove = new Set(); const feElementsToRemove = new Set(); const feSpringsToRemove = new Set(); affectedMembranes.forEach(membrane => { feNodes.forEach(feN => { if (feN.membraneId === membrane.id) { feNodesToRemove.add(feN.id); } }); feElements.forEach(feE => { if (feE.membraneId === membrane.id) { feElementsToRemove.add(feE.id); } }); membrane.isMeshed = false; console.log(`Marked membrane ${membrane.id} as not meshed.`); }); if (feNodesToRemove.size > 0) { feSprings.forEach(feS => { if (feNodesToRemove.has(feS.feNodeId1) || feNodesToRemove.has(feS.feNodeId2)) { feSpringsToRemove.add(feS.id); } }); } const originalNodeCount = feNodes.length; const originalElementCount = feElements.length; const originalSpringCount = feSprings.length; feNodes = feNodes.filter(feN => !feNodesToRemove.has(feN.id)); feElements = feElements.filter(feE => !feElementsToRemove.has(feE.id)); feSprings = feSprings.filter(feS => !feSpringsToRemove.has(feS.id)); console.log(`Removed ${originalNodeCount - feNodes.length} FE nodes.`); console.log(`Removed ${originalElementCount - feElements.length} FE elements.`); console.log(`Removed ${originalSpringCount - feSprings.length} FE springs.`); }
        function clearMeshData() { feNodes = []; feElements = []; feSprings = []; membranes.forEach(m => m.isMeshed = false); if (meshLayer) { meshLayer.destroyChildren(); meshLayer.batchDraw(); } if (springLayer) { springLayer.destroyChildren(); springLayer.batchDraw(); } if (stressLayer) { stressLayer.destroyChildren(); stressLayer.batchDraw(); } clearFeSelection(); console.log("Cleared ALL existing FE mesh, spring, and stress data."); }
        function generateStructuredMesh(membrane, M, N) {
            console.log(`Generating mesh for membrane ${membrane.id}`);
            const cornerNodeIds = membrane.nodeIds;
            let cornerNodes = cornerNodeIds.map(id => findNodeDataById(id));

            if (cornerNodes.some(node => !node)) {
                console.error(`Membrane ${membrane.id} has missing geometric node data.`);
                updateStatus(`Error: Mesh failed for Mem ${membrane.id} (Missing node data).`);
                return; // Stop meshing this membrane
            }

            // --- ADDED: Ensure cornerNodes are sorted Counter-Clockwise (CCW) ---
            if (cornerNodes.length === 4) {
                // 1. Calculate centroid
                let cx = 0, cy = 0;
                cornerNodes.forEach(n => { cx += n.x; cy += n.y; });
                cx /= 4;
                cy /= 4;

                // 2. Calculate angle for each node relative to centroid
                cornerNodes.forEach(n => {
                    n.angle = Math.atan2(n.y - cy, n.x - cx);
                });

                // 3. Sort nodes by angle
                cornerNodes.sort((a, b) => a.angle - b.angle);
                console.log(`Membrane ${membrane.id}: Reordered corner nodes to CCW order: ${cornerNodes.map(n => n.id).join(', ')}`);
            } else {
                console.warn(`Membrane ${membrane.id} is not a quadrilateral. Mesh generation assumes quadrilateral.`);
                // Proceeding anyway, but Jacobians might still be problematic if not quad.
            }
            // --- End Added Section ---

            // Use the (potentially reordered) cornerNodes for mapping
            const [p1, p2, p3, p4] = cornerNodes;

            // The rest of the function remains the same...
            const gridFeNodeIds = Array(M + 1).fill(null).map(() => Array(N + 1).fill(null));
            // ... loop to create feNodes ...
            for (let i = 0; i <= M; i++) {
                for (let j = 0; j <= N; j++) {
                    const u = i / M;
                    const v = j / N;
                    // Ensure mapping uses the potentially reordered p1, p2, p3, p4
                    const x = (1 - u) * (1 - v) * p1.x + u * (1 - v) * p2.x + u * v * p3.x + (1 - u) * v * p4.x;
                    const y = (1 - u) * (1 - v) * p1.y + u * (1 - v) * p2.y + u * v * p3.y + (1 - u) * v * p4.y;
                    const feNodeId = feNodeIdCounter++;
                    // ... rest of node creation ...
                    feNodes.push({ id: feNodeId, x: x, y: y, isBoundary: (i === 0 || i === M || j === 0 || j === N), isSpringConnectionPoint: false, originatingGeometricNodeId: null, membraneId: membrane.id, bc: null }); // Simplified for brevity
                    gridFeNodeIds[i][j] = feNodeId;
                }
            }
            // Assign spring point status and originating IDs after node creation loop
            feNodes.filter(n => n.membraneId === membrane.id).forEach(feN => {
                let originatingGeoId = null;
                // Use a small tolerance for floating point comparison
                const TOL = 1e-6;
                if (Math.abs(feN.x - p1.x) < TOL && Math.abs(feN.y - p1.y) < TOL) originatingGeoId = p1.id;
                else if (Math.abs(feN.x - p2.x) < TOL && Math.abs(feN.y - p2.y) < TOL) originatingGeoId = p2.id;
                else if (Math.abs(feN.x - p3.x) < TOL && Math.abs(feN.y - p3.y) < TOL) originatingGeoId = p3.id;
                else if (Math.abs(feN.x - p4.x) < TOL && Math.abs(feN.y - p4.y) < TOL) originatingGeoId = p4.id;

                if (originatingGeoId !== null) {
                    feN.originatingGeometricNodeId = originatingGeoId;
                    if (geometricSpringNodes.includes(originatingGeoId)) {
                        feN.isSpringConnectionPoint = true;
                    }
                }
            });

            // --- REINSERTED: Element Creation Loop ---
            console.log(`Membrane ${membrane.id}: Creating ${M}x${N} elements...`);
            let elementsCreatedCount = 0;
            for (let i = 0; i < M; i++) {
                for (let j = 0; j < N; j++) {
                    const node_bl = gridFeNodeIds[i]?.[j];
                    const node_br = gridFeNodeIds[i + 1]?.[j];
                    const node_tr = gridFeNodeIds[i + 1]?.[j + 1];
                    const node_tl = gridFeNodeIds[i]?.[j + 1];

                    // Basic check for valid node IDs before creating element
                    if (node_bl === null || node_br === null || node_tr === null || node_tl === null ||
                        node_bl === undefined || node_br === undefined || node_tr === undefined || node_tl === undefined) {
                        console.error(`Error creating element (${i},${j}) for membrane ${membrane.id}: Missing node ID.`);
                        continue; // Skip this element if node IDs are invalid
                    }

                    feElements.push({
                        id: feElementIdCounter++,
                        type: 'quad',
                        nodeIds: [node_bl, node_br, node_tr, node_tl], // CCW order
                        membraneId: membrane.id
                    });
                    elementsCreatedCount++;
                }
            }
            console.log(`Membrane ${membrane.id}: Successfully created ${elementsCreatedCount} elements.`);
            // --- End Reinserted Loop ---

            membrane.isMeshed = true;
        }
        function drawMesh() {
            if (!meshLayer || !stage) return;
            const scale = stage.scaleX(); // Get current scale
            meshLayer.destroyChildren();
            const selectedFeSet = new Set(selectedFeNodes);

            feElements.forEach(element => {
                if (element.type === 'quad' && element.nodeIds.length === 4) {
                    const elementNodes = element.nodeIds.map(nodeId => findFeNodeById(nodeId));
                    if (elementNodes.every(n => n)) {
                        const points = elementNodes.flatMap(n => [n.x, n.y]);
                        const meshLine = new Konva.Line({
                            points: points,
                            stroke: MESH_LINE_COLOR,
                            strokeWidth: LINE_STROKE_WIDTH_TARGET_PX, // Target pixel width
                            strokeScaleEnabled: false, // Keep constant pixel width
                            closed: true,
                            listening: false
                        });
                        meshLayer.add(meshLine);
                    } else { console.warn(`Skipping drawing element ${element.id}, missing node data.`); }
                }
            });

            feNodes.forEach(node => {
                const isSelected = selectedFeSet.has(node.id);
                // --- Calculate scaled radius ---
                const radiusPx = isSelected ? FE_NODE_SELECTED_RADIUS_TARGET_PX : FE_NODE_RADIUS_TARGET_PX;
                const radius = radiusPx / scale;

                const nodeCircle = new Konva.Circle({
                    x: node.x,
                    y: node.y,
                    radius: radius, // Use scaled radius
                    fill: isSelected ? FE_NODE_SELECTED_COLOR : (node.isSpringConnectionPoint ? SPRING_NODE_COLOR : FE_NODE_COLOR),
                    listening: false
                });
                meshLayer.add(nodeCircle);
                if (node.bc) {
                    drawBcSymbol(node.x, node.y, node.bc); // Pass scale to BC drawing
                }
            });
            meshLayer.batchDraw();
            console.log(`Drew mesh with ${feNodes.length} nodes and ${feElements.length} elements.`);
        }
        function drawBcSymbol(x, y, bcData) {
            if (!meshLayer || !stage) return;
            const scale = stage.scaleX();

            // --- Scale symbol size and offset ---
            const symbolSize = BC_SYMBOL_SIZE_TARGET_PX / scale;
            const nodeRadius = (FE_NODE_RADIUS_TARGET_PX / scale); // Use FE node base radius for offset calc
            const symbolOffset = nodeRadius + (BC_SYMBOL_OFFSET_TARGET_PX / scale);
            const strokeWidth = LINE_STROKE_WIDTH_TARGET_PX; // Target pixel width

            /* Adjusted offset */
            if (bcData.type === 'fixed') {
                if (bcData.value.fixX) {
                    const fixedX = new Konva.RegularPolygon({
                        x: x - symbolOffset, y: y, sides: 3, radius: symbolSize / 2, rotation: 90, fill: 'black',
                        stroke: 'black', strokeWidth: strokeWidth, strokeScaleEnabled: false, // Constant pixel stroke
                        listening: false,
                    });
                    meshLayer.add(fixedX);
                }
                if (bcData.value.fixY) {
                    const fixedY = new Konva.RegularPolygon({
                        x: x, y: y + symbolOffset, sides: 3, radius: symbolSize / 2, rotation: 0, fill: 'black',
                        stroke: 'black', strokeWidth: strokeWidth, strokeScaleEnabled: false, // Constant pixel stroke
                        listening: false,
                    });
                    meshLayer.add(fixedY);
                }
            } else if (bcData.type === 'enforced' || bcData.type === 'load') {
                const isLoad = bcData.type === 'load';
                const val = bcData.value;
                const color = isLoad ? 'red' : 'green';
                const valueX = isLoad ? val.fx : val.dx;
                const valueY = isLoad ? val.fy : val.dy;

                const pointerLength = 4 / scale; // Scale pointer size too
                const pointerWidth = 4 / scale;

                if (valueX !== null && valueX !== 0) {
                    const signX = Math.sign(valueX);
                    // Adjust arrow points based on scaled offset and size
                    const arrowX = new Konva.Arrow({
                        points: [x + signX * symbolOffset / 1.5, y, x + signX * (symbolOffset + symbolSize), y], // Adjusted start point slightly
                        pointerLength: pointerLength, pointerWidth: pointerWidth,
                        fill: color, stroke: color, strokeWidth: strokeWidth, strokeScaleEnabled: false, // Constant pixel stroke
                        listening: false
                    });
                    meshLayer.add(arrowX);
                }
                if (valueY !== null && valueY !== 0) {
                    const signY = Math.sign(valueY);
                    // Adjust arrow points based on scaled offset and size
                    const arrowY = new Konva.Arrow({
                        points: [x, y + signY * symbolOffset / 1.5, x, y + signY * (symbolOffset + symbolSize)], // Adjusted start point slightly
                        pointerLength: pointerLength, pointerWidth: pointerWidth,
                        fill: color, stroke: color, strokeWidth: strokeWidth, strokeScaleEnabled: false, // Constant pixel stroke
                        listening: false
                    });
                    meshLayer.add(arrowY);
                }
            }
        }
        function requestSpringInput() { console.log("Create Springs button clicked. Requesting input."); if (feNodes.length === 0) { alert("Please mesh the membranes first before creating springs."); updateStatus("Mesh required before creating springs."); return; } if (geometricSpringNodes.length === 0) { alert("Please mark geometric nodes as spring connection points first (purple nodes)."); updateStatus("No spring connection points marked."); return; } const springInputArea = document.getElementById('spring-input-area'); if (springInputArea) { springInputArea.hidden = false; updateStatus("Enter spring stiffness (k) and click Confirm."); } else { console.error("Spring input area not found!"); updateStatus("Error: UI component missing."); } }
        function handleConfirmSprings() { console.log("Confirm Springs button clicked."); const kInput = document.getElementById('spring-k-input'); const springInputArea = document.getElementById('spring-input-area'); if (!kInput || !springInputArea) { console.error("Spring input field or area not found!"); alert("Error: Cannot find spring input UI elements."); return; } const stiffness = parseFloat(kInput.value); if (isNaN(stiffness) || stiffness <= 0) { alert("Invalid stiffness. Please enter a positive number."); updateStatus("Invalid spring stiffness entered."); return; } springInputArea.hidden = true; performSpringCreation(stiffness); }
        function performSpringCreation(stiffness) { console.log("Creating springs using closest node approach. Stiffness k =", stiffness); feSprings = []; if (springLayer) springLayer.destroyChildren(); feSpringIdCounter = 1; let springsCreatedCount = 0; geometricSpringNodes.forEach(geoNodeId => { console.log(`Processing marked geometric node ${geoNodeId}...`); const targetNode = findNodeDataById(geoNodeId); if (!targetNode) { console.warn(`Marked geometric node ${geoNodeId} not found.`); return; } const targetX = targetNode.x; const targetY = targetNode.y; console.log(`Target coordinates: (${targetX.toFixed(1)}, ${targetY.toFixed(1)})`); const nearbyMembraneNodes = []; membranes.filter(m => m.isMeshed).forEach(membrane => { let minDistSq = Infinity; let closestNodeId = null; feNodes.filter(feN => feN.membraneId === membrane.id).forEach(feN => { const distSq = (feN.x - targetX) ** 2 + (feN.y - targetY) ** 2; if (distSq < minDistSq) { minDistSq = distSq; closestNodeId = feN.id; } }); if (closestNodeId !== null && minDistSq < SPRING_CONN_TOLERANCE_SQ) { nearbyMembraneNodes.push({ membraneId: membrane.id, feNodeId: closestNodeId }); console.log(`Mem ${membrane.id}: Closest FE node ${closestNodeId} is within tolerance (Dist^2: ${minDistSq.toFixed(2)})`); } else if (closestNodeId !== null) { console.log(`Mem ${membrane.id}: Closest FE node ${closestNodeId} is too far (Dist^2: ${minDistSq.toFixed(2)})`); } else { console.warn(`Could not find any FE nodes for Mem ${membrane.id}.`); } }); console.log(`Found ${nearbyMembraneNodes.length} membranes with FE nodes near GeoNode ${geoNodeId}.`); if (nearbyMembraneNodes.length >= 2) { console.log(`Creating springs...`); for (let i = 0; i < nearbyMembraneNodes.length; i++) { for (let j = i + 1; j < nearbyMembraneNodes.length; j++) { const nodeInfoA = nearbyMembraneNodes[i]; const nodeInfoB = nearbyMembraneNodes[j]; if (nodeInfoA.membraneId !== nodeInfoB.membraneId) { const springId = feSpringIdCounter++; feSprings.push({ id: springId, feNodeId1: nodeInfoA.feNodeId, feNodeId2: nodeInfoB.feNodeId, stiffness: stiffness }); springsCreatedCount++; console.log(`Created spring ${springId} between FE Node ${nodeInfoA.feNodeId} (Mem ${nodeInfoA.membraneId}) and FE Node ${nodeInfoB.feNodeId} (Mem ${nodeInfoB.membraneId})`); } } } } else { console.log(`Not enough membranes (${nearbyMembraneNodes.length}) with nearby FE nodes found at GeoNode ${geoNodeId} to create springs.`); } }); drawSprings(); updateStatus(`Created ${springsCreatedCount} spring elements using closest nodes.`); console.log(`Finished creating springs. Total springs: ${feSprings.length}`); }
        function drawSprings() {
            // console.log("--- drawSprings() CALLED ---"); // Keep logs minimal if needed
            if (!springLayer || !stage) { return; }
            springLayer.destroyChildren();
            const scale = stage.scaleX(); // Get scale ONLY for calculating initial world offset

            feSprings.forEach(spring => {
                const node1 = findFeNodeById(spring.feNodeId1);
                const node2 = findFeNodeById(spring.feNodeId2);

                if (node1 && node2) {
                    // --- Draw the Spring Line --- (No changes needed)
                    const springLine = new Konva.Line({
                        points: [node1.x, node1.y, node2.x, node2.y],
                        stroke: SPRING_LINE_COLOR,
                        strokeWidth: LINE_STROKE_WIDTH_TARGET_PX,
                        strokeScaleEnabled: false,
                        dash: [8 / scale, 4 / scale], // Dash appearance still scales with world
                        listening: false,
                        name: `spring-line-${spring.id}`
                    });
                    springLayer.add(springLine);

                    // --- Check for and Prepare Spring Label Text ---
                    const springResult = resultsSpringLoads?.find(r => r.id === spring.id);
                    let labelText;
                    let labelName;
                    if (springResult && springResult.fx !== undefined && springResult.fy !== undefined) {
                        // Get numerical values first
                        const fxNum = Number(springResult.fx);
                        const fyNum = Number(springResult.fy);

                        // Calculate Resultant Force (FR)
                        const frNum = Math.sqrt(fxNum * fxNum + fyNum * fyNum);

                        // Format all values to 2 decimal places
                        const fxFormatted = fxNum.toFixed(2);
                        const fyFormatted = fyNum.toFixed(2);
                        const frFormatted = frNum.toFixed(2); // Format FR

                        // Create the 3-line label text including FR
                        labelText = `Fx: ${fxFormatted}\nFy: ${fyFormatted}\nFR: ${frFormatted}`;
                        labelName = `spring-result-${spring.id}`;
                    } else {
                        labelText = `S${spring.id}`;
                        labelName = `spring-id-${spring.id}`;
                    }

                    // --- Calculate Initial World Position based on Screen Offset ---
                    // Convert fixed screen pixel offset to world coordinate offset
                    const worldOffsetX = SPRING_LABEL_SCREEN_OFFSET_X / scale;
                    // Subtract screen Y offset because Konva Y increases downwards
                    const worldOffsetY = SPRING_LABEL_SCREEN_OFFSET_Y / scale;

                    // --- Create the Label with Fixed Font Size and Counter-Scaling ---
                    const labelToShow = new Konva.Text({
                        x: node1.x + worldOffsetX,           // Initial world X position
                        y: node1.y - worldOffsetY,           // Initial world Y position
                        text: labelText,
                        fontSize: SPRING_LABEL_FIXED_FONT_SIZE, // Use FIXED pixel font size
                        fill: SPRING_LABEL_COLOR,
                        listening: false,
                        name: labelName,
                        scaleX: 1 / scale,                    // Apply initial counter-scaling
                        scaleY: 1 / scale,                    // Apply initial counter-scaling
                        verticalAlign: 'bottom',             // Adjust alignment for better positioning when scaled
                        // align: 'left'
                    });

                    // Store the associated node ID for position updates during zoom
                    labelToShow.setAttr('node1Id', node1.id);
                    springLayer.add(labelToShow);

                } // end if(node1 && node2)
            }); // End forEach spring

            springLayer.batchDraw();
            // console.log(`Drew ${feSprings.length} springs (fixed size labels).`);
        }
        function handleApplyBc() { const type = document.getElementById('bc-type-select').value; console.log(`Applying BC Type: ${type} to ${selectedFeNodes.length} nodes.`); if (selectedFeNodes.length === 0) { updateStatus("No FE nodes selected to apply BC."); return; } let bcData = null; try { if (type === 'fixed') { const fixX = document.getElementById('bc-fix-x').checked; const fixY = document.getElementById('bc-fix-y').checked; if (!fixX && !fixY) { alert("For 'Fixed' BC, please select at least one direction (X or Y)."); return; } bcData = { type: 'fixed', value: { fixX: fixX, fixY: fixY } }; } else if (type === 'enforced') { const enforceX = document.getElementById('bc-enforce-x').checked; const enforceY = document.getElementById('bc-enforce-y').checked; const dxStr = document.getElementById('bc-dx-input').value; const dyStr = document.getElementById('bc-dy-input').value; let dx = null; let dy = null; if (!enforceX && !enforceY) { alert("For 'Enforced' BC, please check at least one direction (X or Y) to enforce."); return; } if (enforceX) { if (dxStr.trim() === '') { alert("Please enter a Dx value if 'Enforce X' is checked."); return; } dx = parseFloat(dxStr); if (isNaN(dx)) { alert("Invalid Dx value. Please enter a number."); return; } } if (enforceY) { if (dyStr.trim() === '') { alert("Please enter a Dy value if 'Enforce Y' is checked."); return; } dy = parseFloat(dyStr); if (isNaN(dy)) { alert("Invalid Dy value. Please enter a number."); return; } } bcData = { type: 'enforced', value: { dx: dx, dy: dy } }; } else if (type === 'load') { const fxStr = document.getElementById('bc-fx-input').value; const fyStr = document.getElementById('bc-fy-input').value; if (fxStr.trim() === '' || fyStr.trim() === '') { alert("Please enter values for Fx and Fy."); return; } const fx = parseFloat(fxStr); const fy = parseFloat(fyStr); if (isNaN(fx) || isNaN(fy)) { alert("Invalid Fx or Fy value. Please enter numbers."); return; } bcData = { type: 'load', value: { fx: fx, fy: fy } }; } } catch (error) { console.error("Error processing BC input:", error); alert("An error occurred while processing BC input."); return; } const nodesAffected = selectedFeNodes.length; selectedFeNodes.forEach(feNodeId => { const node = findFeNodeById(feNodeId); if (node) { node.bc = bcData; } else { console.warn(`Could not find FE Node ${feNodeId} to apply BC.`); } }); console.log("Applied BC Data:", bcData); clearFeSelection(); updateStatus(`Applied BC type '${type}' to ${nodesAffected} nodes.`); }
        function handleApplyMaterialProperties() {
            console.log("Applying material properties to selected membranes...");
            if (selectedMembranes.length === 0) {
                updateStatus("No membranes selected to apply properties to.");
                return;
            }

            const inputE = document.getElementById('mem-mat-prop-e');
            const inputNu = document.getElementById('mem-mat-prop-nu');
            const inputT = document.getElementById('mem-mat-prop-t');
            let valid = true;
            const e_val = parseFloat(inputE?.value);
            const nu_val = parseFloat(inputNu?.value);
            const t_val = parseFloat(inputT?.value);

            if (isNaN(e_val) || e_val <= 0) { alert("Invalid Young's Modulus (E). Must be positive number."); valid = false; }
            if (isNaN(nu_val) || nu_val < 0 || nu_val > 0.5) { alert("Invalid Poisson's Ratio (nu). Must be between 0 and 0.5."); valid = false; }
            if (isNaN(t_val) || t_val <= 0) { alert("Invalid Thickness (t). Must be positive number."); valid = false; }

            if (!valid) {
                console.error("Invalid material properties entered.");
                updateStatus("Error: Invalid material properties.");
                return;
            }

            let updatedCount = 0;
            selectedMembranes.forEach(memId => {
                const membrane = findMembraneById(memId);
                if (membrane) {
                    membrane.materialE = e_val;
                    membrane.materialNu = nu_val;
                    membrane.materialT = t_val;
                    updatedCount++;
                    console.log(`Updated material for Membrane ${memId}: E=${e_val}, nu=${nu_val}, t=${t_val}`);
                } else {
                    console.warn(`Could not find membrane ${memId} to update properties.`);
                }
            });

            updateStatus(`Applied properties to ${updatedCount} selected membranes.`);
        }

        // --- FEA Calculations ---
        function zeros(rows, cols) { return Array(rows).fill(0).map(() => Array(cols).fill(0)); }
        function matrixMultiply(A, B) { const A_rows = A.length; const A_cols = A[0]?.length || 0; const B_rows = B.length; const B_cols = B[0]?.length || 0; if (A_cols !== B_rows) { console.error("Incompatible matrices for multiplication", A_cols, B_rows); return null; } const C = zeros(A_rows, B_cols); for (let i = 0; i < A_rows; i++) { for (let j = 0; j < B_cols; j++) { for (let k = 0; k < A_cols; k++) { C[i][j] += (A[i]?.[k] || 0) * (B[k]?.[j] || 0); } } } return C; }
        function matrixTranspose(A) { const A_rows = A.length; const A_cols = A[0]?.length || 0; const C = zeros(A_cols, A_rows); for (let i = 0; i < A_rows; i++) { for (let j = 0; j < A_cols; j++) { C[j][i] = A[i][j]; } } return C; }
        function matrixAdd(A, B) { const A_rows = A.length; const A_cols = A[0]?.length || 0; const C = zeros(A_rows, A_cols); for (let i = 0; i < A_rows; i++) { for (let j = 0; j < A_cols; j++) { C[i][j] = (A[i]?.[j] || 0) + (B[i]?.[j] || 0); } } return C; }
        function scalarMultiply(scalar, A) { const A_rows = A.length; const A_cols = A[0]?.length || 0; const C = zeros(A_rows, A_cols); for (let i = 0; i < A_rows; i++) { for (let j = 0; j < A_cols; j++) { C[i][j] = scalar * (A[i]?.[j] || 0); } } return C; }
        function matrixVectorMultiply(A, v) { const A_rows = A.length; const A_cols = A[0]?.length || 0; const v_rows = v.length; if (A_cols !== v_rows) { console.error("Incompatible matrix/vector for multiplication"); return null; } const C = Array(A_rows).fill(0); for (let i = 0; i < A_rows; i++) { for (let k = 0; k < A_cols; k++) { C[i] += (A[i]?.[k] || 0) * (v[k] || 0); } } return C; }
        function calculateQuadElementStiffness(elementNodes, E, nu, t) { /* console.log(`Calculating stiffness for quad element [${elementNodes.map(n=>n.id).join(',')}]`); */ const Ke = zeros(8, 8); const coords = elementNodes.map(n => ({ x: n.x, y: n.y })); const D = zeros(3, 3); const E_factor = E / (1.0 - nu * nu); D[0][0] = E_factor; D[0][1] = E_factor * nu; D[1][0] = E_factor * nu; D[1][1] = E_factor; D[2][2] = E_factor * (1.0 - nu) / 2.0; const gpVal = 1.0 / Math.sqrt(3.0); const gaussPoints = [{ xi: -gpVal, eta: -gpVal }, { xi: gpVal, eta: -gpVal }, { xi: gpVal, eta: gpVal }, { xi: -gpVal, eta: gpVal }]; const gaussWeights = [1.0, 1.0, 1.0, 1.0]; for (let gp = 0; gp < gaussPoints.length; gp++) { const xi = gaussPoints[gp].xi; const eta = gaussPoints[gp].eta; const weight = gaussWeights[gp]; const dNdXiEta = [[-0.25 * (1 - eta), 0.25 * (1 - eta), 0.25 * (1 + eta), -0.25 * (1 + eta)], [-0.25 * (1 - xi), -0.25 * (1 + xi), 0.25 * (1 + xi), 0.25 * (1 - xi)]]; const J = zeros(2, 2); for (let i = 0; i < 4; i++) { J[0][0] += dNdXiEta[0][i] * coords[i].x; J[0][1] += dNdXiEta[0][i] * coords[i].y; J[1][0] += dNdXiEta[1][i] * coords[i].x; J[1][1] += dNdXiEta[1][i] * coords[i].y; } const detJ = J[0][0] * J[1][1] - J[0][1] * J[1][0]; if (detJ <= 1e-9) { console.error(`Element ${elementNodes.map(n => n.id).join(',')} has zero/negative Jacobian det (${detJ.toFixed(3)}) at GP ${gp}. Skipping GP.`); continue; } const invDetJ = 1.0 / detJ; const invJ = [[invDetJ * J[1][1], -invDetJ * J[0][1]], [-invDetJ * J[1][0], invDetJ * J[0][0]]]; const dNdXY = zeros(4, 2); for (let i = 0; i < 4; i++) { dNdXY[i][0] = invJ[0][0] * dNdXiEta[0][i] + invJ[0][1] * dNdXiEta[1][i]; dNdXY[i][1] = invJ[1][0] * dNdXiEta[0][i] + invJ[1][1] * dNdXiEta[1][i]; } const B = zeros(3, 8); for (let i = 0; i < 4; i++) { B[0][2 * i] = dNdXY[i][0]; B[0][2 * i + 1] = 0; B[1][2 * i] = 0; B[1][2 * i + 1] = dNdXY[i][1]; B[2][2 * i] = dNdXY[i][1]; B[2][2 * i + 1] = dNdXY[i][0]; } const B_T = matrixTranspose(B); const D_B = matrixMultiply(D, B); const B_T_D_B = matrixMultiply(B_T, D_B); if (B_T_D_B) { const scalarFactor = t * detJ * weight * weight; const Ke_gp = scalarMultiply(scalarFactor, B_T_D_B); for (let r = 0; r < 8; r++) { for (let c = 0; c < 8; c++) { Ke[r][c] += Ke_gp[r][c]; } } } else { console.error(`Matrix multiplication failed for element ${elementNodes.map(n => n.id).join(',')}, GP ${gp}`); } } return Ke; }
        function calculateSpringElementStiffness(node1, node2, k) { const k_matrix = [[k, 0, -k, 0], [0, k, 0, -k], [-k, 0, k, 0], [0, -k, 0, k]]; return k_matrix; }
        // --- Revert to Dense assembleGlobalMatrices ---
        // --- Assemble Global Matrices using math.js sparse ---
        function assembleGlobalMatrices() {
            console.log("Assembling global matrices (math.js Sparse)...");
            if (feNodes.length === 0) { console.error("No FE nodes exist for assembly."); return null; }
            const numNodes = feNodes.length;
            const N_DOF = numNodes * 2;
            console.log(`System size: ${numNodes} nodes, ${N_DOF} DOFs`);

            // Initialize math.js sparse matrix and dense vector
            let K_global = math.sparse(); // Correct: Initialize empty sparse matrix
            let F_global = math.zeros(N_DOF); // Initialize dense force vector (math.js matrix object)
            const nodeIndexMap = new Map();
            feNodes.forEach((node, index) => nodeIndexMap.set(node.id, index));

            // Helper to add entries to the sparse matrix (math.js handles summing duplicates)
            const addSparseEntry = (r, c, value) => {
                if (Math.abs(value) > 1e-12) { // Avoid adding explicit zeros (optional optimization)
                    try {
                        // Get existing value, add new, then set
                        K_global.set([r, c], (K_global.get([r, c]) || 0) + value);
                    } catch (e) {
                        // If get fails (entry doesn't exist), just set the new value
                        if (e.message && e.message.includes("Index out of range")) { // More specific check if needed
                            K_global.set([r, c], value);
                        } else {
                            console.error(`Error setting sparse matrix entry at (${r}, ${c}):`, e);
                        }
                    }
                }
            };

            // Process elements
            feElements.forEach(element => {
                if (element.type === 'quad' && element.nodeIds.length === 4) {
                    const elementNodes = element.nodeIds.map(id => findFeNodeById(id));
                    if (elementNodes.every(n => n)) {
                        const membrane = findMembraneById(element.membraneId);
                        if (!membrane) { console.error(`Membrane ${element.membraneId} not found for element ${element.id}. Skipping.`); return; }
                        const E = membrane.materialE ?? DEFAULT_MATERIAL_E;
                        const nu = membrane.materialNu ?? DEFAULT_MATERIAL_NU;
                        const t = membrane.materialT ?? DEFAULT_MATERIAL_T;
                        if (isNaN(E) || isNaN(nu) || isNaN(t) || E <= 0 || t <= 0 || nu < 0 || nu >= 0.5) {
                            console.error(`Invalid material for membrane ${membrane.id}, element ${element.id}. Skipping.`);
                            updateStatus(`Error: Invalid material on Membrane ${membrane.id}.`);
                            throw new Error(`Invalid material on Membrane ${membrane.id}`); // Halt assembly
                        }
                        const Ke = calculateQuadElementStiffness(elementNodes, E, nu, t); // Ke is standard JS array

                        // Assemble into global matrix using the helper
                        element.nodeIds.forEach((nodeId_i, i) => {
                            const globalRowIndex = nodeIndexMap.get(nodeId_i);
                            if (globalRowIndex === undefined) return;
                            element.nodeIds.forEach((nodeId_j, j) => {
                                const globalColIndex = nodeIndexMap.get(nodeId_j);
                                if (globalColIndex === undefined) return;
                                // Add all 4 entries for the K_ij block
                                addSparseEntry(2 * globalRowIndex, 2 * globalColIndex, Ke[2 * i]?.[2 * j] || 0);
                                addSparseEntry(2 * globalRowIndex, 2 * globalColIndex + 1, Ke[2 * i]?.[2 * j + 1] || 0);
                                addSparseEntry(2 * globalRowIndex + 1, 2 * globalColIndex, Ke[2 * i + 1]?.[2 * j] || 0);
                                addSparseEntry(2 * globalRowIndex + 1, 2 * globalColIndex + 1, Ke[2 * i + 1]?.[2 * j + 1] || 0);
                            });
                        });
                    }
                }
            });

            // Process springs
            feSprings.forEach(spring => {
                const node1 = findFeNodeById(spring.feNodeId1);
                const node2 = findFeNodeById(spring.feNodeId2);
                if (node1 && node2) {
                    const Ks = calculateSpringElementStiffness(node1, node2, spring.stiffness); // Ks is standard JS array
                    const globalIndex1 = nodeIndexMap.get(node1.id);
                    const globalIndex2 = nodeIndexMap.get(node2.id);
                    if (globalIndex1 !== undefined && globalIndex2 !== undefined) {
                        const dofMap = [2 * globalIndex1, 2 * globalIndex1 + 1, 2 * globalIndex2, 2 * globalIndex2 + 1];
                        for (let i = 0; i < 4; i++) {
                            for (let j = 0; j < 4; j++) {
                                addSparseEntry(dofMap[i], dofMap[j], Ks[i]?.[j] || 0);
                            }
                        }
                    }
                }
            });

            // Populate the dense force vector using math.subset and math.index
            feNodes.forEach(node => {
                if (node.bc && node.bc.type === 'load') {
                    const globalIndex = nodeIndexMap.get(node.id);
                    if (globalIndex !== undefined) {
                        const currentFx = math.subset(F_global, math.index(2 * globalIndex)) || 0;
                        const currentFy = math.subset(F_global, math.index(2 * globalIndex + 1)) || 0;
                        F_global = math.subset(F_global, math.index(2 * globalIndex), currentFx + (node.bc.value.fx ?? 0));
                        F_global = math.subset(F_global, math.index(2 * globalIndex + 1), currentFy + (node.bc.value.fy ?? 0));
                    }
                }
            });

            console.log(`Global matrices assembled (math.js Sparse: ${K_global.size()[0]}x${K_global.size()[1]}, ${K_global.toJSON().values.length} non-zeros).`);
            return { K_global, F_global, nodeIndexMap, N_DOF }; // Return math.js sparse K and dense F
        }

        // --- MODIFIED: applyBoundaryConditions using Hybrid Method (Direct for Fixed, Penalty for Enforced) ---
        function applyBoundaryConditions(K_global, F_global, nodeIndexMap, N_DOF) {
            console.log("Applying boundary conditions (Hybrid: Direct-Fixed, Penalty-Enforced)...");
            const K_modified = math.clone(K_global); // K_global is math.js sparse matrix
            let F_modified = math.clone(F_global);   // F_global is math.js dense vector/matrix - USE LET
            const knownDisplacementIndices = new Set(); // Keep track of constrained DOFs

            const PENALTY_MAGNITUDE = 1e10; // Reintroduce penalty magnitude

            try {
                feNodes.forEach(node => {
                    if (node.bc && (node.bc.type === 'fixed' || node.bc.type === 'enforced')) {
                        const globalIndex = nodeIndexMap.get(node.id);
                        if (globalIndex === undefined) { console.warn(`Node ID ${node.id} not found in map.`); return; }

                        const dofX = 2 * globalIndex;
                        const dofY = 2 * globalIndex + 1;
                        if (dofX >= N_DOF || dofY >= N_DOF) { console.error(`DOF index out of bounds for node ${node.id}.`); return; }

                        // --- Fixed BCs (Direct Method - Zeroing) ---
                        if (node.bc.type === 'fixed') {
                            const fixX = node.bc.value.fixX;
                            const fixY = node.bc.value.fixY;

                            if (fixX) {
                                // console.log(`Applying direct BC to DOF ${dofX} (Node ${node.id} X), value=0`);
                                // Zero out row dofX & col dofX (Optional: subset method might be faster)
                                for (let j = 0; j < N_DOF; j++) { if (j !== dofX) K_modified.set([dofX, j], 0); }
                                for (let i = 0; i < N_DOF; i++) { if (i !== dofX) K_modified.set([i, dofX], 0); }
                                K_modified.set([dofX, dofX], 1); // Set diagonal to 1
                                F_modified = math.subset(F_modified, math.index(dofX), 0); // Set force to 0
                                knownDisplacementIndices.add(dofX);
                            }
                            if (fixY) {
                                // console.log(`Applying direct BC to DOF ${dofY} (Node ${node.id} Y), value=0`);
                                // Zero out row dofY & col dofY
                                for (let j = 0; j < N_DOF; j++) { if (j !== dofY) K_modified.set([dofY, j], 0); }
                                for (let i = 0; i < N_DOF; i++) { if (i !== dofY) K_modified.set([i, dofY], 0); }
                                K_modified.set([dofY, dofY], 1); // Set diagonal to 1
                                F_modified = math.subset(F_modified, math.index(dofY), 0); // Set force to 0
                                knownDisplacementIndices.add(dofY);
                            }
                        }
                        // --- Enforced BCs (Penalty Method) ---
                        else if (node.bc.type === 'enforced') {
                            const enforceX = node.bc.value.dx !== null;
                            const enforceY = node.bc.value.dy !== null;
                            const dx = node.bc.value.dx ?? 0;
                            const dy = node.bc.value.dy ?? 0;
                            const penalty = PENALTY_MAGNITUDE;

                            if (enforceX) {
                                console.log(`Applying penalty BC to DOF ${dofX} (Node ${node.id} X), value=${dx}`);
                                const currentDiagX = K_modified.get([dofX, dofX]) || 0;
                                K_modified.set([dofX, dofX], currentDiagX + penalty); // K[k,k] += penalty

                                const currentForceX = math.subset(F_modified, math.index(dofX)) || 0;
                                F_modified = math.subset(F_modified, math.index(dofX), currentForceX + penalty * dx); // F[k] += penalty * d_prescribed
                                knownDisplacementIndices.add(dofX);
                            }
                            if (enforceY) {
                                console.log(`Applying penalty BC to DOF ${dofY} (Node ${node.id} Y), value=${dy}`);
                                const currentDiagY = K_modified.get([dofY, dofY]) || 0;
                                K_modified.set([dofY, dofY], currentDiagY + penalty); // K[k,k] += penalty

                                const currentForceY = math.subset(F_modified, math.index(dofY)) || 0;
                                F_modified = math.subset(F_modified, math.index(dofY), currentForceY + penalty * dy); // F[k] += penalty * d_prescribed
                                knownDisplacementIndices.add(dofY);
                            }
                        }
                    }
                });
            } catch (error) {
                console.error("Error applying BCs (Hybrid Method):", error);
                updateStatus("Error during BC application.");
                return null; // Indicate failure
            }

            console.log(`Boundary conditions applied (Hybrid). ${knownDisplacementIndices.size} DOFs constrained.`);
            return { K_modified, F_modified, knownDisplacementIndices }; // Return math.js sparse K and dense F
        }
        // --- Revert to Dense solveSystem using helper ---
        // --- Update solveSystem for math.js sparse ---
        function solveSystem(K_modified, F_modified, N_DOF) {
            console.log("Solving system (math.js Sparse) ...");
            if (typeof math === 'undefined' || typeof math.lusolve !== 'function') {
                console.error("math.js library or lusolve function not loaded. Cannot solve.");
                alert("Error: math.js library not found or incomplete.");
                return null;
            }
            try {
                // Ensure F_modified is a 1D matrix (column vector) for lusolve if it isn't already
                if (F_modified.size().length > 1 && F_modified.size()[1] !== 1) {
                    console.warn("Reshaping F_modified to column vector for lusolve");
                    F_modified = math.reshape(F_modified, [N_DOF, 1]);
                } else if (F_modified.size().length === 1) {
                    // If it's a flat array, convert to Nx1 matrix
                    F_modified = math.reshape(F_modified, [N_DOF, 1]);
                }

                console.time("MathJsSparseSolve");
                // Solve using sparse LU decomposition provided by math.js
                const d_matrix = math.lusolve(K_modified, F_modified);
                console.timeEnd("MathJsSparseSolve");

                // lusolve returns a Matrix object, convert it to a flat JS array
                const d_vec = d_matrix.toArray().flat();

                if (!d_vec || d_vec.length !== N_DOF) {
                    console.error("Solver returned unexpected format or size.", d_vec);
                    throw new Error(`Solver failed or returned vector of incorrect size. Expected ${N_DOF}, Got ${d_vec?.length}`);
                }
                console.log("System solved successfully (math.js Sparse).");
                return d_vec; // Return standard JS array
            } catch (error) {
                console.error("Error solving sparse system with math.js:", error);
                // Attempt to provide more specific feedback for common math.js errors
                if (error.message && error.message.toLowerCase().includes("matrix is singular")) {
                    alert(`Analysis failed: Matrix is singular. Check boundary conditions (ensure sufficient constraints) and mesh quality.`);
                } else if (error.message && error.message.toLowerCase().includes("dimension mismatch")) {
                    alert(`Analysis failed: Dimension mismatch during solve. K(${K_modified.size().join(',')}), F(${F_modified.size().join(',')})`);
                } else {
                    alert(`Error solving system: ${error.message}. Check BCs/mesh.`);
                }
                updateStatus("Analysis failed: Solver error.");
                return null;
            }
        }

        // Helper function for Gaussian elimination (already present in the file)
        function solveDenseLinearSystem(A, b) {
            const n = A.length;
            if (n === 0 || A[0].length !== n || b.length !== n) {
                console.error("Invalid input to solveDenseLinearSystem:", A, b);
                return null;
            }
            // Augment matrix (Create a copy to avoid modifying original A if it's needed elsewhere)
            const Aug = A.map((row, i) => [...row, b[i]]);

            // Forward elimination
            for (let i = 0; i < n; i++) {
                let pivot = i;
                for (let j = i + 1; j < n; j++) { if (Math.abs(Aug[j][i]) > Math.abs(Aug[pivot][i])) { pivot = j; } }
                [Aug[i], Aug[pivot]] = [Aug[pivot], Aug[i]]; // Swap rows

                if (Math.abs(Aug[i][i]) < 1e-12) {
                    console.warn(`Zero pivot encountered at row ${i}. Matrix might be singular.`);
                    continue; // Skip this row if pivot is effectively zero
                }

                for (let j = i + 1; j < n; j++) {
                    const factor = Aug[j][i] / Aug[i][i];
                    for (let k = i; k <= n; k++) { // Iterate through the augmented part too
                        Aug[j][k] -= factor * Aug[i][k];
                    }
                }
            }

            // Back substitution
            const x = Array(n);
            for (let i = n - 1; i >= 0; i--) {
                if (Math.abs(Aug[i][i]) < 1e-12) {
                    console.error(`System may be singular or has no unique solution (zero on diagonal at row ${i} after elimination).`);
                    // Decide whether to return null or partial solution based on needs
                    return null; // Indicate failure
                }
                let sum = 0;
                for (let j = i + 1; j < n; j++) { sum += Aug[i][j] * x[j]; }
                x[i] = (Aug[i][n] - sum) / Aug[i][i];
            }
            return x; // Return the solution vector
        }

        // --- Update calculateResults for math.js sparse K_original ---
        // --- Update calculateResults for math.js sparse K_original ---
        function calculateResults(d, K_original, F_original, nodeIndexMap, N_DOF) {
            console.log("Calculating results (math.js Sparse K)...");
            // Convert solution vector d (JS array) back to math.js Matrix for multiplication
            const d_matrix = math.matrix(d);

            if (!d_matrix || !nodeIndexMap || nodeIndexMap.size === 0 || typeof math === 'undefined') {
                console.error("Invalid input or math.js not loaded for calculateResults.");
                resultsSpringLoads = []; resultsReactions = []; resultsElementStresses = []; return;
            }

            resultsSpringLoads = [];
            resultsReactions = [];
            resultsElementStresses = []; // Stresses calculated later

            // --- Calculate Spring Loads (uses d - standard JS array) ---
            feSprings.forEach(spring => {
                const node1 = findFeNodeById(spring.feNodeId1);
                const node2 = findFeNodeById(spring.feNodeId2);
                const idx1 = nodeIndexMap.get(spring.feNodeId1);
                const idx2 = nodeIndexMap.get(spring.feNodeId2);
                if (node1 && node2 && idx1 !== undefined && idx2 !== undefined) {
                    if (2 * idx1 + 1 >= d.length || 2 * idx2 + 1 >= d.length) { console.error(`DOF index out of bounds for spring ${spring.id}.`); return; }
                    const dx1 = d[2 * idx1]; const dy1 = d[2 * idx1 + 1];
                    const dx2 = d[2 * idx2]; const dy2 = d[2 * idx2 + 1];
                    const deltaX = dx2 - dx1; const deltaY = dy2 - dy1;
                    const forceX = spring.stiffness * deltaX;
                    const forceY = spring.stiffness * deltaY;
                    resultsSpringLoads.push({ id: spring.id, fx: forceX.toExponential(3), fy: forceY.toExponential(3) });
                } else { console.warn(`Could not find nodes/indices for spring ${spring.id}`); }
            });
            console.log('Calculated Spring Loads:', resultsSpringLoads);

            // --- Calculate Reaction Forces using math.js operations ---
            console.log("Calculating reaction forces (math.js)...");
            try {
                console.time("MathJsReactionCalc");
                // Ensure F_original is a column vector if it's flat
                let F_orig_matrix = F_original;
                if (F_original.size().length === 1) {
                    F_orig_matrix = math.reshape(F_original, [N_DOF, 1]);
                }

                const K_d = math.multiply(K_original, d_matrix); // K_original * d (sparse * dense)
                const R_matrix = math.subtract(K_d, F_orig_matrix);   // K*d - F_original
                const R_vec = R_matrix.toArray().flat(); // Convert result to standard JS array
                console.timeEnd("MathJsReactionCalc");

                feNodes.forEach(node => {
                    if (node.bc && (node.bc.type === 'fixed' || node.bc.type === 'enforced')) {
                        const globalIndex = nodeIndexMap.get(node.id);
                        if (globalIndex !== undefined) {
                            const dofX = 2 * globalIndex; const dofY = 2 * globalIndex + 1;
                            if (dofX >= R_vec.length || dofY >= R_vec.length) { console.error(`Reaction index out of bounds for node ${node.id}`); return; }
                            let rx = 0, ry = 0;
                            let reportX = (node.bc.type === 'fixed' && node.bc.value.fixX) || (node.bc.type === 'enforced' && node.bc.value.dx !== null);
                            let reportY = (node.bc.type === 'fixed' && node.bc.value.fixY) || (node.bc.type === 'enforced' && node.bc.value.dy !== null);

                            if (reportX) rx = (R_vec[dofX] !== undefined) ? Number(R_vec[dofX]).toExponential(3) : 'N/A';
                            if (reportY) ry = (R_vec[dofY] !== undefined) ? Number(R_vec[dofY]).toExponential(3) : 'N/A';

                            const tolerance = 1e-6;
                            if (reportX || reportY) {
                                if (Math.abs(Number(rx)) > tolerance || Math.abs(Number(ry)) > tolerance || node.bc.type === 'enforced') {
                                    resultsReactions.push({ feNodeId: node.id, rx: reportX ? rx : '0.000e+0', ry: reportY ? ry : '0.000e+0' });
                                }
                            }
                        }
                    }
                });
                console.log("Reaction forces calculated using math.js.");

            } catch (error) {
                console.error("Error calculating math.js reaction forces:", error);
                resultsReactions = [];
                feNodes.forEach(node => {
                    if (node.bc && (node.bc.type === 'fixed' || node.bc.type === 'enforced')) {
                        resultsReactions.push({ feNodeId: node.id, rx: 'Error', ry: 'Error' });
                    }
                });
            }
            console.log('Calculated Reactions:', resultsReactions);

            // --- Calculate Element Stresses (uses d - standard JS array) ---
            console.log("Calculating element stresses ...");
            resultsElementStresses = [];
            feElements.forEach(element => {
                if (element.type === 'quad' && element.nodeIds.length === 4) {
                    const elementNodes = element.nodeIds.map(id => findFeNodeById(id));
                    if (!elementNodes.every(n => n)) { console.warn(`Skipping stress for element ${element.id}, missing node data.`); return; }
                    const membrane = findMembraneById(element.membraneId);
                    if (!membrane) { console.warn(`Membrane ${element.membraneId} not found for stress calc, elem ${element.id}.`); return; }
                    const E = membrane.materialE ?? DEFAULT_MATERIAL_E;
                    const nu = membrane.materialNu ?? DEFAULT_MATERIAL_NU;
                    if (isNaN(E) || isNaN(nu) || E <= 0 || nu < 0 || nu >= 0.5) { console.warn(`Invalid material for membrane ${membrane.id} during stress calc, elem ${element.id}.`); return; }
                    const D_element = zeros(3, 3);
                    const E_factor_element = E / (1.0 - nu * nu);
                    D_element[0][0] = E_factor_element; D_element[0][1] = E_factor_element * nu;
                    D_element[1][0] = E_factor_element * nu; D_element[1][1] = E_factor_element;
                    D_element[2][2] = E_factor_element * (1.0 - nu) / 2.0;

                    const nodeCoords = elementNodes.map(n => ({ x: n.x, y: n.y }));
                    const elementDisp = zeros(8, 1);
                    let dataComplete = true;
                    element.nodeIds.forEach((nodeId, i) => {
                        const globalIndex = nodeIndexMap.get(nodeId);
                        // Use d (standard JS array) here
                        if (globalIndex === undefined || (2 * globalIndex + 1) >= d.length) { console.warn(`Missing displacement data for node ${nodeId}, elem ${element.id}`); dataComplete = false; return; }
                        elementDisp[2 * i][0] = d[2 * globalIndex];
                        elementDisp[2 * i + 1][0] = d[2 * globalIndex + 1];
                    });
                    if (!dataComplete) return;

                    const xi = 0, eta = 0; // Center stress
                    const dNdXiEta = [[-0.25 * (1 - eta), 0.25 * (1 - eta), 0.25 * (1 + eta), -0.25 * (1 + eta)], [-0.25 * (1 - xi), -0.25 * (1 + xi), 0.25 * (1 + xi), 0.25 * (1 - xi)]];
                    const J = zeros(2, 2);
                    for (let i = 0; i < 4; i++) { J[0][0] += dNdXiEta[0][i] * nodeCoords[i].x; J[0][1] += dNdXiEta[0][i] * nodeCoords[i].y; J[1][0] += dNdXiEta[1][i] * nodeCoords[i].x; J[1][1] += dNdXiEta[1][i] * nodeCoords[i].y; }
                    const detJ = J[0][0] * J[1][1] - J[0][1] * J[1][0];
                    if (detJ <= 1e-9) { console.warn(`Zero/negative Jacobian for stress calc, elem ${element.id}.`); return; }
                    const invDetJ = 1.0 / detJ;
                    const invJ = [[invDetJ * J[1][1], -invDetJ * J[0][1]], [-invDetJ * J[1][0], invDetJ * J[0][0]]];
                    const dNdXY = zeros(4, 2);
                    for (let i = 0; i < 4; i++) { dNdXY[i][0] = invJ[0][0] * dNdXiEta[0][i] + invJ[0][1] * dNdXiEta[1][i]; dNdXY[i][1] = invJ[1][0] * dNdXiEta[0][i] + invJ[1][1] * dNdXiEta[1][i]; }
                    const B = zeros(3, 8);
                    for (let i = 0; i < 4; i++) { B[0][2 * i] = dNdXY[i][0]; B[0][2 * i + 1] = 0; B[1][2 * i] = 0; B[1][2 * i + 1] = dNdXY[i][1]; B[2][2 * i] = dNdXY[i][1]; B[2][2 * i + 1] = dNdXY[i][0]; }

                    // Use existing dense helper for B * d_element
                    const epsilon = matrixVectorMultiply(B, elementDisp.flat()); // Still uses standard arrays
                    if (!epsilon) { console.warn(`Strain calculation failed for element ${element.id}`); return; }

                    // Use existing dense helper for D * epsilon
                    const sigma = matrixVectorMultiply(D_element, epsilon); // Still uses standard arrays
                    if (!sigma) { console.warn(`Stress calculation failed for element ${element.id}`); return; }

                    const sxx = sigma[0]; const syy = sigma[1]; const sxy = sigma[2];
                    const sigmaVM = Math.sqrt(Math.max(0, sxx ** 2 - sxx * syy + syy ** 2 + 3 * sxy ** 2));
                    resultsElementStresses.push({ elementId: element.id, sxx: sxx.toExponential(3), syy: syy.toExponential(3), sxy: sxy.toExponential(3), sigmaVM: sigmaVM });
                }
            });
            console.log(`Calculated stresses for ${resultsElementStresses.length} elements.`);

            resultsDisplacements = d; // Store the final displacement vector (standard JS array)
            console.log("Results calculation finished (math.js).");
        }

        // --- Revert runAnalysis Orchestration ---
        // --- Update runAnalysis Orchestration for math.js ---
        function runAnalysis() {
            console.log("--- Starting Analysis (math.js Sparse) ---");
            updateStatus("Running analysis...");
            // --- Checks remain the same ---
            if (feNodes.length === 0 || feElements.length === 0) { alert("Mesh required."); updateStatus("Analysis failed: Mesh required."); return; }
            const hasBCs = feNodes.some(n => n.bc && n.bc.type === 'fixed');
            if (!hasBCs) { alert("Warning: No fixed BCs found."); console.warn("No fixed BCs found."); }

            let allMaterialsValid = true;
            membranes.forEach(membrane => {
                if (membrane.isMeshed && (isNaN(membrane.materialE) || isNaN(membrane.materialNu) || isNaN(membrane.materialT) || membrane.materialE <= 0 || membrane.materialT <= 0 || membrane.materialNu < 0 || membrane.materialNu >= 0.5)) {
                    console.error(`Membrane ${membrane.id} is meshed but has invalid material properties: E=${membrane.materialE}, nu=${membrane.materialNu}, t=${membrane.materialT}`);
                    allMaterialsValid = false;
                }
            });
            if (!allMaterialsValid) {
                updateStatus("Analysis failed: One or more meshed membranes have invalid material properties.");
                alert("Analysis failed: Check material properties for all meshed membranes.");
                return;
            }
            // --- End Material Check ---

            updateStatus("Assembling global matrices (math.js Sparse)...");
            console.time("TotalAssembly");
            let assemblyResult;
            try {
                assemblyResult = assembleGlobalMatrices();
            } catch (error) {
                console.error("Error during sparse matrix assembly:", error);
                updateStatus(`Analysis failed: ${error.message}`);
                alert(`Analysis failed during assembly: ${error.message}`);
                return;
            }
            console.timeEnd("TotalAssembly");
            console.log("Assembly Result:", assemblyResult ? "OK" : "Failed");
            if (!assemblyResult) { updateStatus("Analysis failed: Matrix assembly error."); return; }

            // Destructure assembly results (K_global is math.js sparse, F_global is math.js dense)
            const { K_global, F_global, nodeIndexMap, N_DOF } = assemblyResult;

            // --- Store original K and F (math.js objects) ---
            const K_original = math.clone(K_global);
            const F_original = math.clone(F_global);
            // --- End store original ---

            updateStatus("Applying boundary conditions (math.js Sparse)...");
            console.time("ApplyBCs");
            // Pass the math.js objects to applyBoundaryConditions
            const bcResult = applyBoundaryConditions(K_global, F_global, nodeIndexMap, N_DOF);
            console.timeEnd("ApplyBCs");
            console.log("BC Result:", bcResult ? "OK" : "Failed");
            if (!bcResult) { updateStatus("Analysis failed: Error applying BCs."); return; }
            // Destructure modified math.js objects
            const { K_modified, F_modified } = bcResult;

            updateStatus("Solving system (math.js Sparse)...");
            console.time("TotalSolve");
            // Pass math.js objects to solveSystem
            const d = solveSystem(K_modified, F_modified, N_DOF); // d is returned as a standard JS array
            console.timeEnd("TotalSolve");
            console.log("Solver Result (d):", d ? `Array[${d.length}]` : "Failed");
            if (!d) { updateStatus("Analysis failed: System solve error."); return; } // d is null if solve failed

            // Displacement and scale factor calculation (uses d - standard JS array)
            let maxDisp = 0;
            for (let i = 0; i < d.length; i += 2) { const dispMag = Math.sqrt((d[i] ** 2) + (d[i + 1] ** 2)); if (dispMag > maxDisp) { maxDisp = dispMag; } }
            console.log("Maximum displacement:", maxDisp);
            let avgElementSideLength = 50;
            if (feElements.length > 0 && feElements[0].nodeIds.length >= 2) { const nodeA = findFeNodeById(feElements[0].nodeIds[0]); const nodeB = findFeNodeById(feElements[0].nodeIds[1]); if (nodeA && nodeB) { avgElementSideLength = Math.sqrt((nodeA.x - nodeB.x) ** 2 + (nodeA.y - nodeB.y) ** 2); } }
            console.log("Avg element side:", avgElementSideLength);
            const DISP_TOL = 1e-9; let scaleFactor = 1;
            if (maxDisp > DISP_TOL) { scaleFactor = avgElementSideLength / maxDisp; scaleFactor = Math.min(scaleFactor, 500); scaleFactor = Math.max(scaleFactor, 1); }
            console.log("Deformation scale factor:", scaleFactor);

            updateStatus("Calculating results (math.js Sparse)...");
            console.time("CalculateResults");
            // --- Pass original math.js K/F objects and standard JS array d ---
            calculateResults(d, K_original, F_original, nodeIndexMap, N_DOF);
            console.timeEnd("CalculateResults");

            updateStatus("Analysis complete. Updating display...");
            console.time("DrawResults");
            updateResultsDisplay();
            // Pass standard JS array d to drawDeformedMesh
            drawDeformedMesh(d, scaleFactor);
            drawSprings();
            drawStressResults(resultsElementStresses);
            handleResultsViewChange(); // Set initial visibility based on radio buttons
            console.timeEnd("DrawResults");
            console.log("--- Analysis Finished (math.js Sparse) ---");
        }

        // --- Save/Load Functions ---
        function handleSaveModel() {
            console.log("Saving model...");
            try {
                // Simplify nodes and membranes for saving, include material props
                const simplifiedNodes = nodes.map(n => ({ id: n.id, x: n.x, y: n.y }));
                const simplifiedMembranes = membranes.map(m => ({
                    id: m.id,
                    nodeIds: m.nodeIds,
                    materialE: m.materialE ?? DEFAULT_MATERIAL_E, // Save actual or default E
                    materialNu: m.materialNu ?? DEFAULT_MATERIAL_NU, // Save actual or default nu
                    materialT: m.materialT ?? DEFAULT_MATERIAL_T   // Save actual or default t
                }));
                // FE data can be saved directly as they are simple objects (BCs included)
                const simplifiedFeNodes = feNodes; // No simplification needed if BCs are simple objects
                const simplifiedFeElements = feElements;
                const simplifiedFeSprings = feSprings;

                const saveData = {
                    nodes: simplifiedNodes,
                    membranes: simplifiedMembranes,
                    geometricSpringNodes: geometricSpringNodes,
                    feNodes: simplifiedFeNodes,
                    feElements: simplifiedFeElements,
                    feSprings: simplifiedFeSprings,
                    // Save ID counters to resume numbering correctly
                    nextCounters: {
                        node: nextNodeId,
                        membrane: nextMembraneId,
                        feNode: feNodeIdCounter,
                        feElement: feElementIdCounter,
                        feSpring: feSpringIdCounter
                    }
                };

                const jsonString = JSON.stringify(saveData, null, 2);
                if (navigator.clipboard && navigator.clipboard.writeText) {
                    navigator.clipboard.writeText(jsonString).then(() => {
                        console.log("Model JSON copied to clipboard.");
                        alert("Model JSON copied to clipboard. Paste it into a text file to save.");
                        updateStatus("Model JSON copied to clipboard.");
                    }).catch(err => {
                        console.error('Failed to copy model JSON: ', err);
                        alert("Failed to copy model JSON. See console. Check permissions?");
                        updateStatus("Error copying model JSON.");
                    });
                } else {
                    console.warn("Clipboard API not available. Displaying JSON in textarea.");
                    document.getElementById('load-textarea').value = jsonString;
                    updateStatus("Clipboard unavailable. JSON shown in Load textarea.");
                    alert("Clipboard not available. JSON data placed in Load textarea for manual copy.");
                }
            } catch (error) {
                console.error("Error during save process:", error);
                alert("An error occurred while saving the model.");
                updateStatus("Error saving model.");
            }
        }
        function handleLoadText() {
            console.log("Loading model from text area...");
            const textArea = document.getElementById('load-textarea');
            const jsonString = textArea.value;
            if (!jsonString || jsonString.trim() === '') { alert("Please paste the model JSON data into the text area first."); return; }
            try {
                const loadedData = JSON.parse(jsonString);

                // --- Enhanced Validation ---
                if (!loadedData || typeof loadedData !== 'object' ||
                    !Array.isArray(loadedData.nodes) ||
                    !Array.isArray(loadedData.membranes) ||
                    !Array.isArray(loadedData.geometricSpringNodes) ||
                    !Array.isArray(loadedData.feNodes) ||
                    !Array.isArray(loadedData.feElements) ||
                    !Array.isArray(loadedData.feSprings) ||
                    typeof loadedData.nextCounters !== 'object') {
                    throw new Error("Invalid file format or missing required properties.");
                }

                clearAllData(); // Clear existing data AND reset counters
                console.log("Restoring model state...");

                // --- Restore Geometry Nodes ---
                let maxNodeId = 0;
                const loadedNodesMap = new Map();
                nodes = []; // Ensure nodes array is empty after clearAllData
                loadedData.nodes.forEach(nodeData => {
                    // Pass the loaded ID to addNode
                    const newNodeData = addNode(nodeData.x, nodeData.y, nodeData.id);
                    if (newNodeData) {
                        // nodes.push(newNodeData); // addNode already pushes to global nodes array
                        loadedNodesMap.set(newNodeData.id, newNodeData);
                        if (nodeData.id > maxNodeId) maxNodeId = nodeData.id;
                    } else { console.error(`Failed to load node ${nodeData.id}`); }
                });
                // Set next ID based on loaded data, default to 1 if no nodes loaded
                nextNodeId = (loadedData.nextCounters.node > maxNodeId) ? loadedData.nextCounters.node : (maxNodeId + 1);
                console.log(`Restored ${nodes.length} nodes. Next Node ID: ${nextNodeId}`);

                // --- Restore Membranes (with material properties) ---
                let maxMembraneId = 0;
                membranes = []; // Ensure membranes array is empty
                loadedData.membranes.forEach(memData => {
                    const newMembrane = createMembraneFromData(memData.id, memData.nodeIds, memData.materialE, memData.materialNu, memData.materialT);
                    if (newMembrane) {
                        membranes.push(newMembrane); // createMembraneFromData only returns, doesn't push globally
                        if (memData.id > maxMembraneId) maxMembraneId = memData.id;
                    } else { console.error(`Failed to load membrane ${memData.id}`); }
                });
                nextMembraneId = (loadedData.nextCounters.membrane > maxMembraneId) ? loadedData.nextCounters.membrane : (maxMembraneId + 1);
                console.log(`Restored ${membranes.length} membranes. Next Membrane ID: ${nextMembraneId}`);

                // --- Restore Geometric Spring Nodes ---
                geometricSpringNodes = loadedData.geometricSpringNodes;
                console.log(`Restored ${geometricSpringNodes.length} marked spring points.`);

                // --- Restore FE Data ---
                feNodes = loadedData.feNodes;
                feElements = loadedData.feElements;
                feSprings = loadedData.feSprings;
                console.log(`Restored ${feNodes.length} FE nodes, ${feElements.length} FE elements, ${feSprings.length} FE springs.`);

                // --- Restore FE Counters ---
                let maxFeNodeId = 0;
                feNodes.forEach(n => { if (n.id > maxFeNodeId) maxFeNodeId = n.id; });
                feNodeIdCounter = (loadedData.nextCounters.feNode > maxFeNodeId) ? loadedData.nextCounters.feNode : (maxFeNodeId + 1);

                let maxFeElementId = 0;
                feElements.forEach(e => { if (e.id > maxFeElementId) maxFeElementId = e.id; });
                feElementIdCounter = (loadedData.nextCounters.feElement > maxFeElementId) ? loadedData.nextCounters.feElement : (maxFeElementId + 1);

                let maxFeSpringId = 0;
                feSprings.forEach(s => { if (s.id > maxFeSpringId) maxFeSpringId = s.id; });
                feSpringIdCounter = (loadedData.nextCounters.feSpring > maxFeSpringId) ? loadedData.nextCounters.feSpring : (maxFeSpringId + 1);

                console.log(`Restored Counters: Next FE Node ID: ${feNodeIdCounter}, Element: ${feElementIdCounter}, Spring: ${feSpringIdCounter}`);

                // --- Mark membranes as meshed if they have FE elements ---
                const meshedMembraneIds = new Set(feElements.map(el => el.membraneId));
                membranes.forEach(mem => {
                    mem.isMeshed = meshedMembraneIds.has(mem.id);
                });

                console.log("Drawing loaded FE data...");

                drawMesh();    // Draw mesh based on loaded feNodes/feElements
                drawSprings(); // Draw springs based on loaded feSprings

                console.log("Batch drawing loaded geometry and membranes...");
                geometryLayer?.batchDraw();     // Redraw layer with loaded nodes added by addNode
                membraneFillLayer?.batchDraw(); // Redraw layer with loaded membranes added by createMembraneFromData

                // --- Batch draw layers that were populated ---
                console.log("Batch drawing loaded model...");
                geometryLayer?.batchDraw();
                membraneFillLayer?.batchDraw();
                meshLayer?.batchDraw();
                springLayer?.batchDraw();
                stressLayer?.visible(false); // Ensure stress layer is hidden initially
                stressLayer?.batchDraw();
                updateSpringPointsInfo();
                updateMembraneSelectionInfo();
                updateFeSelectionInfo();
                updateResultsDisplay(); // Clear old results display
                textArea.value = '';
                updateStatus(`Model loaded successfully. ${nodes.length} nodes, ${membranes.length} membranes, ${feElements.length} elements.`);

            } catch (error) {
                console.error("Error loading model:", error);
                alert(`Error loading model: ${error.message}`);
                updateStatus("Error loading model.");   // Attempt to clear again in case of partial load before error
                clearAllData();    // Explicitly redraw the cleared state
                geometryLayer?.batchDraw();
                membraneFillLayer?.batchDraw();
                meshLayer?.batchDraw();
                springLayer?.batchDraw();
                stressLayer?.batchDraw();
            }
        }

        function clearAllData() {
            console.log("Clearing all model data...");
            nodes = [];
            membranes = [];
            geometricSpringNodes = [];
            selectedNodes = [];
            selectedMembranes = [];
            // Clear results
            resultsDisplacements = null;
            resultsSpringLoads = [];
            resultsReactions = [];
            resultsElementStresses = [];

            clearMeshData(); // Clears FE nodes, elements, springs

            // Reset ID counters
            nextNodeId = 1;
            nextMembraneId = 1;
            feNodeIdCounter = 1;
            feElementIdCounter = 1;
            feSpringIdCounter = 1;

            // Clear Konva Layers (except background)
            geometryLayer?.destroyChildren();
            membraneFillLayer?.destroyChildren();
            meshLayer?.destroyChildren(); // Included in clearMeshData, but safe to repeat
            springLayer?.destroyChildren(); // Included in clearMeshData, but safe to repeat
            stressLayer?.destroyChildren(); // Included in clearMeshData, but safe to repeat
            selectionLayer?.destroyChildren();

            // Redraw background
            const background = backgroundLayer?.findOne('Rect');
            backgroundLayer?.destroyChildren();
            if (background) backgroundLayer?.add(background);

            // Batch draw to apply clearing
            geometryLayer?.batchDraw();
            membraneFillLayer?.batchDraw();
            meshLayer?.batchDraw();
            springLayer?.batchDraw();
            stressLayer?.batchDraw();
            selectionLayer?.batchDraw();
            backgroundLayer?.batchDraw();

            // Update UI displays
            updateSelectionInfo();
            updateMembraneSelectionInfo();
            updateFeSelectionInfo();
            updateSpringPointsInfo();
            updateResultsDisplay();
            setMode('add-node'); // Reset mode
            updateStatus("Model cleared.");
        }

        function createMembraneFromData(id, nodeIds, matE, matNu, matT) {
            const membraneNodes = nodeIds.map(nid => findNodeDataById(nid));
            if (membraneNodes.some(n => !n)) { console.error(`Cannot create membrane ${id}, missing node data.`); return null; }
            const points = membraneNodes.flatMap(n => [n.x, n.y]);
            if (typeof Konva === 'undefined' || !Konva.Line) { console.error("Konva.Line not available."); return null; }

            let membraneFillShape;
            try {
                membraneFillShape = new Konva.Line({ /* ... properties ... */ });
                // --- ADD THIS LINE: ---
                if (membraneFillLayer) {
                    membraneFillLayer.add(membraneFillShape); // Add the shape to the layer here
                } else {
                    console.error("Membrane fill layer not available during membrane creation from data.");
                    // Optional: throw an error or return null earlier if layer doesn't exist
                }
                // --- END ADDED LINE ---
            } catch (error) { /* ... */ return null; }

            const newMembrane = {
                id: id,
                nodeIds: nodeIds,
                konvaShape: membraneFillShape,
                isMeshed: false,
                materialE: matE ?? DEFAULT_MATERIAL_E,
                materialNu: matNu ?? DEFAULT_MATERIAL_NU,
                materialT: matT ?? DEFAULT_MATERIAL_T
            };

            // REMOVE adding to layer here, it's done above now.
            return newMembrane;
        }

        // --- Renamed and Enhanced Redraw Function ---
        function redrawAll() {
            console.log("Redrawing full model state...");
            if (!stage) return; // Needed for scale check
            const scale = stage.scaleX();

            // 1. Clear Layers (visuals only, data is already loaded)
            geometryLayer?.destroyChildren();
            membraneFillLayer?.destroyChildren();
            meshLayer?.destroyChildren();
            springLayer?.destroyChildren();
            stressLayer?.destroyChildren();

            // 2. Redraw Geometry Nodes
            nodes.forEach(node => {
                if (!node.konvaCircle) { // Should not happen if addNode worked, but safety check
                    console.warn(`Node ${node.id} missing konvaCircle on redraw.`);
                    // Try to recreate if necessary (optional)
                    const konvaCircle = new Konva.Circle({
                        x: node.x, y: node.y,
                        radius: NODE_RADIUS_TARGET_PX / scale, // Use scaled radius
                        stroke: 'black',
                        strokeWidth: NODE_STROKE_WIDTH_TARGET_PX, // Target pixel width
                        strokeScaleEnabled: false, // Keep stroke constant
                        draggable: true, id: `node-${node.id}`
                    });
                    node.konvaCircle = konvaCircle;
                    konvaCircle.on('click tap', (e) => { e.cancelBubble = true; handleNodeClick(node); });
                    konvaCircle.on('dragend', () => { /* Add drag logic back if needed */ });
                } else {
                    // Update radius of existing circle
                    node.konvaCircle.radius(NODE_RADIUS_TARGET_PX / scale);
                }
                const isMarked = geometricSpringNodes.includes(node.id);
                node.konvaCircle.fill(isMarked ? SPRING_NODE_COLOR : DEFAULT_NODE_COLOR);
                geometryLayer.add(node.konvaCircle);
            });

            // 3. Redraw Membranes
            membranes.forEach(membrane => {
                if (!membrane.konvaShape) {
                    console.warn(`Membrane ${membrane.id} missing konvaShape on redraw.`);
                    // Try to recreate
                    const points = membrane.nodeIds.map(nid => findNodeDataById(nid)).flatMap(n => [n.x, n.y]);
                    membrane.konvaShape = new Konva.Line({
                        points: points, fill: 'rgba(173, 216, 230, 0.5)',
                        stroke: MEMBRANE_DEFAULT_STROKE,
                        strokeWidth: MEMBRANE_DEFAULT_STROKE_WIDTH, // Target pixel width
                        strokeScaleEnabled: false, // Keep stroke constant
                        closed: true, listening: false, draggable: false, opacity: MEMBRANE_DEFAULT_OPACITY, name: 'membrane'
                    });
                }
                membraneFillLayer.add(membrane.konvaShape);
            });

            // 4. Redraw Mesh (FE Nodes, Elements, BCs)
            drawMesh(); // This function already handles drawing based on global feNodes/feElements

            // 5. Redraw Springs
            drawSprings(); // This function already handles drawing based on global feSprings

            // 6. Batch Draw All Layers
            geometryLayer?.batchDraw();
            membraneFillLayer?.batchDraw();
            meshLayer?.batchDraw();
            springLayer?.batchDraw();
            stressLayer?.visible(false); // Hide stress layer initially after load
            stressLayer?.batchDraw();

            console.log("Finished redrawing full model state.");
        }

        // --- ADDED: drawDeformedMesh --- MOVE THIS UP
        function drawDeformedMesh(displacementVector, scaleFactor) {
            console.log(`Drawing deformed mesh with scale factor: ${scaleFactor}`);
            if (!meshLayer || !displacementVector) return;
            // Clear previous deformed mesh visuals if they exist (e.g., add a name property)
            // Correct way to destroy nodes found by find()
            const oldDeformed = meshLayer.find('.deformed-mesh-element');
            oldDeformed.forEach(node => {
                node.destroy();
            });
            // meshLayer.find('.deformed-mesh-element').destroy(); // Incorrect: find() returns a Collection
            const nodeIndexMap = new Map();
            feNodes.forEach((node, index) => nodeIndexMap.set(node.id, index));

            feElements.forEach(element => {
                if (element.type === 'quad' && element.nodeIds.length === 4) {
                    const deformedPoints = [];
                    let geometryValid = true;
                    element.nodeIds.forEach(nodeId => {
                        const node = findFeNodeById(nodeId);
                        const globalIndex = nodeIndexMap.get(nodeId);
                        if (node && globalIndex !== undefined && (2 * globalIndex + 1) < displacementVector.length) {
                            const dx = displacementVector[2 * globalIndex] * scaleFactor;
                            const dy = displacementVector[2 * globalIndex + 1] * scaleFactor;
                            deformedPoints.push(node.x + dx, node.y + dy);
                        } else {
                            console.warn(`Missing node or displacement data for FE Node ${nodeId} in element ${element.id}`);
                            geometryValid = false;
                        }
                    });

                    if (geometryValid) {
                        const deformedLine = new Konva.Line({
                            points: deformedPoints,
                            stroke: 'rgba(255, 0, 0, 0.7)', // Red for deformed shape
                            strokeWidth: LINE_STROKE_WIDTH_TARGET_PX, // Use target width
                            strokeScaleEnabled: false, // Keep stroke width constant
                            closed: true,
                            listening: false,
                            name: 'deformed-mesh-element' // Name for easy removal
                        });
                        meshLayer.add(deformedLine);
                    }
                }
            });
            meshLayer.batchDraw();
            console.log("Deformed mesh drawn.");
        }

        // --- ADDED: drawStressResults --- MOVE THIS UP
        function drawStressResults(stressData) {
            console.log("Drawing stress results...");
            if (!stressLayer || !stressData || stressData.length === 0) {
                console.log("No stress data to draw or stress layer missing.");
                stressLayer?.destroyChildren(); // Clear if no data
                stressLayer?.visible(false);
                stressLayer?.batchDraw();
                return;
            }
            stressLayer.destroyChildren(); // Clear previous stress results

            let maxStress = 0;
            stressData.forEach(s => { if (s.sigmaVM > maxStress) maxStress = s.sigmaVM; });
            console.log("Max Von Mises Stress:", maxStress.toExponential(3));
            if (maxStress <= 0) maxStress = 1; // Avoid division by zero

            stressData.forEach(data => {
                const element = findFeElementById(data.elementId);
                if (element && element.type === 'quad' && element.nodeIds.length === 4) {
                    const nodeCoords = element.nodeIds.map(id => findFeNodeById(id)).filter(n => n).map(n => ({ x: n.x, y: n.y }));
                    if (nodeCoords.length === 4) {
                        const stressRatio = Math.min(1, Math.max(0, data.sigmaVM / maxStress));
                        const stressColor = `hsl(${240 * (1 - stressRatio)}, 100%, 50%)`; // Blue (low) to Red (high)

                        const elementPolygon = new Konva.Line({
                            points: nodeCoords.flatMap(p => [p.x, p.y]),
                            fill: stressColor,
                            strokeWidth: LINE_STROKE_WIDTH_TARGET_PX, // Target pixel width
                            strokeScaleEnabled: false, // Keep constant pixel width
                            stroke: '#cccccc', // Faint stroke
                            closed: true,
                            listening: false
                        });
                        stressLayer.add(elementPolygon);
                    } else { console.warn(`Could not get all node coordinates for stress plot element ${data.elementId}`); }
                } else { console.warn(`Could not find element ${data.elementId} for stress plot.`); }
            });

            stressLayer.visible(true); // Make sure layer is visible
            stressLayer.batchDraw();
            console.log(`Stress results drawn for ${stressData.length} elements.`);
        }

        // --- ADDED: handleResultsViewChange --- MOVE THIS UP
        function handleResultsViewChange(event) {
            const selectedValue = event ? event.target.value : document.querySelector('input[name="results-view"]:checked')?.value || 'springs';
            console.log("Results view changed to:", selectedValue);

            document.getElementById('results-springs').hidden = (selectedValue !== 'springs');
            document.getElementById('results-reactions').hidden = (selectedValue !== 'reactions');
            document.getElementById('results-stress').hidden = (selectedValue !== 'stress');

            // Toggle visibility of Konva layers
            if (stressLayer) stressLayer.visible(selectedValue === 'stress');
            // Other layers (like mesh, springs) might remain visible or be toggled based on design
            // For now, only explicitly control stress layer visibility here
            stressLayer?.batchDraw();
        }

        // --- Delete Functions ---
        function deleteNode(nodeId) { console.log(`Attempting to delete node ${nodeId}`); const isUsed = membranes.some(m => m.nodeIds.includes(nodeId)); if (isUsed) { alert(`Cannot delete Node ${nodeId} because it is used by one or more membranes. Delete the membrane(s) first.`); updateStatus(`Cannot delete Node ${nodeId}: Used by membrane(s).`); console.warn(`Deletion of node ${nodeId} prevented: used by membrane.`); return; } const springIndex = geometricSpringNodes.indexOf(nodeId); if (springIndex > -1) { geometricSpringNodes.splice(springIndex, 1); updateSpringPointsInfo(); } const nodeIndex = nodes.findIndex(n => n.id === nodeId); if (nodeIndex > -1) { const nodeToRemove = nodes[nodeIndex]; nodeToRemove.konvaCircle?.destroy(); nodes.splice(nodeIndex, 1); console.log(`Node ${nodeId} deleted.`); updateStatus(`Node ${nodeId} deleted.`); geometryLayer?.batchDraw(); updateSelectionInfo(); } else { console.warn(`Node ${nodeId} not found for deletion.`); } }
        /**
         * Deletes a membrane data object and its associated visual shape.
         * Also clears any FE mesh data (nodes, elements, springs) associated
         * specifically with this membrane BEFORE deleting the membrane data.
         *
         * NOTE: This function deletes MEMBRANES. To delete geometric points/nodes,
         * the `deleteNode` function is used (and only works if the node
         * is not part of any existing membrane definition).
         *
         * @param {number} membraneId The ID of the membrane to delete.
         */
        function deleteMembrane(membraneId) {
            console.log(`Attempting to delete membrane ${membraneId}`);
            const memIndex = membranes.findIndex(m => m.id === membraneId);

            if (memIndex > -1) {
                const membraneToRemove = membranes[memIndex];

                // --- Step 1: Clear associated FE data first (if any) ---
                // This is important to do before removing the membrane data itself.
                // clearMeshForSingleMembrane also sets membraneToRemove.isMeshed = false internally.
                if (membraneToRemove.isMeshed) {
                    clearMeshForSingleMembrane(membraneId);
                }

                // --- Step 2: Clean up the Konva visual shape ---
                if (membraneToRemove.konvaShape) {
                    // Try explicitly removing from layer first before destroying,
                    // as suggested by some Konva warnings to help internal cleanup.
                    membraneToRemove.konvaShape.remove();
                    membraneToRemove.konvaShape.destroy();
                    membraneToRemove.konvaShape = null; // Clear the reference in the data object
                }

                // --- Step 3: Remove the membrane data object from the global array ---
                membranes.splice(memIndex, 1);

                // --- Step 4: Update selection state if necessary ---
                // Remove the deleted membrane's ID from the selectedMembranes array if present.
                const selectionIndex = selectedMembranes.indexOf(membraneId);
                if (selectionIndex > -1) {
                    selectedMembranes.splice(selectionIndex, 1);
                }

                // --- Step 5: Update UI and log success ---
                console.log(`Membrane ${membraneId} deleted.`);
                updateStatus(`Membrane ${membraneId} deleted.`);

                // --- Step 6: Redraw layers affected by the deletion ---
                // We need to redraw to reflect the removed shapes and potentially cleared mesh/springs.
                membraneFillLayer?.batchDraw(); // Update membrane visuals (fill is gone)
                meshLayer?.batchDraw();        // Update mesh visuals (elements/nodes might be gone)
                springLayer?.batchDraw();      // Update spring visuals (springs might be gone)
                updateMembraneSelectionInfo(); // Update the list of selected membranes in the UI

            } else {
                // Handle case where membrane ID wasn't found (should generally not happen if called correctly)
                console.warn(`Membrane ${membraneId} not found for deletion.`);
                updateStatus(`Membrane ${membraneId} not found.`); // Optional: Update status
            }
        }
        function clearMeshForSingleMembrane(membraneId) { console.log(`Clearing mesh data for membrane ${membraneId}`); const feNodesToRemove = new Set(); const feElementsToRemove = new Set(); const feSpringsToRemove = new Set(); feNodes.forEach(feN => { if (feN.membraneId === membraneId) { feNodesToRemove.add(feN.id); } }); feElements.forEach(feE => { if (feE.membraneId === membraneId) { feElementsToRemove.add(feE.id); } }); if (feNodesToRemove.size > 0) { feSprings.forEach(feS => { if (feNodesToRemove.has(feS.feNodeId1) || feNodesToRemove.has(feS.feNodeId2)) { feSpringsToRemove.add(feS.id); } }); } const nodeCount = feNodes.length; const elemCount = feElements.length; const springCount = feSprings.length; feNodes = feNodes.filter(feN => !feNodesToRemove.has(feN.id)); feElements = feElements.filter(feE => !feElementsToRemove.has(feE.id)); feSprings = feSprings.filter(feS => !feSpringsToRemove.has(feS.id)); const membrane = findMembraneById(membraneId); if (membrane) membrane.isMeshed = false; console.log(`Removed ${nodeCount - feNodes.length} FE nodes, ${elemCount - feElements.length} FE elements, ${springCount - feSprings.length} FE springs for membrane ${membraneId}.`); }

        // --- Start the application ---
        document.addEventListener('DOMContentLoaded', () => {
            console.log("DOMContentLoaded fired, calling initializeKonva...");
            initializeKonva();
        });

        // --- ADDED: Handler for applying edited node coordinates ---
        function handleApplyNodeCoords() {
            if (editingNodeId === null) {
                console.warn("Apply Node Coords called but no node is being edited.");
                updateStatus("No node selected for coordinate editing.");
                return;
            }

            const nodeToEdit = findNodeDataById(editingNodeId);
            if (!nodeToEdit || !nodeToEdit.konvaCircle) {
                console.error(`Node ${editingNodeId} not found or invalid during coordinate apply.`);
                updateStatus(`Error: Node ${editingNodeId} data missing.`);
                editingNodeId = null; // Reset state
                return;
            }

            const xInput = document.getElementById('edit-node-x-input');
            const yInput = document.getElementById('edit-node-y-input');
            const newX = parseFloat(xInput?.value);
            const newY = parseFloat(yInput?.value);

            if (isNaN(newX) || isNaN(newY)) {
                alert("Invalid coordinates. Please enter numeric values for X and Y.");
                updateStatus("Error: Invalid coordinate values entered.");
                return;
            }

            console.log(`Applying new coordinates (${newX.toFixed(3)}, ${newY.toFixed(3)}) to Node ${editingNodeId}`);

            // Update node data
            nodeToEdit.x = newX;
            nodeToEdit.y = newY;

            // Update Konva shape position
            nodeToEdit.konvaCircle.position({ x: newX, y: newY });

            // Update connected elements
            updateConnectedMembranes(editingNodeId);
            clearMeshForAffectedMembranes(editingNodeId); // Clear mesh data if node moved

            // Redraw layers
            geometryLayer?.batchDraw();
            membraneFillLayer?.batchDraw();
            drawMesh();    // Redraw mesh layer (needed if mesh was cleared)
            drawSprings(); // Redraw springs layer

            updateStatus(`Node ${editingNodeId} coordinates updated.`);

            // Optional: Hide input area and reset state after applying
            // const inputArea = document.getElementById('edit-node-coords-input-area');
            // if (inputArea) inputArea.hidden = true;
            // editingNodeId = null;
            // setMode('add-node'); // Or stay in edit mode? User preference. Currently stays.
        }
        // --- End Added Function ---

        // --- MOVED: Function to update the results text areas ---
        function updateResultsDisplay() {
            const springsDiv = document.getElementById('results-springs')?.querySelector('pre');
            const reactionsDiv = document.getElementById('results-reactions')?.querySelector('pre');
            const stressDiv = document.getElementById('results-stress')?.querySelector('pre');

            if (springsDiv) {
                if (resultsSpringLoads === null || resultsSpringLoads.length === 0) {
                    springsDiv.textContent = "Not run yet or no springs.";
                } else {
                    springsDiv.textContent = resultsSpringLoads.map(r => `Spring ${r.id}: Fx=${r.fx}, Fy=${r.fy}`).join('\n');
                }
            }
            if (reactionsDiv) {
                if (resultsReactions === null || resultsReactions.length === 0) {
                    reactionsDiv.textContent = "Not run yet or no reactions.";
                } else {
                    reactionsDiv.textContent = resultsReactions.map(r => `Node ${r.feNodeId}: Rx=${r.rx}, Ry=${r.ry}`).join('\n');
                }
            }
            if (stressDiv) {
                if (resultsElementStresses === null || resultsElementStresses.length === 0) {
                    stressDiv.textContent = "Not run yet or no elements.";
                } else {
                    // Display only Von Mises for brevity in the preview
                    stressDiv.textContent = resultsElementStresses.map(r => `Elem ${r.elementId}: VM=${Number(r.sigmaVM).toExponential(3)}`).join('\n');
                }
            }
        }

        // --- FEA Calculations ---
        function zeros(rows, cols) { return Array(rows).fill(0).map(() => Array(cols).fill(0)); }

    </script>

</body>

</html>