<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=20.0">
    <title>2D Membrane FEA Tool</title>
    <!-- Add defer attribute to library scripts -->
    <script defer src="https://cdn.jsdelivr.net/npm/konva@9.3.6/konva.min.js"
        onerror="console.error('FATAL: Failed to load Konva!')"></script>
    <!-- RE-ADD math.js script tag -->
    <script defer src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/12.4.1/math.min.js"
        onerror="console.error('FATAL: Failed to load Math.js!')"></script>

    <!-- Tailwind might not need defer, but can add for consistency -->
    <script defer src="https://cdn.tailwindcss.com" onerror="console.error('FATAL: Failed to load Tailwind!')"></script>
    <style>
        /* Basic styling */
        body {
            font-family: 'Inter', sans-serif;
        }

        /* ... rest of styles ... */
    </style>
</head>

<body class="bg-gray-100 p-4">

    <h1 class="text-2xl font-bold mb-4 text-center text-gray-800">2D Membrane FEA Tool</h1>

    <div class="flex flex-col md:flex-row gap-4">
        <div class="w-full md:w-1/4 bg-white p-4 rounded-lg shadow overflow-y-auto max-h-[90vh]">
            <h2 class="text-lg font-semibold mb-3 border-b pb-2">Controls - Modes</h2>
            <!-- Modified Controls Section -->

            <!-- Membrane Creation Panel -->
            <div class="mb-4 border-b pb-4">
                <h3 class="text-sm font-semibold mb-2 text-gray-700">New Membrane</h3>
                <div class="grid grid-cols-2 gap-2 mb-2">
                    <div>
                        <label class="block text-xs text-gray-600">Origin X</label>
                        <input type="number" id="new-mem-x" value="0" class="w-full border rounded px-1 py-0.5 text-sm">
                    </div>
                    <div>
                        <label class="block text-xs text-gray-600">Origin Y</label>
                        <input type="number" id="new-mem-y" value="0" class="w-full border rounded px-1 py-0.5 text-sm">
                    </div>
                    <div>
                        <label class="block text-xs text-gray-600">Length (X)</label>
                        <input type="number" id="new-mem-w" value="100"
                            class="w-full border rounded px-1 py-0.5 text-sm">
                    </div>
                    <div>
                        <label class="block text-xs text-gray-600">Width (Y)</label>
                        <input type="number" id="new-mem-h" value="50"
                            class="w-full border rounded px-1 py-0.5 text-sm">
                    </div>
                </div>
                <button id="btn-create-parametric-membrane"
                    class="w-full bg-blue-600 hover:bg-blue-700 text-white font-semibold py-1.5 px-3 rounded text-sm shadow-sm transition">
                    Create Membrane
                </button>
            </div>

            <!-- Spring Grid Creation Panel -->
            <div class="mb-4 border-b pb-4">
                <h3 class="text-sm font-semibold mb-2 text-gray-700">New Spring Grid</h3>
                <div class="grid grid-cols-2 gap-2 mb-2">
                    <div>
                        <label class="block text-xs text-gray-600">Origin X</label>
                        <input type="number" id="spring-grid-x" value="0"
                            class="w-full border rounded px-1 py-0.5 text-sm">
                    </div>
                    <div>
                        <label class="block text-xs text-gray-600">Origin Y</label>
                        <input type="number" id="spring-grid-y" value="0"
                            class="w-full border rounded px-1 py-0.5 text-sm">
                    </div>
                    <div>
                        <label class="block text-xs text-gray-600">Width</label>
                        <input type="number" id="spring-grid-w" value="100"
                            class="w-full border rounded px-1 py-0.5 text-sm">
                    </div>
                    <div>
                        <label class="block text-xs text-gray-600">Height</label>
                        <input type="number" id="spring-grid-h" value="50"
                            class="w-full border rounded px-1 py-0.5 text-sm">
                    </div>
                    <div>
                        <label class="block text-xs text-gray-600">Count X</label>
                        <input type="number" id="spring-grid-nx" value="5" min="2"
                            class="w-full border rounded px-1 py-0.5 text-sm">
                    </div>
                    <div>
                        <label class="block text-xs text-gray-600">Count Y</label>
                        <input type="number" id="spring-grid-ny" value="3" min="2"
                            class="w-full border rounded px-1 py-0.5 text-sm">
                    </div>
                </div>
                <button id="btn-create-parametric-springs"
                    class="w-full bg-purple-600 hover:bg-purple-700 text-white font-semibold py-1.5 px-3 rounded text-sm shadow-sm transition">
                    Create Spring Grid
                </button>
            </div>

            <!-- Selection Modes -->
            <h3 class="text-sm font-semibold mb-2 text-gray-700">Selection / Edit</h3>
            <!-- Moved Select Geo Node out or kept? Prompt: "Remove the ability to define individual grid points". Selecting them for MEMBRANE definition is gone. Selecting them for DELETION? Maybe. -->
            <!-- Prompt says "Selection of membranes for meshing should be left as it is" -->

            <button id="btn-select-membrane"
                class="bg-blue-600 hover:bg-blue-700 text-white font-semibold py-1.5 px-3 rounded-lg shadow-sm hover:shadow transition duration-150 ease-in-out mb-2 w-full text-left disabled:opacity-50 disabled:cursor-not-allowed">Mode:
                Select Membrane</button>
            <button id="btn-mode-select-fe-box"
                class="bg-blue-500 hover:bg-blue-600 text-white font-semibold py-1.5 px-3 rounded-lg shadow-sm hover:shadow transition duration-150 ease-in-out mb-2 w-full text-left">Mode:
                Select Nodes (Box)</button>
            <button id="btn-mode-select-element-box"
                class="bg-blue-500 hover:bg-blue-600 text-white font-semibold py-1.5 px-3 rounded-lg shadow-sm hover:shadow transition duration-150 ease-in-out mb-2 w-full text-left">Mode:
                Select Elements (Box)</button>
            <button id="btn-mode-select-springs-box"
                class="bg-blue-500 hover:bg-blue-600 text-white font-semibold py-1.5 px-3 rounded-lg shadow-sm hover:shadow transition duration-150 ease-in-out mb-2 w-full text-left">Mode:
                Select Springs (Box)</button>
            <button id="btn-mode-select-fe-element"
                class="bg-blue-500 hover:bg-blue-600 text-white font-semibold py-1.5 px-3 rounded-lg shadow-sm hover:shadow transition duration-150 ease-in-out mb-2 w-full text-left"
                hidden>Mode:
                Select Element (One)</button>
            <button id="btn-mode-delete"
                class="bg-red-500 hover:bg-red-600 text-white font-semibold py-1.5 px-3 rounded-lg shadow-sm hover:shadow transition duration-150 ease-in-out mb-2 w-full text-left">Mode:
                Delete Item</button>
            <button id="btn-mode-edit-node"
                class="bg-blue-500 hover:bg-blue-600 text-white font-semibold py-1.5 px-3 rounded-lg shadow-sm hover:shadow transition duration-150 ease-in-out mb-2 w-full text-left">Mode:
                Edit Node Coords</button>

            <!-- Edit Node Input Area -->
            <div id="edit-node-coords-input-area" class="p-3 my-2 border border-gray-200 rounded bg-gray-50" hidden>
                <h4 class="text-md font-semibold mb-2">Edit Coordinates</h4>
                <p class="text-sm mb-2">Node ID: <span id="edit-node-id-display" class="font-mono">N/A</span></p>
                <label for="edit-node-x-input" class="block text-sm font-medium text-gray-700 mb-1">New X:</label>
                <input type="number" id="edit-node-x-input" step="any"
                    class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm py-1 px-2 font-mono">
                <label for="edit-node-y-input" class="mt-2 block text-sm font-medium text-gray-700 mb-1">New
                    Y:</label>
                <input type="number" id="edit-node-y-input" step="any"
                    class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm py-1 px-2 font-mono">
                <button id="btn-apply-node-coords"
                    class="mt-3 w-full bg-indigo-600 hover:bg-indigo-700 text-white font-semibold py-1.5 px-3 rounded-lg shadow-sm hover:shadow">Apply
                    Coordinates</button>
            </div>
            <!-- End parent div for mode buttons (removed premature close) -->
            <hr class="my-3 border-gray-300">

            <!-- Model Tree -->
            <div id="model-explorer" class="mb-4 border-t pt-4">
                <h3 class="text-sm font-semibold mb-2 text-gray-700">Model Explorer</h3>
                <div id="model-tree-list"
                    class="text-xs text-gray-600 max-h-32 overflow-y-auto bg-gray-50 p-2 rounded border mb-2">
                    <p class="text-gray-500 italic">No membranes.</p>
                </div>
                <h4 class="text-xs font-semibold mb-1 text-gray-700">Spring Groups</h4>
                <div id="spring-group-list"
                    class="text-xs text-gray-600 max-h-32 overflow-y-auto bg-gray-50 p-2 rounded border">
                    <p class="text-gray-500 italic">No spring groups.</p>
                </div>
            </div>


            <h2 class="text-lg font-semibold mb-3 border-b pb-2">Process</h2>
            <div class="space-y-2">
                <!-- Removed btn-add-membrane (replaced by parametric input above) -->
                <button id="btn-mesh-membranes"
                    class="bg-blue-600 hover:bg-blue-700 text-white font-semibold py-1.5 px-3 rounded-lg shadow-sm hover:shadow transition duration-150 ease-in-out mb-2 w-full text-left disabled:opacity-50 disabled:cursor-not-allowed">Mesh
                    Selected Membranes</button>
                <div id="mesh-input-area" class="p-3 my-2 border border-gray-200 rounded bg-gray-50" hidden>
                    <!-- Input Area Style -->
                    <label for="mesh-m-input" class="block text-sm font-medium text-gray-700 mb-1">Divisions M
                        (X-dir):</label><input type="number" id="mesh-m-input" name="mesh-m" min="1" value="4"
                        class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm py-1 px-2 font-mono">
                    <label for="mesh-n-input" class="mt-2 block text-sm font-medium text-gray-700 mb-1">Divisions N
                        (Y-dir):</label><input type="number" id="mesh-n-input" name="mesh-n" min="1" value="3"
                        class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm py-1 px-2 font-mono">
                    <button id="btn-confirm-mesh"
                        class="mt-3 w-full bg-indigo-600 hover:bg-indigo-700 text-white font-semibold py-1.5 px-3 rounded-lg shadow-sm hover:shadow">Confirm
                        Mesh</button> <!-- Input Area Button Style -->
                </div>
                <button id="btn-add-spring"
                    class="bg-blue-600 hover:bg-blue-700 text-white font-semibold py-1.5 px-3 rounded-lg shadow-sm hover:shadow transition duration-150 ease-in-out mb-2 w-full text-left disabled:opacity-50 disabled:cursor-not-allowed">Create
                    Springs</button>
                <div id="spring-input-area" class="p-3 my-2 border border-gray-200 rounded bg-gray-50" hidden>
                    <!-- Input Area Style -->
                    <label for="spring-k-input" class="block text-sm font-medium text-gray-700 mb-1">Stiffness
                        (k):</label><input type="number" id="spring-k-input" name="spring-k" min="0" step="any"
                        value="1000"
                        class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm py-1 px-2 font-mono">
                    <button id="btn-confirm-springs"
                        class="mt-3 w-full bg-indigo-600 hover:bg-indigo-700 text-white font-semibold py-1.5 px-3 rounded-lg shadow-sm hover:shadow">Confirm
                        Springs</button> <!-- Input Area Button Style -->
                </div>
                <hr class="my-2 border-gray-300">
                <div id="bc-input-area" class="p-3 my-2 border border-gray-200 rounded bg-gray-50" hidden>
                    <!-- Input Area Style -->
                    <h4 class="text-md font-semibold mb-2">Apply Boundary Condition</h4>
                    <label for="bc-type-select" class="block text-sm font-medium text-gray-700 mb-1">Type:</label>
                    <select id="bc-type-select" name="bc-type"
                        class="mb-2 mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm py-1 px-2 font-mono">
                        <option value="none">None (Clear BC)</option>
                        <option value="fixed">Fixed Displacement</option>
                        <option value="enforced">Enforced Displacement</option>
                        <option value="load">Nodal Load</option>
                    </select>
                    <div id="bc-fixed-options" class="sub-options mt-2 pl-3 border-l-2 border-gray-200" hidden> <label
                            class="block text-sm font-medium text-gray-700 mb-1"><input type="checkbox" id="bc-fix-x"
                                class="h-4 w-4 text-indigo-600 border-gray-300 rounded focus:ring-indigo-500 mr-2"> Fix
                            X</label><br> <label class="block text-sm font-medium text-gray-700 mb-1"><input
                                type="checkbox" id="bc-fix-y"
                                class="h-4 w-4 text-indigo-600 border-gray-300 rounded focus:ring-indigo-500 mr-2"> Fix
                            Y</label> </div>
                    <div id="bc-enforced-options" class="sub-options mt-2 pl-3 border-l-2 border-gray-200" hidden>
                        <label class="block text-sm font-medium text-gray-700 mb-1"><input type="checkbox"
                                id="bc-enforce-x"
                                class="h-4 w-4 text-indigo-600 border-gray-300 rounded focus:ring-indigo-500 mr-2">
                            Enforce X:</label> <input type="number" id="bc-dx-input" step="any" placeholder="Dx value"
                            class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm py-1 px-2 font-mono">
                        <label class="mt-2 block text-sm font-medium text-gray-700 mb-1"><input type="checkbox"
                                id="bc-enforce-y"
                                class="h-4 w-4 text-indigo-600 border-gray-300 rounded focus:ring-indigo-500 mr-2">
                            Enforce Y:</label> <input type="number" id="bc-dy-input" step="any" placeholder="Dy value"
                            class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm py-1 px-2 font-mono">
                    </div>
                    <div id="bc-load-options" class="sub-options mt-2 pl-3 border-l-2 border-gray-200" hidden> <label
                            for="bc-fx-input" class="block text-sm font-medium text-gray-700 mb-1">Load Fx:</label>
                        <input type="number" id="bc-fx-input" step="any" placeholder="Fx value"
                            class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm py-1 px-2 font-mono">
                        <label for="bc-fy-input" class="mt-2 block text-sm font-medium text-gray-700 mb-1">Load
                            Fy:</label> <input type="number" id="bc-fy-input" step="any" placeholder="Fy value"
                            class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm py-1 px-2 font-mono">
                    </div>
                    <button id="btn-apply-bc-confirm"
                        class="mt-3 w-full bg-indigo-600 hover:bg-indigo-700 text-white font-semibold py-1.5 px-3 rounded-lg shadow-sm hover:shadow">Apply
                        BC to Selected</button> <!-- Input Area Button Style -->
                </div>
                <hr class="my-2 border-gray-300">
                <!-- ADDED New Per-Membrane Material Properties Area (initially hidden) -->
                <div id="membrane-material-input-area" class="p-3 my-2 border border-gray-200 rounded bg-gray-50"
                    hidden>
                    <h4 class="text-md font-semibold mb-2">Material Properties (Selected Membranes)</h4>
                    <p id="material-note" class="text-xs text-gray-500 mb-2 italic"></p>
                    <label for="mem-mat-prop-e" class="block text-sm font-medium text-gray-700 mb-1">Young's Modulus
                        (E):</label>
                    <input type="number" id="mem-mat-prop-e" value="10.5e6"
                        class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm py-1 px-2 font-mono">
                    <label for="mem-mat-prop-nu" class="mt-2 block text-sm font-medium text-gray-700 mb-1">Poisson's
                        Ratio (nu):</label>
                    <input type="number" id="mem-mat-prop-nu" step="0.01" min="0" max="0.5" value="0.3"
                        class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm py-1 px-2 font-mono">
                    <label for="mem-mat-prop-t" class="mt-2 block text-sm font-medium text-gray-700 mb-1">Thickness
                        (t):</label>
                    <input type="number" id="mem-mat-prop-t" min="0" value="0.05"
                        class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm py-1 px-2 font-mono">
                    <button id="btn-apply-material"
                        class="mt-3 w-full bg-indigo-600 hover:bg-indigo-700 text-white font-semibold py-1.5 px-3 rounded-lg shadow-sm hover:shadow">Apply
                        Properties to Selected</button>
                </div>

                <!-- NEW: Element Property Area -->
                <div id="element-properties-area" class="p-3 my-2 border border-blue-200 rounded bg-blue-50" hidden>
                    <h4 class="text-md font-semibold mb-2 text-blue-900">Element Properties</h4>
                    <p id="element-note" class="text-xs text-gray-600 mb-2 italic">ID: <span id="el-prop-id"></span></p>

                    <label for="el-prop-e" class="block text-sm font-medium text-gray-700 mb-1">E (Override):</label>
                    <div class="flex gap-2">
                        <input type="number" id="el-prop-e" placeholder="Inherit"
                            class="block w-full rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500 sm:text-sm py-1 px-2 font-mono">
                        <button id="btn-clear-el-e" class="text-xs bg-gray-200 hover:bg-gray-300 px-2 rounded"
                            title="Reset to Inherit">X</button>
                    </div>

                    <label for="el-prop-nu" class="mt-2 block text-sm font-medium text-gray-700 mb-1">Nu
                        (Override):</label>
                    <div class="flex gap-2">
                        <input type="number" id="el-prop-nu" placeholder="Inherit" step="0.01"
                            class="block w-full rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500 sm:text-sm py-1 px-2 font-mono">
                        <button id="btn-clear-el-nu" class="text-xs bg-gray-200 hover:bg-gray-300 px-2 rounded"
                            title="Reset to Inherit">X</button>
                    </div>

                    <label for="el-prop-t" class="mt-2 block text-sm font-medium text-gray-700 mb-1">Thickness
                        (Override):</label>
                    <div class="flex gap-2">
                        <input type="number" id="el-prop-t" placeholder="Inherit" step="any"
                            class="block w-full rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500 sm:text-sm py-1 px-2 font-mono">
                        <button id="btn-clear-el-t" class="text-xs bg-gray-200 hover:bg-gray-300 px-2 rounded"
                            title="Reset to Inherit">X</button>
                    </div>

                    <div id="el-stress-display" class="mt-3 pt-2 border-t border-blue-200 text-xs text-blue-800" hidden>
                        <strong>Stresses:</strong><br>
                        <span class="inline-block w-16">SX:</span> <span id="el-stress-sx"
                            class="font-mono">N/A</span><br>
                        <span class="inline-block w-16">SY:</span> <span id="el-stress-sy"
                            class="font-mono">N/A</span><br>
                        <span class="inline-block w-16">SXY:</span> <span id="el-stress-sxy"
                            class="font-mono">N/A</span><br>
                        <span class="inline-block w-16">SE (VM):</span> <span id="el-stress-vm"
                            class="font-mono">N/A</span>
                        <div id="el-stress-note" class="text-gray-500 italic mt-1" hidden></div>
                    </div>

                    <button id="btn-apply-element-props"
                        class="mt-3 w-full bg-blue-600 hover:bg-blue-700 text-white font-semibold py-1.5 px-3 rounded-lg shadow-sm hover:shadow">Apply
                        to Selected</button>

                    <button id="btn-delete-selected-elements"
                        class="mt-2 w-full bg-red-600 hover:bg-red-700 text-white font-semibold py-1.5 px-3 rounded-lg shadow-sm hover:shadow">Delete
                        Selected Elements</button>
                </div>

                <!-- Spring Property Area -->
                <div id="spring-properties-area" class="p-3 my-2 border border-green-200 rounded bg-green-50" hidden>
                    <h4 class="text-md font-semibold mb-2 text-green-900">Spring Properties</h4>
                    <p id="spring-select-note" class="text-xs text-gray-600 mb-2 italic">Selected: <span
                            id="spring-sel-count">0</span></p>

                    <label for="spring-prop-k" class="block text-sm font-medium text-gray-700 mb-1">Stiffness
                        (k):</label>
                    <input type="number" id="spring-prop-k" placeholder="1000"
                        class="block w-full rounded-md border-gray-300 shadow-sm focus:border-green-500 focus:ring-green-500 sm:text-sm py-1 px-2 font-mono">

                    <button id="btn-update-springs"
                        class="mt-2 w-full bg-green-600 hover:bg-green-700 text-white font-semibold py-1.5 px-3 rounded-lg shadow-sm hover:shadow">Update
                        Selected</button>

                    <button id="btn-delete-springs"
                        class="mt-4 w-full bg-red-500 hover:bg-red-600 text-white font-semibold py-1.5 px-3 rounded-lg shadow-sm hover:shadow">Delete
                        Selected</button>
                </div>
            </div>

            <hr class="my-2 border-gray-300">
            <!-- Note: Special background colors for Solve/Save/Load are handled via !important utilities or specific JS -->
            <button id="btn-solve"
                class="bg-red-600 hover:bg-red-700 text-white font-semibold py-1.5 px-3 rounded-lg shadow-sm hover:shadow transition duration-150 ease-in-out mb-2 w-full text-left disabled:opacity-50 disabled:cursor-not-allowed">Run
                Analysis</button>
            <hr class="my-3 border-gray-300">
            <h2 class="text-lg font-semibold mb-3 border-b pb-2">Save / Load</h2>
            <div class="space-y-2">
                <button id="btn-save-model"
                    class="bg-gray-600 hover:bg-gray-700 text-white font-semibold py-1.5 px-3 rounded-lg shadow-sm hover:shadow transition duration-150 ease-in-out mb-2 w-full text-left disabled:opacity-50 disabled:cursor-not-allowed">Save
                    Model (Copy JSON)</button>
                <div id="load-model-area" class="p-3 my-2 border border-gray-200 rounded bg-gray-50">
                    <!-- Input Area Style -->
                    <label for="load-textarea" class="block text-sm font-medium text-gray-700 mb-1">Paste Model JSON
                        here:</label>
                    <textarea id="load-textarea" rows="4"
                        class="text-xs mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm py-1 px-2 font-mono"></textarea>
                    <button id="btn-load-text"
                        class="mt-3 w-full bg-gray-600 hover:bg-gray-700 text-white font-semibold py-1.5 px-3 rounded-lg shadow-sm hover:shadow">Load
                        from Text</button> <!-- Special Button Style -->
                </div>
            </div>
            <!-- End of Controls Section (div removed to include Results in Sidebar) -->
            <!-- Added Tailwind classes directly to Results Area elements -->
            <div class="results-area mt-4 pt-4 border-t">
                <h3 class="text-md font-semibold mb-2">Selected Geo Nodes</h3>
                <div id="selection-info"
                    class="text-sm text-gray-600 h-16 overflow-y-auto bg-gray-50 p-2 rounded border">
                    None.</div>
            </div>
            <div class="results-area mt-4 pt-4 border-t">
                <h3 class="text-md font-semibold mb-2">Selected Membranes</h3>
                <div id="membrane-selection-info"
                    class="text-sm text-gray-600 h-16 overflow-y-auto bg-gray-50 p-2 rounded border">None.</div>
            </div>
            <div id="results-area mt-4 pt-4 border-t">
                <h3 class="text-md font-semibold mb-2">Selected Elements</h3>
                <div id="element-selection-info"
                    class="text-sm text-gray-600 h-16 overflow-y-auto bg-gray-50 p-2 rounded border">None.</div>
            </div>
            <div class="results-area mt-4 pt-4 border-t">
                <h3 class="text-md font-semibold mb-2">Selected FE Nodes</h3>
                <div id="fe-selection-info"
                    class="text-sm text-gray-600 h-16 overflow-y-auto bg-gray-50 p-2 rounded border">None.</div>
            </div>
            <div class="results-area mt-4 pt-4 border-t">
                <h3 class="text-md font-semibold mb-2">Marked Spring Points</h3>
                <div id="spring-points-info"
                    class="text-sm text-gray-600 h-16 overflow-y-auto bg-gray-50 p-2 rounded border">None.</div>
            </div>

            <div class="results-area mt-4 pt-4 border-t">
                <h3 class="text-md font-semibold mb-2">Analysis Results</h3>
                <div class="results-toggle mb-2">
                    <label class="mr-4 text-sm cursor-pointer"><input type="radio" name="results-view" value="springs"
                            id="radio-view-springs" checked class="mr-1 cursor-pointer"> Springs</label>
                    <label class="mr-4 text-sm cursor-pointer"><input type="radio" name="results-view" value="reactions"
                            id="radio-view-reactions" class="mr-1 cursor-pointer"> Reactions</label>
                    <label class="inline-flex items-center">
                        <input type="radio" name="results-view" value="stress" id="radio-view-stress"
                            class="form-radio text-indigo-600 cursor-pointer">
                        <span class="ml-2">Stresses</span>
                        <select id="stress-type-select" class="ml-2 text-xs border border-gray-300 rounded px-1 py-0.5"
                            hidden>
                            <option value="sigmaVM">Von Mises (SE)</option>
                            <option value="sxx">Stress X (SX)</option>
                            <option value="syy">Stress Y (SY)</option>
                            <option value="sxy">Shear XY (SXY)</option>
                        </select>
                    </label>
                </div>
            </div>
            <div id="results-springs" class="results-content">
                <h4>Spring Loads:</h4>
                <pre
                    class="text-xs bg-gray-100 p-2 rounded border h-20 overflow-y-auto whitespace-pre-wrap">Not run yet.</pre>
            </div>
            <div id="results-reactions" class="results-content" hidden>
                <h4>Reaction Forces:</h4>
                <pre
                    class="text-xs bg-gray-100 p-2 rounded border h-20 overflow-y-auto whitespace-pre-wrap">Not run yet.</pre>
            </div>
            <div id="results-stress" class="results-content" hidden>
                <h4>Membrane Stresses (Von Mises):</h4>
                <pre
                    class="text-xs bg-gray-100 p-2 rounded border h-20 overflow-y-auto whitespace-pre-wrap">Not run yet.</pre>
            </div>
        </div>



        <div class="w-full md:w-3/4 relative">
            <div id="container" class="w-full h-[800px] bg-white rounded-lg shadow" style="min-height: 800px;"></div>
            <!-- Stress Legend Overlay -->
            <div id="stress-legend"
                class="absolute top-4 right-4 bg-white/90 p-2 rounded shadow border border-gray-300 pointer-events-none"
                hidden>
                <h4 id="legend-title" class="text-xs font-bold text-center mb-1">Stress (psi)</h4>
                <div class="flex flex-row items-center gap-2">
                    <!-- Gradient Bar -->
                    <div id="legend-gradient" class="w-4 h-32 border border-gray-400"
                        style="background: linear-gradient(to bottom, red, blue);"></div>
                    <!-- Labels -->
                    <div class="flex flex-col justify-between h-32 text-xs font-mono">
                        <span id="legend-max">Max</span>
                        <span id="legend-mid">Mid</span>
                        <span id="legend-min">Min</span>
                    </div>
                </div>
            </div>
            <div class="mt-4 pt-4 border-t">
                <h3 class="text-md font-semibold mb-2">Status</h3>
                <div id="status-message" class="text-sm text-blue-700"> Initializing... </div>
            </div>
        </div>
    </div>

    <script>
        console.log("Script block started.");

        // --- Global Variables ---
        let stage;
        let backgroundLayer, membraneFillLayer, meshLayer, springLayer, geometryLayer, selectionLayer, stressLayer;
        let currentMode = 'select-membrane';
        // --- ADDED state for editing node coords ---
        let editingNodeId = null;
        let nodes = [], membranes = [], selectedNodes = [], selectedMembranes = [], geometricSpringNodes = [];
        let feNodes = []; // { id, x, y, bc: { type, ... } }
        let feElements = []; // { id, type: 'quad', nodeIds: [], materialE, materialNu, materialT, ... }
        let feSprings = [];  // { id, feNodeId1, feNodeId2, stiffness }
        let selectedFeNodes = []; // Array of FE Node IDs
        let selectedFeSprings = []; // Array of FE Spring IDs
        let selectedFeElements = []; // New selection array for elements
        let resultsDisplacements = null; // Store d vector
        let resultsSpringLoads = []; // Store spring loads
        let resultsReactions = []; // Store reaction forces
        let resultsElementStresses = []; // Store stresses
        let isSelectingBox = false;
        let selectionBoxStart = null;
        let selectionRect = null;
        let nextNodeId = 1, nextMembraneId = 1, feNodeIdCounter = 1, feElementIdCounter = 1, feSpringIdCounter = 1;
        // --- REMOVED Global Material Variables ---
        // let resultsDisplacements = null; let resultsSpringLoads = []; let resultsReactions = []; let resultsElementStresses = []; // These are now declared above

        // --- ADDED Default Material Constants ---
        const DEFAULT_MATERIAL_E = 10.5e6;
        const DEFAULT_MATERIAL_NU = 0.3;
        const DEFAULT_MATERIAL_T = 0.05;

        const DEFAULT_NODE_COLOR = 'red', SPRING_NODE_COLOR = 'purple', FE_NODE_COLOR = 'blue', FE_NODE_SELECTED_COLOR = 'orange';
        // --- Define Target Pixel Sizes ---
        const NODE_RADIUS_TARGET_PX = 6;
        const NODE_STROKE_WIDTH_TARGET_PX = 1;
        const FE_NODE_RADIUS_TARGET_PX = 2;
        const FE_NODE_SELECTED_RADIUS_TARGET_PX = 3.5;
        // --- Reduced target line width ---
        const LINE_STROKE_WIDTH_TARGET_PX = 0.75; // For mesh, springs, etc.
        const BC_SYMBOL_SIZE_TARGET_PX = 12; // Size of arrow/triangle
        const BC_SYMBOL_OFFSET_TARGET_PX = 4; // Offset from node
        const SELECTION_BOX_COLOR = 'rgba(0, 0, 255, 0.2)';

        const SPRING_SELECTED_COLOR = 'cyan'; // Color for selected springs
        const SPRING_SELECTED_WIDTH_PX = 3;   // Width for selected springs

        // --- Fixed Pixel Size/Offset Constants for Spring Labels ---
        const SPRING_LABEL_FIXED_FONT_SIZE = 7; // Font size in screen pixels (reduced from 12)
        const SPRING_LABEL_SCREEN_OFFSET_X = 15; // Horizontal offset in screen pixels
        const SPRING_LABEL_SCREEN_OFFSET_Y = 15; // Vertical offset in screen pixels
        const FE_NODE_RADIUS = 2, FE_NODE_SELECTED_RADIUS = 3.5; // REMOVE these old constants
        const MESH_LINE_COLOR = '#999999', SPRING_LINE_COLOR = 'green', SPRING_LABEL_COLOR = 'darkgreen';
        const MEMBRANE_DEFAULT_OPACITY = 0.5, MEMBRANE_SELECTED_OPACITY = 0.8;
        const MEMBRANE_DEFAULT_STROKE = 'blue', MEMBRANE_SELECTED_STROKE = 'orange';
        // --- Reduced selected membrane stroke width ---
        const MEMBRANE_DEFAULT_STROKE_WIDTH = 1, MEMBRANE_SELECTED_STROKE_WIDTH = 1.5;
        const SPRING_CONN_TOLERANCE_SQ = 4.0;
        // const SELECTION_BOX_COLOR = 'rgba(0, 123, 255, 0.3)'; // Moved up
        const SPRING_RESULT_LABEL_OFFSET_PX = 6; // Offset in pixels from node center (adjust as needed)

        // --- NEW: Spring Point Groups Data ---
        let springPointGroups = []; // Array of { id: number, name: string, nodeIds: [], isSelected: boolean }
        let nextSpringGroupId = 1;

        // --- Function Definitions ---

        // --- NEW: Orphan Node Cleanup ---
        function cleanupOrphanFeNodes() {
            // Find all Node IDs currently used by elements
            const usedNodeIds = new Set();
            feElements.forEach(el => {
                el.nodeIds.forEach(nid => usedNodeIds.add(nid));
            });
            // Also keep nodes that are part of springs
            feSprings.forEach(s => {
                usedNodeIds.add(s.feNodeId1);
                usedNodeIds.add(s.feNodeId2);
            });
            // Also keep nodes that have BCs
            feNodes.forEach(node => {
                if (node.bc && node.bc.type !== 'none') {
                    usedNodeIds.add(node.id);
                }
            });


            const initialCount = feNodes.length;
            feNodes = feNodes.filter(node => usedNodeIds.has(node.id));

            if (feNodes.length < initialCount) {
                console.log(`Cleaned up ${initialCount - feNodes.length} orphan FE nodes.`);
                // Update selection if deleted nodes were selected
                selectedFeNodes = selectedFeNodes.filter(id => feNodes.find(n => n.id === id));
                updateFeSelectionInfo();
            }
        }


        // --- Moved UI Update Functions Higher ---
        function updateStatus(message) { const statusElement = document.getElementById('status-message'); if (statusElement) { statusElement.textContent = message; } else { console.warn("Status message element not found."); } }
        function updateSelectionInfo() { const infoDiv = document.getElementById('selection-info'); if (!infoDiv) return; if (selectedNodes.length === 0) { infoDiv.textContent = 'None.'; } else { infoDiv.innerHTML = `Node IDs (${selectedNodes.length}):<br>`; selectedNodes.forEach((node, index) => { if (node && typeof node.id !== 'undefined') { infoDiv.innerHTML += `${index + 1}. ${node.id} <br>`; } else { infoDiv.innerHTML += `${index + 1}. ? <br>`; console.error("Error displaying node data:", node); } }); } }
        function updateSpringPointsInfo() { const infoDiv = document.getElementById('spring-points-info'); if (!infoDiv) return; if (geometricSpringNodes.length === 0) { infoDiv.textContent = 'None.'; } else { infoDiv.innerHTML = `Node IDs: ${geometricSpringNodes.join(', ')}`; } }
        // --- REPLACED: updateMembraneSelectionInfo to also update Model Tree ---
        function updateMembraneSelectionInfo() {
            const infoDiv = document.getElementById('membrane-selection-info');
            if (infoDiv) {
                if (selectedMembranes.length === 0) { infoDiv.textContent = 'None.'; }
                else { infoDiv.innerHTML = `Membrane IDs: ${selectedMembranes.join(', ')}`; }
            }
            updateModelTree(); // Update the tree highlighting
        }

        // --- NEW: updateModelTree with Visibility Toggles ---
        function updateModelTree() {
            const list = document.getElementById('model-tree-list');
            if (!list) return;
            list.innerHTML = '';

            if (membranes.length === 0) {
                list.innerHTML = '<p class="text-gray-500 italic">No membranes.</p>';
                return;
            }

            membranes.forEach(m => {
                const item = document.createElement('div');
                const isSelected = selectedMembranes.includes(m.id);
                item.className = `p-1 rounded mb-1 flex justify-between items-center ${isSelected ? 'bg-indigo-100 border-indigo-300 border' : 'hover:bg-gray-100'}`;

                // Flex container for Checkbox + Label
                const leftDiv = document.createElement('div');
                leftDiv.className = 'flex items-center gap-2 cursor-pointer';

                // Visibility Checkbox
                const chk = document.createElement('input');
                chk.type = 'checkbox';
                chk.checked = m.visible !== false; // Default true
                chk.onclick = (e) => {
                    e.stopPropagation(); // Don't trigger select
                    m.visible = chk.checked;
                    console.log(`Membrane ${m.id} visibility: ${m.visible}`);
                    // Trigger redrawing of EVERYTHING affected
                    drawMembraneFill(); // Assume this exists or I'll fix
                    drawMesh();
                    drawStressResults(resultsElementStresses); // Redraw stress if present
                };

                // Label
                const label = document.createElement('span');
                const status = m.isMeshed ? '(Meshed)' : '';
                label.textContent = `Membrane ${m.id} ${status}`;

                leftDiv.appendChild(chk);
                leftDiv.appendChild(label);

                // Click on Label/Div selects
                leftDiv.onclick = (e) => {
                    if (e.ctrlKey || e.metaKey) {
                        toggleMembraneSelection(m.id);
                    } else {
                        clearMembraneSelection();
                        toggleMembraneSelection(m.id);
                    }
                };

                item.appendChild(leftDiv);
                list.appendChild(item);
            });
        }

        // --- NEW: Spring Group Tree Updater ---
        function updateSpringGroupTree() {
            const list = document.getElementById('spring-group-list');
            if (!list) return;
            list.innerHTML = '';

            if (springPointGroups.length === 0) {
                list.innerHTML = '<p class="text-gray-500 italic">No spring groups.</p>';
                return;
            }

            springPointGroups.forEach(g => {
                const item = document.createElement('div');
                const isSelected = g.isSelected;
                item.className = `p-1 cursor-pointer rounded mb-1 flex justify-between items-center ${isSelected ? 'bg-green-100 border-green-300 border' : 'hover:bg-gray-100'}`;
                item.textContent = `${g.name} (${g.nodeIds.length} nodes)`;

                item.onclick = () => {
                    // Exclusive selection for spring groups (simplest for "create for selected")
                    springPointGroups.forEach(grp => grp.isSelected = false);
                    g.isSelected = true;
                    updateSpringGroupTree();

                    // Visualize selected group points
                    updateSpringGroupHighlights();
                };
                list.appendChild(item);
            });
        }
        // --- UPDATED: Update Highlights (Red & Thick) ---
        function updateMembraneHighlights() {
            // Loop all membranes and update their stroke based on selection
            membranes.forEach(m => {
                if (m.konvaShape) {
                    const isSelected = selectedMembranes.includes(m.id);
                    if (isSelected) {
                        m.konvaShape.stroke('red');
                        m.konvaShape.strokeWidth(4); // Thicker
                        m.konvaShape.moveToTop(); // Ensure visibility
                    } else {
                        m.konvaShape.stroke(MEMBRANE_DEFAULT_STROKE); // Blue/Default
                        m.konvaShape.strokeWidth(MEMBRANE_DEFAULT_STROKE_WIDTH);
                    }
                }
            });
            if (membraneFillLayer) membraneFillLayer.batchDraw();
        }
        function updateFeSelectionInfo() { const infoDiv = document.getElementById('fe-selection-info'); if (!infoDiv) return; if (selectedFeNodes.length === 0) { infoDiv.textContent = 'None.'; } else { infoDiv.innerHTML = `Count: ${selectedFeNodes.length}<br>IDs: ${selectedFeNodes.slice(0, 10).join(', ')} ${selectedFeNodes.length > 10 ? '...' : ''}`; } }
        function toggleBcInputArea() { const bcArea = document.getElementById('bc-input-area'); if (!bcArea) return; const hasSelection = selectedFeNodes.length > 0; bcArea.hidden = !hasSelection; if (hasSelection) { document.getElementById('bc-type-select').value = 'none'; handleBcTypeChange(); } }
        function handleBcTypeChange() { const selectedType = document.getElementById('bc-type-select')?.value; document.getElementById('bc-fixed-options')?.setAttribute('hidden', ''); document.getElementById('bc-enforced-options')?.setAttribute('hidden', ''); document.getElementById('bc-load-options')?.setAttribute('hidden', ''); if (selectedType === 'fixed') { document.getElementById('bc-fixed-options')?.removeAttribute('hidden'); } else if (selectedType === 'enforced') { document.getElementById('bc-enforced-options')?.removeAttribute('hidden'); } else if (selectedType === 'load') { document.getElementById('bc-load-options')?.removeAttribute('hidden'); } }

        // --- ADDED Function to update material property display (Moved Higher) ---
        function updateMaterialPropertyDisplay() {
            const materialArea = document.getElementById('membrane-material-input-area');
            const noteP = document.getElementById('material-note');
            const inputE = document.getElementById('mem-mat-prop-e');
            const inputNu = document.getElementById('mem-mat-prop-nu');
            const inputT = document.getElementById('mem-mat-prop-t');

            if (!materialArea || !noteP || !inputE || !inputNu || !inputT) {
                console.error("Material property UI elements not found!");
                return;
            }

            if (selectedMembranes.length > 0) {
                const firstSelectedId = selectedMembranes[0];
                const firstMembrane = findMembraneById(firstSelectedId);
                if (firstMembrane) {
                    inputE.value = firstMembrane.materialE ?? DEFAULT_MATERIAL_E;
                    inputNu.value = firstMembrane.materialNu ?? DEFAULT_MATERIAL_NU;
                    inputT.value = firstMembrane.materialT ?? DEFAULT_MATERIAL_T;
                    if (selectedMembranes.length > 1) {
                        noteP.textContent = `Showing properties for Membrane ${firstSelectedId}. Changes apply to all ${selectedMembranes.length} selected.`;
                    } else {
                        noteP.textContent = `Showing properties for Membrane ${firstSelectedId}.`;
                    }
                    materialArea.hidden = false;
                } else {
                    console.warn(`Could not find membrane data for selected ID ${firstSelectedId}`);
                    materialArea.hidden = true; // Hide if data is inconsistent
                }
            } else {
                materialArea.hidden = true; // Hide if no membranes are selected
                noteP.textContent = '';
            }
        }

        // --- ADDED Handler for applying material properties (Moved Higher) ---
        function handleApplyMaterialProperties() {
            // ... (existing code)
        }

        function updateElementSelectionInfo() {
            const infoDiv = document.getElementById('element-selection-info');
            if (!infoDiv) return;
            if (selectedFeElements.length === 0) {
                infoDiv.textContent = 'None.';
            } else {
                infoDiv.innerHTML = `Count: ${selectedFeElements.length}<br>IDs: ${selectedFeElements.slice(0, 10).join(', ')} ${selectedFeElements.length > 10 ? '...' : ''}`;
            }
        }

        function updateElementPropertyDisplay() {
            const elPropArea = document.getElementById('element-properties-area');
            const noteSpan = document.getElementById('el-prop-id');
            const inputE = document.getElementById('el-prop-e');
            const inputNu = document.getElementById('el-prop-nu');
            const inputT = document.getElementById('el-prop-t');
            const stressDisplay = document.getElementById('el-stress-display');
            const stressSxSpan = document.getElementById('el-stress-sx');
            const stressSySpan = document.getElementById('el-stress-sy');
            const stressSxySpan = document.getElementById('el-stress-sxy');
            const stressVmSpan = document.getElementById('el-stress-vm');
            const stressNote = document.getElementById('el-stress-note');

            if (!elPropArea) return;

            if (selectedFeElements.length > 0) {
                elPropArea.hidden = false;

                // Display ID info
                if (selectedFeElements.length === 1) {
                    noteSpan.textContent = selectedFeElements[0];
                } else {
                    noteSpan.textContent = `${selectedFeElements.length} elements selected (Bulk Edit)`;
                }

                // Calculate stresses for selected elements
                const stressData = selectedFeElements.map(id =>
                    resultsElementStresses.find(r => r.elementId === id)
                ).filter(r => r !== undefined);

                if (stressData.length > 0) {
                    stressDisplay.hidden = false;

                    // Parse stress values (they may be stored as exponential strings)
                    const getSxValue = (r) => parseFloat(r.sxx) || 0;
                    const getSyValue = (r) => parseFloat(r.syy) || 0;
                    const getSxyValue = (r) => parseFloat(r.sxy) || 0;
                    const getVmValue = (r) => (typeof r.sigmaVM === 'number') ? r.sigmaVM : parseFloat(r.sigmaVM) || 0;

                    if (stressData.length === 1) {
                        // Single element - show exact values
                        const result = stressData[0];
                        stressSxSpan.textContent = getSxValue(result).toExponential(3) + " psi";
                        stressSySpan.textContent = getSyValue(result).toExponential(3) + " psi";
                        stressSxySpan.textContent = getSxyValue(result).toExponential(3) + " psi";
                        stressVmSpan.textContent = getVmValue(result).toExponential(3) + " psi";
                        stressNote.hidden = true;
                    } else {
                        // Multiple elements - show averaged values
                        const avgSx = stressData.reduce((sum, r) => sum + getSxValue(r), 0) / stressData.length;
                        const avgSy = stressData.reduce((sum, r) => sum + getSyValue(r), 0) / stressData.length;
                        const avgSxy = stressData.reduce((sum, r) => sum + getSxyValue(r), 0) / stressData.length;
                        const avgVm = stressData.reduce((sum, r) => sum + getVmValue(r), 0) / stressData.length;

                        stressSxSpan.textContent = avgSx.toExponential(3) + " psi";
                        stressSySpan.textContent = avgSy.toExponential(3) + " psi";
                        stressSxySpan.textContent = avgSxy.toExponential(3) + " psi";
                        stressVmSpan.textContent = avgVm.toExponential(3) + " psi";
                        stressNote.textContent = `(Avg of ${stressData.length} elements)`;
                        stressNote.hidden = false;
                    }
                } else {
                    stressDisplay.hidden = true;
                }

                // Helper to determine common value
                const getCommonValue = (propName) => {
                    let firstVal = undefined;
                    let isMixed = false;
                    for (let i = 0; i < selectedFeElements.length; i++) {
                        const el = findFeElementById(selectedFeElements[i]);
                        if (!el) continue;
                        const val = el[propName];
                        if (i === 0) firstVal = val;
                        else if (val !== firstVal) isMixed = true;
                    }
                    return isMixed ? '' : (firstVal !== undefined ? firstVal : '');
                };

                // Populate inputs (Blank if mixed or undefined, Value if all same)
                inputE.value = getCommonValue('propE');
                inputNu.value = getCommonValue('propNu');
                inputT.value = getCommonValue('propT');

                // Set placeholders to indicate behavior
                const placeholderText = selectedFeElements.length > 1 ? "Keep Existing (Mixed)" : "Inherit";
                inputE.placeholder = placeholderText;
                inputNu.placeholder = placeholderText;
                inputT.placeholder = placeholderText;

            } else {
                elPropArea.hidden = true;
            }
        }

        function handleApplyElementProperties() {
            if (selectedFeElements.length === 0) return;

            const inputE = document.getElementById('el-prop-e');
            const inputNu = document.getElementById('el-prop-nu');
            const inputT = document.getElementById('el-prop-t');

            // Only update if value is provided (non-empty)
            // If empty, preserve existing value (allows partial bulk updates)
            const eStr = inputE.value.trim();
            const nuStr = inputNu.value.trim();
            const tStr = inputT.value.trim();

            const eVal = eStr === '' ? null : parseFloat(eStr);
            const nuVal = nuStr === '' ? null : parseFloat(nuStr);
            const tVal = tStr === '' ? null : parseFloat(tStr);

            let updatedCount = 0;
            selectedFeElements.forEach(id => {
                const element = findFeElementById(id);
                if (element) {
                    if (eVal !== null) element.propE = eVal;
                    if (nuVal !== null) element.propNu = nuVal;
                    if (tVal !== null) element.propT = tVal;
                    updatedCount++;
                }
            });
            updateStatus(`Updated properties for ${updatedCount} elements.`);
            updateElementPropertyDisplay(); // Refresh display logic (might show new common values)
        }

        function handleClearElementProp(propNameShort) {
            // propNameShort is 'e', 'nu', or 't'
            // Reset means set to undefined (Inherit)
            if (selectedFeElements.length === 0) return;

            const propMap = { 'e': 'propE', 'nu': 'propNu', 't': 'propT' };
            const fullPropName = propMap[propNameShort];

            selectedFeElements.forEach(id => {
                const element = findFeElementById(id);
                if (element) {
                    element[fullPropName] = undefined; // Reset to inherit
                }
            });

            // Clear input visual
            const input = document.getElementById(`el-prop-${propNameShort}`);
            if (input) input.value = '';

            updateStatus(`Reset property '${propNameShort}' to Inherit for selected elements.`);
            updateElementPropertyDisplay();
        }

        function deleteSelectedElements() {
            if (selectedFeElements.length === 0) return;
            if (!confirm(`Are you sure you want to delete ${selectedFeElements.length} selected elements?`)) return;

            // Create a copy to iterate because deleteElement modifies the array/selection
            const idsToDelete = [...selectedFeElements];
            let deletedCount = 0;

            idsToDelete.forEach(id => {
                const idx = feElements.findIndex(e => e.id === id);
                if (idx > -1) {
                    feElements.splice(idx, 1);
                    deletedCount++;
                }
            });

            selectedFeElements = []; // Clear selection
            updateElementSelectionInfo();
            updateElementPropertyDisplay();
            cleanupOrphanFeNodes(); // Clean up orphans
            drawMesh(); // Single redraw
            updateStatus(`Deleted ${deletedCount} elements.`);
        }

        // --- NEW: Parametric Membrane Creation Handler ---
        function handleCreateMembraneParametric() {
            const x = parseFloat(document.getElementById('new-mem-x').value);
            const y = parseFloat(document.getElementById('new-mem-y').value);
            const w = parseFloat(document.getElementById('new-mem-w').value);
            const h = parseFloat(document.getElementById('new-mem-h').value);

            if (isNaN(x) || isNaN(y) || isNaN(w) || isNaN(h) || w <= 0 || h <= 0) {
                alert("Please enter valid parameters for the membrane. Width and Height must be positive.");
                return;
            }

            // Create 4 nodes
            // Order: Bottom-Left (x,y), Bottom-Right (x+w, y), Top-Right (x+w, y+h), Top-Left (x, y+h)
            // Note: Canvas Y coordinates increase downwards, but engineering usually expects Y up.
            // Konva coords: (0,0) top left.
            // If user inputs "Origin" as bottom-left in engineering terms, and width/height...
            // Let's assume standard canvas coordinates for now to be safe (X right, Y down).
            // Or better, assume user "Origin X,Y" is the top-left corner as per standard rect drawing?
            // "Lower left corner" was requested.
            // If user enters (0,0) as lower-left, and wants Y to go UP...
            // Standard computer graphics (Konva) has Y down.
            // Let's implement as: Origin is (x,y).
            // Node 1: (x,y)
            // Node 2: (x+w, y)
            // Node 3: (x+w, y+h)
            // Node 4: (x, y+h)
            // This creates a rectangle.

            const n1 = addNode(x, y);
            const n2 = addNode(x + w, y);
            const n3 = addNode(x + w, y + h); // +h goes down in canvas
            const n4 = addNode(x, y + h);

            if (n1 && n2 && n3 && n4) {
                const nodesData = [n1, n2, n3, n4];
                createMembraneWithNodes(nodesData);
                updateStatus(`Created parametric membrane at (${x},${y}) with ${w}x${h}.`);
            } else {
                updateStatus("Error creating nodes for membrane.");
            }
        }

        // --- NEW: Parametric Spring Grid Creation Handler ---
        function handleCreateSpringGridParametric() {
            const xOrigin = parseFloat(document.getElementById('spring-grid-x').value);
            const yOrigin = parseFloat(document.getElementById('spring-grid-y').value);
            const w = parseFloat(document.getElementById('spring-grid-w').value);
            const h = parseFloat(document.getElementById('spring-grid-h').value);
            const nx = parseInt(document.getElementById('spring-grid-nx').value, 10);
            const ny = parseInt(document.getElementById('spring-grid-ny').value, 10);

            if (isNaN(xOrigin) || isNaN(yOrigin) || isNaN(w) || isNaN(h) || isNaN(nx) || isNaN(ny)) {
                alert("Please enter valid numeric values for all spring grid fields.");
                return;
            }
            if (nx < 2 || ny < 2) {
                alert("Count X and Count Y must be at least 2.");
                return;
            }

            let nodesCreated = 0;
            const dx = (nx > 1) ? w / (nx - 1) : 0;
            const dy = (ny > 1) ? h / (ny - 1) : 0;

            // Create NEW Spring Group
            const newGroup = {
                id: nextSpringGroupId++,
                name: `Grid ${nextSpringGroupId - 1}`,
                nodeIds: [],
                isSelected: true // Auto-select new group
            };
            // Deselect others
            springPointGroups.forEach(g => g.isSelected = false);

            for (let i = 0; i < nx; i++) {
                for (let j = 0; j < ny; j++) {
                    const x = xOrigin + i * dx;
                    const y = yOrigin + j * dy;
                    const newNodeData = addNode(x, y);
                    if (newNodeData) {
                        // toggleSpringPointMarking(newNodeData); // OLD Logic
                        // NEW Logic: Add to group
                        newGroup.nodeIds.push(newNodeData.id);
                        newNodeData.konvaCircle.fill(SPRING_NODE_COLOR); // Visual feedback
                        nodesCreated++;
                    }
                }
            }

            springPointGroups.push(newGroup);
            updateSpringGroupTree();

            // Visualize the newly created group
            updateSpringGroupHighlights();

            updateStatus(`Created Spring Group "${newGroup.name}" with ${nodesCreated} points.`);
            console.log(`Finished creating parametric spring grid.`);
        }

        // --- Initialization ---
        function initializeKonva() {
            console.log("initializeKonva started...");
            // --- REMOVE Check for numeric.js --- REMOVED IN PREVIOUS STEP
            // if (typeof numeric === 'undefined') { ... }
            // --- End Removed Check ---

            try {
                const container = document.getElementById('container');
                if (!container) { console.error("Container element not found."); return; }
                const width = container.clientWidth; const height = container.clientHeight;
                if (!width || !height) { console.error("Container dimensions zero."); setTimeout(initializeKonva, 100); return; }
                if (typeof Konva === 'undefined') { console.error("Konva library not loaded yet."); setTimeout(initializeKonva, 100); return; }
                // Add check for math.js
                if (typeof math === 'undefined') { console.error("Math.js library not loaded yet."); /* Optionally add alert or status update */ }

                stage = new Konva.Stage({ container: 'container', width: width, height: height, draggable: true });
                backgroundLayer = new Konva.Layer();
                membraneFillLayer = new Konva.Layer();
                meshLayer = new Konva.Layer();
                springLayer = new Konva.Layer();
                geometryLayer = new Konva.Layer();
                selectionLayer = new Konva.Layer();
                stressLayer = new Konva.Layer({ visible: false }); // Start hidden
                reactionLayer = new Konva.Layer({ visible: false }); // Start hidden for reactions
                const bcLayer = new Konva.Layer(); // For BC symbols

                stage.add(backgroundLayer);
                stage.add(membraneFillLayer);
                stage.add(meshLayer); // FE elements below springs
                stage.add(stressLayer); // Stress map (filled elements)
                stage.add(geometryLayer); // Nodes/Membrane outlines
                stage.add(springLayer); // Springs on top of mesh
                stage.add(reactionLayer); // Reactions/BCs on top
                stage.add(bcLayer); // BC symbols
                stage.add(selectionLayer); // Selection highlights on top
                const background = new Konva.Rect({ x: 0, y: 0, width: width, height: height, fill: '#f0f0f0' });
                backgroundLayer.add(background);

                stage.on('click tap', handleStageClick);
                stage.on('mousedown touchstart', handleStageMouseDown);
                stage.on('mousemove touchmove', handleStageMouseMove);
                stage.on('mouseup touchend', handleStageMouseUp);
                stage.on('wheel', handleWheelZoom);

                const safeAddListener = (id, event, handler) => { try { const element = document.getElementById(id); if (element) { if (typeof handler === 'function') { element.addEventListener(event, handler); } else { console.error(`Handler for #${id} is not defined or not a function!`); } } else { console.error(`Element #${id} not found!`); } } catch (err) { console.error(`Error adding listener for #${id}:`, err.message, err.stack); throw err; } };

                // --- Updated Listeners for Parametric UI ---
                safeAddListener('btn-create-parametric-membrane', 'click', () => { console.log("Button Clicked: Create Parametric Membrane"); handleCreateMembraneParametric(); });
                safeAddListener('btn-create-parametric-springs', 'click', () => { console.log("Button Clicked: Create Parametric Spring Grid"); handleCreateSpringGridParametric(); });

                // --- Existing Modes that are kept ---
                safeAddListener('btn-select-membrane', 'click', () => { console.log("Button Clicked: Select Membrane"); setMode('select-membrane'); });
                safeAddListener('btn-select-fe-box', 'click', () => { console.log("Button Clicked: Select FE Box"); setMode('select-fe-nodes-box'); });
                safeAddListener('btn-delete-item', 'click', () => { console.log("Button Clicked: Delete Item"); setMode('delete-item'); });
                safeAddListener('btn-edit-node-coords', 'click', () => { console.log("Button Clicked: Edit Node Coords"); setMode('edit-node-coords'); });

                // --- Action Listeners ---
                safeAddListener('btn-mesh-membranes', 'click', () => { console.log("Button Clicked: Mesh Selected"); requestMeshInput(); });
                safeAddListener('btn-confirm-mesh', 'click', () => { console.log("Button Clicked: Confirm Mesh"); handleConfirmMesh(); });
                safeAddListener('btn-add-spring', 'click', () => { console.log("Button Clicked: Create Springs (FE)"); requestSpringInput(); });
                safeAddListener('btn-confirm-springs', 'click', () => { console.log("Button Clicked: Confirm Springs (FE)"); handleConfirmSprings(); });
                safeAddListener('btn-apply-bc-confirm', 'click', () => { console.log("Button Clicked: Apply BC Confirm"); handleApplyBc(); });
                safeAddListener('bc-type-select', 'change', () => { console.log("Dropdown Changed: BC Type"); handleBcTypeChange(); });
                safeAddListener('btn-apply-material', 'click', () => { console.log("Button Clicked: Apply Material Properties"); handleApplyMaterialProperties(); });
                safeAddListener('btn-apply-node-coords', 'click', () => { console.log("Button Clicked: Apply Node Coordinates"); handleApplyNodeCoords(); });
                safeAddListener('btn-solve', 'click', () => { console.log("Button Clicked: Run Analysis"); runAnalysis(); });
                safeAddListener('btn-save-model', 'click', () => { console.log("Button Clicked: Save Model"); handleSaveModel(); });
                safeAddListener('btn-load-text', 'click', () => { console.log("Button Clicked: Load From Text"); handleLoadText(); });

                // Results View Radio Buttons
                const resultRadios = document.querySelectorAll('input[name="results-view"]');
                resultRadios.forEach(radio => {
                    safeAddListener(radio.id, 'change', (event) => { console.log(`Radio Changed: ${event.target.value}`); handleResultsViewChange(event); });
                });

                // Stress Type Select
                safeAddListener('stress-type-select', 'change', () => {
                    console.log("Stress type changed.");
                    drawStressResults(resultsElementStresses);
                });

                // Filter Checkbox REMOVED

                safeAddListener('btn-select-element', 'click', () => { console.log("Button Clicked: Select FE Element"); setMode('select-element'); }); // NEW Listener
                safeAddListener('btn-apply-element-props', 'click', handleApplyElementProperties);
                safeAddListener('btn-delete-selected-elements', 'click', deleteSelectedElements); // NEW Listener
                safeAddListener('btn-clear-el-e', 'click', () => handleClearElementProp('e'));
                safeAddListener('btn-clear-el-nu', 'click', () => handleClearElementProp('nu'));
                safeAddListener('btn-clear-el-t', 'click', () => handleClearElementProp('t'));

                // Wire up new buttons
                safeAddListener('btn-mode-select-fe-box', 'click', () => setMode('select-fe-nodes-box'));
                safeAddListener('btn-mode-select-element-box', 'click', () => setMode('select-element-box'));
                safeAddListener('btn-mode-select-springs-box', 'click', () => setMode('select-springs-box'));
                safeAddListener('btn-mode-select-fe-element', 'click', () => setMode('select-element')); // Keep support if needed

                safeAddListener('btn-delete-springs', 'click', deleteSelectedSprings);
                safeAddListener('btn-update-springs', 'click', updateSelectedSpringsStiffness);

                // Wire up Element Property Listeners for Bulk Edit?
                // If we want bulk edit for elements, we need a button or handle change.
                // The existing UI for elements (`element-properties-area`) had inputs.
                // We didn't add an "Apply" button there.
                // User asked for "Bulk delete or bulk edit spring stiffness".
                // User didn't explicitly ask for Bulk Edit Elements, just "select things entirely within box".
                // But "Select Membrane Elements" implies some action.
                // Assuming current actions (Delete Item) work on selected items?
                // I need to ensure `Mode: Delete Item` works for selectedFeElements.

                safeAddListener('btn-mode-delete', 'click', () => setMode('delete-item'));
                // We need to update delete logic to handle selectedFeElements if Delete Mode is clicked?
                // Or usually Delete Mode means "Click to delete".
                // Bulk delete via button? The Spring panel has a button.
                // Elements don't have a specific bulk delete button yet.
                // Maybe "Mode: Delete Item" handles box selections?
                // Usually, separate "Delete Selected" button is clearer.
                // For now, I satisfy the Spring request fully.
                // Element request was mainly about Selection.

                window.addEventListener('resize', resizeCanvas);
                resizeCanvas(); // Initial resize

                // --- Adjust initial view ---
                // Center the view slightly around the origin with a small initial zoom
                const initialScale = 20; // Start slightly zoomed in
                stage.scale({ x: initialScale, y: initialScale });
                stage.position({
                    x: 20, // Center at upper left
                    y: 20
                });
                updateVisualScales(); // Apply scaling to visuals immediately
                stage.batchDraw();
                // --- End initial view adjustment ---

                console.log("Initialization complete.");
                setMode('select-membrane'); // Default mode updated
                updateSpringPointsInfo();
                updateMembraneSelectionInfo();
                updateFeSelectionInfo();
                updateElementSelectionInfo(); // NEW
                updateSpringSelectionInfo(); // NEW
                updateResultsDisplay();
                handleResultsViewChange();
                // Filtering removed
                drawStressResults(resultsElementStresses); // Simply draw results if available

            } catch (error) { console.error("Error during Konva initialization or listener binding:", error, error.message, error.stack); updateStatus(`Initialization Error: ${error.message}`); }
        }

        // --- UI & Mode Handling ---
        function resizeCanvas() { const container = document.getElementById('container'); if (!stage || !container) return; const width = container.clientWidth; const height = container.clientHeight; stage.width(width); stage.height(height); const background = backgroundLayer.findOne('Rect'); if (background) { background.width(width); background.height(height); } }
        function setMode(newMode) {
            console.log(`setMode called with: ${newMode}`);
            const meshInputArea = document.getElementById('mesh-input-area');
            const springInputArea = document.getElementById('spring-input-area');
            const bcInputArea = document.getElementById('bc-input-area');
            const materialInputArea = document.getElementById('membrane-material-input-area');
            const springGridInputArea = document.getElementById('spring-grid-input-area'); // Kept for reference if exists, but hidden
            const editCoordsInputArea = document.getElementById('edit-node-coords-input-area');

            // Hide input areas if they are visible
            if (meshInputArea && !meshInputArea.hidden) { meshInputArea.hidden = true; }
            if (springInputArea && !springInputArea.hidden) { springInputArea.hidden = true; }
            if (bcInputArea && !bcInputArea.hidden) { bcInputArea.hidden = true; }
            if (materialInputArea && newMode !== 'select-membrane') { materialInputArea.hidden = true; }
            if (springGridInputArea) { springGridInputArea.hidden = true; } // Always hide old input area if it exists
            if (editCoordsInputArea && newMode !== 'edit-node-coords') { editCoordsInputArea.hidden = true; }

            // Clear selections based on mode changes
            if (['select-membrane', 'select-fe-nodes-box', 'delete-item'].includes(newMode)) { clearSelection(true); } // Clear geo node selection
            if (newMode !== 'select-membrane' && newMode !== 'mesh-membranes') { clearMembraneSelection(); }
            if (newMode !== 'select-fe-nodes-box') { clearFeSelection(); }
            if (newMode !== 'select-element') { clearFeElementSelection(); } // Clear element selection on mode switch
            if (newMode !== 'select-springs-box') { clearSpringSelection(); } // Clear spring selection on mode switch

            // Reset editing node state when changing modes
            if (newMode !== 'edit-node-coords') {
                if (editingNodeId !== null) {
                    const editedNode = findNodeDataById(editingNodeId);
                    if (editedNode?.konvaCircle) {
                        const index = selectedNodes.findIndex(n => n.id === editingNodeId);
                        if (index === -1) {
                            editedNode.konvaCircle.stroke('black');
                            editedNode.konvaCircle.strokeWidth(NODE_STROKE_WIDTH_TARGET_PX);
                        } else {
                            editedNode.konvaCircle.stroke('#007bff');
                            editedNode.konvaCircle.strokeWidth(3);
                        }
                    }
                    editingNodeId = null;
                }
            }

            const container = document.getElementById('container');
            if (container) {
                container.classList.toggle('crosshair-cursor', newMode === 'select-fe-nodes-box' || newMode === 'select-springs-box' || newMode === 'select-element-box');
                container.classList.toggle('delete-cursor', newMode === 'delete-item');
                if (newMode === 'select-fe-nodes-box' || newMode === 'delete-item' || newMode === 'select-springs-box' || newMode === 'select-element-box') {
                    container.classList.remove('cursor-default');
                } else if (!container.classList.contains('cursor-default')) {
                    container.classList.add('cursor-default');
                }
            }

            currentMode = newMode;
            console.log("Mode changed to:", currentMode);

            // Update button active states
            const allButtons = document.querySelectorAll('button[id^="btn-"]');
            allButtons.forEach(btn => {
                // Skip special buttons
                if (btn.id.includes('create-parametric') || btn.id === 'btn-confirm-mesh' || btn.id === 'btn-confirm-springs'
                    || btn.id === 'btn-apply-bc-confirm' || btn.id === 'btn-apply-material' || btn.id === 'btn-apply-node-coords'
                    || btn.id === 'btn-apply-element-props' || btn.id.startsWith('btn-clear-el') || btn.id === 'btn-delete-selected-elements'
                    || btn.id === 'btn-delete-springs' || btn.id === 'btn-update-springs') { // Added new spring buttons
                    return;
                }

                // Clear active styles
                btn.classList.remove('bg-green-600', 'hover:bg-green-700', 'shadow', 'bg-teal-600', 'hover:bg-teal-700', 'bg-orange-600', 'hover:bg-orange-700', '!bg-red-600', '!hover:!bg-red-700', 'bg-blue-600', 'hover:bg-blue-700', 'bg-purple-600', 'hover:bg-purple-700'); // Added purple
                btn.classList.remove('!bg-gray-600', '!hover:!bg-gray-700', '!bg-red-600', '!hover:!bg-red-700');

                // Apply inactive styles
                if (btn.id === 'btn-solve') {
                    btn.classList.add('!bg-red-600', '!hover:!bg-red-700');
                } else if (['btn-save-model', 'btn-load-text'].includes(btn.id)) {
                    btn.classList.add('!bg-gray-600', '!hover:!bg-gray-700');
                } else {
                    btn.classList.add('bg-blue-600', 'hover:bg-blue-700');
                }
            });

            const activeButton = document.getElementById(`btn-${newMode.replace(/_/g, '-')}`);
            if (activeButton) {
                activeButton.classList.remove('bg-blue-600', 'hover:bg-blue-700');
                if (newMode === 'delete-item') {
                    activeButton.classList.add('!bg-red-600', '!hover:!bg-red-700', 'shadow');
                } else if (newMode === 'select-membrane') {
                    activeButton.classList.add('bg-teal-600', 'hover:bg-teal-700', 'shadow');
                    updateMaterialPropertyDisplay();
                } else if (newMode === 'select-fe-nodes-box') {
                    activeButton.classList.add('bg-orange-600', 'hover:bg-orange-700', 'shadow');
                } else if (newMode === 'edit-node-coords') {
                    activeButton.classList.add('bg-green-600', 'hover:bg-green-700', 'shadow');
                } else if (newMode === 'select-element' || newMode === 'select-element-box') { // Combined for styling
                    activeButton.classList.add('bg-purple-600', 'hover:bg-purple-700', 'shadow');
                } else if (newMode === 'select-springs-box') { // New mode for springs
                    activeButton.classList.add('bg-pink-600', 'hover:bg-pink-700', 'shadow'); // Using pink for springs
                }
            }

            // Show edit coords input area IF a node is being edited
            if (newMode === 'edit-node-coords' && editCoordsInputArea && editingNodeId !== null) {
                editCoordsInputArea.hidden = false;
            }

            // Update status message
            switch (currentMode) {
                case 'edit-node-coords': updateStatus("Mode: Edit Node Coords. Click a node to edit."); break;
                case 'select-membrane': updateStatus("Mode: Select Membrane. Click inside membranes to select/deselect/cycle."); break;
                case 'select-fe-nodes-box': updateStatus("Mode: Select FE Nodes. Drag a box to select nodes."); break;
                case 'select-element': updateStatus("Mode: Select Element. Click mesh elements to select."); break;
                case 'select-element-box': updateStatus("Mode: Select Elements. Drag a box to select elements."); break;
                case 'select-springs-box': updateStatus("Mode: Select Springs. Drag a box to select springs."); break;
                case 'delete-item': updateStatus("Mode: Delete Item. Click a Geo Node, Membrane, Mesh Element, or Spring to delete."); break;
                default: updateStatus(`Mode: ${currentMode}`);
            }
        }
        function isPointInsidePolygon(point, polygonVertices) { const x = point.x, y = point.y; let isInside = false; const n = polygonVertices.length; if (n < 3) return false; for (let i = 0, j = n - 1; i < n; j = i++) { const xi = polygonVertices[i].x, yi = polygonVertices[i].y; const xj = polygonVertices[j].x, yj = polygonVertices[j].y; const y_adjusted = y + 1e-9; const intersect = ((yi > y_adjusted) !== (yj > y_adjusted)) && (x < (xj - xi) * (y_adjusted - yi) / (yj - yi) + xi); if (intersect) { isInside = !isInside; } } return isInside; }
        function handleStageClick(e) {
            console.log(`handleStageClick called in mode: ${currentMode}`);
            if (!stage || !geometryLayer || !backgroundLayer) return;
            if (e.target.getParent() === geometryLayer && e.target.getClassName() === 'Circle') { return; } // Ignore clicks on existing nodes
            if (isSelectingBox) return; // Ignore clicks during box selection

            const pos = stage.getPointerPosition();
            if (!pos) return;
            const stagePos = stage.position();
            const scale = stage.scaleX();
            const clickPos = { x: (pos.x - stagePos.x) / scale, y: (pos.y - stagePos.y) / scale };

            // --- Standard Modes ---
            if (currentMode === 'select-membrane' || currentMode === 'delete-item') {
                // Check if click is inside any membrane
                const overlappingMembranes = membranes.filter(m => {
                    if (!m || m.nodeIds.length < 3) return false;
                    const vertices = m.nodeIds.map(id => { const node = findNodeDataById(id); return node ? { x: node.x, y: node.y } : null; }).filter(v => v !== null);
                    if (vertices.length !== m.nodeIds.length) { return false; } // Ensure all nodes found
                    return isPointInsidePolygon(clickPos, vertices);
                });
                console.log(`Found ${overlappingMembranes.length} membranes at click point (manual check).`);

                if (overlappingMembranes.length > 0) {
                    if (currentMode === 'select-membrane') {
                        // Cycle through overlapping membranes or select the first one
                        if (overlappingMembranes.length === 1) {
                            toggleMembraneSelection(overlappingMembranes[0]);
                        } else {
                            // Logic to cycle selection if multiple membranes overlap
                            const overlappingIds = overlappingMembranes.map(m => m.id);
                            const selectedOverlappingId = selectedMembranes.find(id => overlappingIds.includes(id));
                            if (selectedOverlappingId !== undefined) {
                                // Cycle to the next one
                                const currentSelectedMembrane = findMembraneById(selectedOverlappingId);
                                const currentIndex = overlappingMembranes.findIndex(m => m.id === selectedOverlappingId);
                                const nextIndex = (currentIndex + 1) % overlappingMembranes.length;
                                const nextMembraneToSelect = overlappingMembranes[nextIndex];
                                if (currentSelectedMembrane) { toggleMembraneSelection(currentSelectedMembrane); } // Deselect current
                                toggleMembraneSelection(nextMembraneToSelect); // Select next
                                console.log(`Cycled selection from Mem ${selectedOverlappingId} to Mem ${nextMembraneToSelect.id}`);
                            } else {
                                // Select the first one found
                                toggleMembraneSelection(overlappingMembranes[0]);
                                console.log(`Selected first overlapping Mem ${overlappingMembranes[0].id}`);
                            }
                        }
                    } else if (currentMode === 'delete-item') {
                        // Delete the top-most overlapping membrane (or first found)
                        const membraneToDelete = overlappingMembranes[0];
                        if (confirm(`Delete Membrane ${membraneToDelete.id} and its defining nodes?`)) {
                            console.log("Attempting to delete membrane:", membraneToDelete.id);
                            deleteMembrane(membraneToDelete.id);
                        }
                    }
                } else {
                    // Click was on background, clear selections
                    if (e.target === stage || e.target === backgroundLayer.findOne('Rect')) {
                        if (currentMode === 'select-membrane') clearMembraneSelection();
                        // Removed select-geo-node clearing
                        if (currentMode === 'select-fe-nodes-box') clearFeSelection();
                        if (currentMode === 'select-springs-box') clearSpringSelection(); // NEW
                        if (currentMode === 'select-element-box') clearFeElementSelection(); // NEW
                    }
                }
            }
        }
        function handleNodeClick(nodeData) {
            console.log(`handleNodeClick called for node ${nodeData?.id} in mode: ${currentMode}`);
            if (!nodeData || !nodeData.konvaCircle) { console.error("Invalid nodeData received in handleNodeClick"); return; }

            // --- Logic for Edit Node Coords mode ---
            if (currentMode === 'edit-node-coords') {
                // Clear previous selection highlight if any
                if (editingNodeId !== null && editingNodeId !== nodeData.id) {
                    const previouslyEditedNode = findNodeDataById(editingNodeId);
                    if (previouslyEditedNode?.konvaCircle) {
                        previouslyEditedNode.konvaCircle.stroke('black');
                        previouslyEditedNode.konvaCircle.strokeWidth(NODE_STROKE_WIDTH_TARGET_PX);
                    }
                }

                // Set new editing node
                editingNodeId = nodeData.id;
                console.log(`Selected node ${editingNodeId} for coordinate editing.`);

                // Populate input area
                document.getElementById('edit-node-id-display').textContent = editingNodeId;
                const xVal = nodeData.x !== undefined ? nodeData.x : 0;
                const yVal = nodeData.y !== undefined ? nodeData.y : 0;
                document.getElementById('edit-node-x-input').value = xVal.toFixed(3);
                document.getElementById('edit-node-y-input').value = yVal.toFixed(3);

                // Show input area
                const inputArea = document.getElementById('edit-node-coords-input-area');
                if (inputArea) inputArea.hidden = false;

                // Immediate highlight
                if (nodeData.konvaCircle) {
                    nodeData.konvaCircle.stroke('#007bff');
                    nodeData.konvaCircle.strokeWidth(3);
                }

                geometryLayer?.batchDraw();
                updateStatus(`Editing coordinates for Node ${editingNodeId}. Enter new X/Y and click Apply.`);
            }
            // --- End Edit Node Coords Logic ---

            else if (currentMode === 'delete-item') {
                if (confirm(`Delete Node ${nodeData.id}?`)) {
                    deleteNode(nodeData.id);
                }
            }
        }

        function handleSpringClick(spring) { // Added missing function
            if (currentMode === 'delete-item') {
                if (confirm(`Delete Spring ${spring.id}?`)) {
                    // Inline delete logic since deleteSpring func might be missing
                    const idx = feSprings.findIndex(s => s.id === spring.id);
                    if (idx > -1) {
                        feSprings.splice(idx, 1);
                        updateSpringSelectionInfo();
                        drawSprings();
                        updateStatus(`Spring ${spring.id} deleted.`);
                    }
                }
            } else if (currentMode === 'select-springs-box') {
                // Or simple select mode? Assuming handled by box usually, but if click...
                // Step 20 said: if currentMode === 'select-springs-box' ... handleSpringClick
                // So we should toggle selection?
                // But current UI only has 'select-springs-box'.
                // Let's implement toggle logic like elements.
                const index = selectedFeSprings.indexOf(spring.id);
                if (index > -1) {
                    selectedFeSprings.splice(index, 1);
                } else {
                    selectedFeSprings.push(spring.id);
                }
                updateSpringSelectionInfo();
                drawSprings();
            }
        }

        function handleStageMouseDown(e) {
            if ((currentMode !== 'select-fe-nodes-box' && currentMode !== 'select-springs-box' && currentMode !== 'select-element-box' && currentMode !== 'delete-item') || !stage) return;
            stage.stopDrag();
            e.evt.preventDefault();
            isSelectingBox = true;
            let pos = stage.getPointerPosition();
            if (!pos) { isSelectingBox = false; return; }
            const stagePos = stage.position();
            const scale = stage.scaleX();
            selectionBoxStart = { x: (pos.x - stagePos.x) / scale, y: (pos.y - stagePos.y) / scale }; // World coords

            // Clear relevant selection based on mode
            if (currentMode === 'select-fe-nodes-box') clearFeSelection(); // Clears all FE nodes and springs
            if (currentMode === 'select-springs-box') clearSpringSelection();
            if (currentMode === 'select-element-box') clearFeElementSelection(); // Clear element selection

            selectionRect = new Konva.Rect({
                x: selectionBoxStart.x, y: selectionBoxStart.y, width: 0, height: 0, fill: SELECTION_BOX_COLOR,
                stroke: 'blue',
                strokeWidth: 1, // Use constant pixel width
                strokeScaleEnabled: false, // Disable scaling with zoom
                visible: true,
            });
            selectionLayer.add(selectionRect);
            selectionLayer.batchDraw();
        }
        function handleStageMouseMove(e) { if (!isSelectingBox || !selectionRect || !stage) return; let currentPos = stage.getPointerPosition(); if (!currentPos) return; const stagePos = stage.position(); const scale = stage.scaleX(); const adjustedPos = { x: (currentPos.x - stagePos.x) / scale, y: (currentPos.y - stagePos.y) / scale }; const width = adjustedPos.x - selectionBoxStart.x; const height = adjustedPos.y - selectionBoxStart.y; selectionRect.setAttrs({ x: width > 0 ? selectionBoxStart.x : adjustedPos.x, y: height > 0 ? selectionBoxStart.y : adjustedPos.y, width: Math.abs(width), height: Math.abs(height), }); selectionLayer.batchDraw(); }
        function handleStageMouseUp(e) {
            if (!isSelectingBox || !selectionRect || !stage) { return; }
            isSelectingBox = false;
            const finalAttrs = selectionRect.getAttrs();
            // Normalize box (width/height can be negative during draw, but filter prefers x/y/w/h normalized)
            const box = {
                x: finalAttrs.width > 0 ? finalAttrs.x : finalAttrs.x + finalAttrs.width,
                y: finalAttrs.height > 0 ? finalAttrs.y : finalAttrs.y + finalAttrs.height,
                width: Math.abs(finalAttrs.width),
                height: Math.abs(finalAttrs.height)
            };

            console.log("Selection box finished (World):", box);

            if (currentMode === 'select-fe-nodes-box') {
                selectedFeNodes = feNodes.filter(feN => {
                    const mem = findMembraneById(feN.membraneId);
                    if (mem && mem.visible === false) return false;
                    return feN.x >= box.x && feN.x <= box.x + box.width &&
                        feN.y >= box.y && feN.y <= box.y + box.height
                }).map(feN => feN.id);
                console.log(`Selected ${selectedFeNodes.length} FE nodes.`);
                updateFeSelectionInfo();
                drawMesh();
                toggleBcInputArea();
            }
            else if (currentMode === 'select-springs-box') {
                // Select springs where BOTH nodes are inside the box
                selectedFeSprings = feSprings.filter(s => {
                    const n1 = findFeNodeById(s.feNodeId1);
                    const n2 = findFeNodeById(s.feNodeId2);
                    if (!n1 || !n2) return false;

                    // Optional: Check visibility of membranes attached to these nodes?
                    // Springs might connect different membranes. If ANY connected membrane is hidden, maybe hide selection?
                    // For now, let's stick to strict spatial selection, but respecting "visual" might mean:
                    // If the spring itself is not drawn (filtered in drawSprings), it shouldn't be selected.
                    // drawSprings logic: shouldDraw = (selectedMembranes...) if filter is on.
                    // But general visibility?
                    // If a membrane is hidden, its nodes are hidden.
                    // If both nodes are hidden, spring is hidden?
                    // Let's add a consistent check: if both ends belong to hidden membranes, don't select.
                    const m1 = findMembraneById(n1.membraneId);
                    const m2 = findMembraneById(n2.membraneId);
                    if ((m1 && m1.visible === false) && (m2 && m2.visible === false)) return false;
                    // Or stricter: if EITHER is visible, we select? Or if BOTH visible?
                    // Let's go with: If the spring is VISIBLE, select it. 
                    // A spring is usually visible if its nodes are visible.
                    // Simplest for now: Don't change spring logic unless requested, but the user asked for "membrane elements".
                    // I'll stick to the user request for "membrane elements" (FE Elements) and Nodes generally follow.

                    const n1Inside = n1.x >= box.x && n1.x <= box.x + box.width && n1.y >= box.y && n1.y <= box.y + box.height;
                    const n2Inside = n2.x >= box.x && n2.x <= box.x + box.width && n2.y >= box.y && n2.y <= box.y + box.height;
                    return n1Inside && n2Inside;
                }).map(s => s.id);
                console.log(`Selected ${selectedFeSprings.length} Springs.`);
                updateSpringSelectionInfo();
                drawSprings();
            }
            else if (currentMode === 'select-element-box') {
                // Select elements where ALL nodes are inside the box
                // AND the membrane is visible
                const elementsInBox = feElements.filter(el => {
                    const mem = findMembraneById(el.membraneId);
                    if (mem && mem.visible === false) return false;

                    return el.nodeIds.every(nid => {
                        const n = findFeNodeById(nid);
                        if (!n) return false;
                        return n.x >= box.x && n.x <= box.x + box.width && n.y >= box.y && n.y <= box.y + box.height;
                    });
                });

                // Update selectedFeElements array
                selectedFeElements = elementsInBox.map(el => el.id);

                console.log(`Selected ${selectedFeElements.length} Elements (by Box).`);
                updateElementSelectionInfo();
                updateElementPropertyDisplay();
                drawMesh(); // Redraw to highlight selected elements
            }

            else if (currentMode === 'delete-item') {
                // Box Delete Logic
                const visibleMembranesInBox = membranes.filter(m => {
                    if (m.visible === false) return false;
                    // Check if ALL nodes of the membrane are in the box? Or ANY?
                    // Usually for deletion, if you encompass it, you delete it. 
                    // Let's require all control points to be inside to be safe against accidental partial intersections.
                    return m.nodeIds.every(nid => {
                        const n = findNodeDataById(nid);
                        return n && n.x >= box.x && n.x <= box.x + box.width && n.y >= box.y && n.y <= box.y + box.height;
                    });
                });

                const visibleElementsInBox = feElements.filter(el => {
                    const mem = findMembraneById(el.membraneId);
                    if (mem && mem.visible === false) return false;
                    return el.nodeIds.every(nid => {
                        const n = findFeNodeById(nid);
                        return n && n.x >= box.x && n.x <= box.x + box.width && n.y >= box.y && n.y <= box.y + box.height;
                    });
                });

                const visibleSpringsInBox = feSprings.filter(s => {
                    const n1 = findFeNodeById(s.feNodeId1);
                    const n2 = findFeNodeById(s.feNodeId2);
                    if (!n1 || !n2) return false;
                    // Check visibility logic same as selection
                    const m1 = findMembraneById(n1.membraneId);
                    const m2 = findMembraneById(n2.membraneId);
                    if ((m1 && m1.visible === false) && (m2 && m2.visible === false)) return false;

                    return (n1.x >= box.x && n1.x <= box.x + box.width && n1.y >= box.y && n1.y <= box.y + box.height) &&
                        (n2.x >= box.x && n2.x <= box.x + box.width && n2.y >= box.y && n2.y <= box.y + box.height);
                });

                // Nodes: Only delete orphan Geometry nodes? 
                // Or all nodes in box?
                // The prompt says "delete item feature act as both a point selector ... and a box selection".
                // If I select a box, I expect everything inside to go.
                // But deleting FE nodes is implicit via Elements usually, but standalone FE nodes exist?
                // Actually existing "delete-item" handles: Geo Node, Membrane, Element, Spring.
                // It does NOT handle FE Node deletion directly (usually).
                // Existing `handleNodeClick` deletes GEO nodes.
                // So we should filter GEO nodes.
                const visibleGeoNodesInBox = nodes.filter(n => {
                    // Check if node is part of a visible membrane? 
                    // Or just if it is in the box?
                    // If it is in the box, and we are deleting, we try to delete it.
                    // deleteNode() logic will prevent deletion if it's used by a membrane (that isn't also being deleted?).
                    // But if we delete the membrane in this same batch, we should allow deleting the node.
                    // This creates a dependency order: Delete Membranes FIRST, then Nodes.
                    return n.x >= box.x && n.x <= box.x + box.width && n.y >= box.y && n.y <= box.y + box.height;
                });

                const countMem = visibleMembranesInBox.length;
                const countEl = visibleElementsInBox.length;
                const countSpr = visibleSpringsInBox.length;
                const countNode = visibleGeoNodesInBox.length;

                if (countMem + countEl + countSpr + countNode === 0) {
                    updateStatus("No visible items found in selection box to delete.");
                } else {
                    const confirmMsg = `Are you sure you want to delete:\n` +
                        (countMem ? `- ${countMem} Membranes (and their nodes)\n` : '') +
                        (countEl ? `- ${countEl} Elements\n` : '') +
                        (countSpr ? `- ${countSpr} Springs\n` : '') +
                        (countNode ? `- ${countNode} Geometry Nodes\n` : '') +
                        `\n(Hidden items are ignored)`;

                    if (confirm(confirmMsg)) {
                        // Execution Order:
                        // 1. Elements & Springs (Independent)
                        // 2. Membranes (might free up Nodes)
                        // 3. Nodes (orphans)

                        visibleSpringsInBox.forEach(s => deleteSpring(s.id)); // Need to ensure deleteSpring exists? It doesn't! 
                        // Wait, how do we delete springs? 
                        // Existing code uses `feSprings.splice`.
                        // I need to implement `deleteSpring` or do it inline.
                        // I'll create `deleteSpring` helper or use the loop.
                        // Actually, let's look at `deleteElement` (line 392 of snippet... no, line 2378 inferred).
                        // I will add `deleteSpring` function later or just do it here?
                        // Better to call a function. I'll add `deleteSpring` function definition too if missing.

                        visibleElementsInBox.forEach(el => deleteElement(el.id));

                        // Delete springs inline for now if function missing
                        // Actually I can filter feSprings global array.
                        const springIds = new Set(visibleSpringsInBox.map(s => s.id));
                        if (springIds.size > 0) {
                            const initialSpr = feSprings.length;
                            feSprings = feSprings.filter(s => !springIds.has(s.id));
                            console.log(`Deleted ${initialSpr - feSprings.length} springs via box.`);
                            updateSpringSelectionInfo();
                            drawSprings();
                        }

                        // Membranes:
                        visibleMembranesInBox.forEach(m => deleteMembrane(m.id)); // This now handles its nodes too

                        // Nodes:
                        // Now try to delete geo nodes. Some might have been deleted by deleteMembrane already if I implement that.
                        // But `deleteNode` handles checking if it exists.
                        visibleGeoNodesInBox.forEach(n => deleteNode(n.id, true)); // Pass true for silent

                        updateStatus(`Deleted ${countMem} membranes, ${countEl} elements, ${countSpr} springs, ${countNode} nodes.`);
                    }
                }
            }

            selectionRect.destroy();
            selectionLayer.batchDraw();
            selectionRect = null;
        }

        function handleWheelZoom(e) {
            e.evt.preventDefault();
            if (!stage) return;

            const scaleBy = 1.05;
            const oldScale = stage.scaleX();
            const pointer = stage.getPointerPosition();
            if (!pointer) return;

            const mousePointTo = {
                x: (pointer.x - stage.x()) / oldScale,
                y: (pointer.y - stage.y()) / oldScale,
            };

            let direction = e.evt.deltaY < 0 ? 1 : -1;
            let newScale;
            if (direction > 0) {
                newScale = oldScale * scaleBy;
            } else {
                newScale = oldScale / scaleBy;
            }
            // --- Changed min/max zoom levels ---
            newScale = Math.max(1, Math.min(newScale, 200)); // Clamp scale: Min 1x, Max 200x

            const newPos = {
                x: pointer.x - mousePointTo.x * newScale,
                y: pointer.y - mousePointTo.y * newScale,
            };

            stage.scale({ x: newScale, y: newScale });
            stage.position(newPos);

            // --- ADDED: Update visuals for new scale ---
            updateVisualScales();
            // --- End Added ---

            stage.batchDraw();
        }

        // --- Function to update scale-dependent visuals ---
        function updateVisualScales() {
            if (!stage) return;
            const scale = stage.scaleX(); // Get the NEW scale after zoom

            // Update geometric nodes (Radius only)
            nodes.forEach(node => {
                if (node.konvaCircle) {
                    let radius = NODE_RADIUS_TARGET_PX / scale;
                    if (node.isSpringGroupSelected) {
                        radius *= 1.5; // Apply highlight multiplier
                    }
                    node.konvaCircle.radius(radius);
                }
            });

            // Update FE nodes / BCs (by redrawing mesh layer which uses scale)
            drawMesh();

            // --- Update Spring Labels for Fixed Screen Size ---
            if (springLayer) {
                const springLabels = springLayer.find('Text'); // Find all labels

                springLabels.forEach(textNode => {
                    const node1Id = textNode.getAttr('node1Id'); // Get associated node
                    const node1 = findFeNodeById(node1Id);

                    if (node1) {
                        // Calculate NEW world offset based on FIXED screen offset and NEW scale
                        const worldOffsetX = SPRING_LABEL_SCREEN_OFFSET_X / scale;
                        const worldOffsetY = SPRING_LABEL_SCREEN_OFFSET_Y / scale;

                        // Update counter-scaling to match the new stage scale
                        textNode.scaleX(1 / scale);
                        textNode.scaleY(1 / scale);

                        // Update world position based on node1's current pos and NEW world offset
                        textNode.position({
                            x: node1.x + worldOffsetX,
                            y: node1.y - worldOffsetY // Still subtract Y offset for 'up'
                        });

                        // NOTE: textNode.fontSize() is NOT changed here - it remains fixed
                    }
                });
            } // End if (springLayer)

            // Batch draw layers that had visual updates
            geometryLayer?.batchDraw(); // Nodes updated
            // meshLayer is redrawn by drawMesh()
            springLayer?.batchDraw();   // Labels updated
        }
        // --- End Added Function ---

        function addNode(x, y, loadedId = null) {
            const useLoadedId = loadedId !== null;
            const nodeId = useLoadedId ? loadedId : nextNodeId++;
            if (typeof Konva === 'undefined' || !Konva.Circle) { console.error("Konva.Circle not available."); updateStatus("Error: Konva library component missing."); return null; }

            // --- Calculate initial radius based on current scale ---
            const currentScale = stage ? stage.scaleX() : 1.0; // Get current scale or default to 1
            const initialRadius = NODE_RADIUS_TARGET_PX / currentScale;
            const initialStrokeWidth = NODE_STROKE_WIDTH_TARGET_PX; // Use target pixel width

            const konvaCircle = new Konva.Circle({
                x: x,
                y: y,
                radius: initialRadius, // Use scaled radius
                fill: DEFAULT_NODE_COLOR,
                stroke: 'black',
                strokeWidth: initialStrokeWidth,
                strokeScaleEnabled: false, // Keep stroke width constant in pixels
                draggable: true,
                id: `node-${nodeId}`
            });
            const nodeData = { id: nodeId, konvaCircle: konvaCircle, x: x, y: y }; if (!findNodeDataById(nodeId)) { nodes.push(nodeData); } else if (!useLoadedId) { console.warn(`Node ID ${nodeId} conflict!`); } /* ID counter updated in handleLoadText */ konvaCircle.on('click tap', (e) => { e.cancelBubble = true; handleNodeClick(nodeData); }); konvaCircle.on('dragend', () => { nodeData.x = konvaCircle.x(); nodeData.y = konvaCircle.y(); const movedNodeId = nodeData.id; console.log(`Node ${movedNodeId} moved to (${nodeData.x.toFixed(1)}, ${nodeData.y.toFixed(1)})`); updateConnectedMembranes(movedNodeId); updateSelectionInfo(); konvaCircle.moveToTop(); clearMeshForAffectedMembranes(movedNodeId); drawMesh(); drawSprings(); }); geometryLayer.add(konvaCircle); return nodeData;
        }
        function findNodeDataById(id) { return nodes.find(n => n.id === id); }
        function findFeNodeById(id) { return feNodes.find(n => n.id === id); }
        function findFeElementById(id) { return feElements.find(el => el.id === id); }
        function findMembraneById(id) { return membranes.find(m => m.id === id); }
        function updateConnectedMembranes(nodeId) { membranes.forEach(mem => { if (mem.nodeIds.includes(nodeId)) { const points = []; let geometryIsValid = true; mem.nodeIds.forEach(nId => { const nodeData = findNodeDataById(nId); if (nodeData && nodeData.konvaCircle) { points.push(nodeData.konvaCircle.x(), nodeData.konvaCircle.y()); } else { geometryIsValid = false; } }); if (geometryIsValid && mem.konvaShape && points.length === mem.nodeIds.length * 2) { mem.konvaShape.points(points); } else { console.warn(`Membrane ${mem.id} fill shape could not be updated.`); } } }); if (membraneFillLayer) membraneFillLayer.batchDraw(); }
        function toggleNodeSelection(nodeData) { if (!nodeData || !nodeData.konvaCircle) { console.error("Invalid node data passed to toggleNodeSelection:", nodeData); return; } const index = selectedNodes.findIndex(n => n.id === nodeData.id); if (index > -1) { selectedNodes.splice(index, 1); nodeData.konvaCircle.stroke('black'); nodeData.konvaCircle.strokeWidth(1); console.log(`Node ${nodeData.id} deselected.`); } else { selectedNodes.push(nodeData); nodeData.konvaCircle.stroke('#007bff'); nodeData.konvaCircle.strokeWidth(3); console.log(`Node ${nodeData.id} selected.`); } if (geometryLayer) geometryLayer.batchDraw(); updateSelectionInfo(); }
        function clearSelection(clearData = true) { selectedNodes.forEach(nodeData => { if (nodeData && nodeData.konvaCircle) { nodeData.konvaCircle.stroke('black'); nodeData.konvaCircle.strokeWidth(1); } }); if (clearData) { selectedNodes = []; console.log("Selection data cleared."); } if (geometryLayer) geometryLayer.batchDraw(); updateSelectionInfo(); console.log("Selection visual cleared."); }
        function toggleSpringPointMarking(nodeData) { if (!nodeData || !nodeData.konvaCircle) return; const index = geometricSpringNodes.indexOf(nodeData.id); if (index > -1) { geometricSpringNodes.splice(index, 1); nodeData.konvaCircle.fill(DEFAULT_NODE_COLOR); updateStatus(`Unmarked node ${nodeData.id} as spring point.`); console.log(`Unmarked node ${nodeData.id} for springs.`); } else { geometricSpringNodes.push(nodeData.id); nodeData.konvaCircle.fill(SPRING_NODE_COLOR); updateStatus(`Marked node ${nodeData.id} as spring point.`); console.log(`Marked node ${nodeData.id} for springs.`); } if (geometryLayer) geometryLayer.batchDraw(); updateSpringPointsInfo(); }
        // --- UPDATED: Refactored toggle logic ---
        function toggleMembraneSelection(membraneArg) {
            let mid;
            // Handle both object (from click) and ID (from tree)
            if (typeof membraneArg === 'object' && membraneArg !== null) {
                mid = membraneArg.id;
            } else {
                mid = membraneArg;
            }

            const index = selectedMembranes.indexOf(mid);
            if (index > -1) {
                selectedMembranes.splice(index, 1);
                console.log(`Deselected Membrane ${mid}`);
            } else {
                selectedMembranes.push(mid);
                console.log(`Selected Membrane ${mid}`);
            }

            // Centralized Updates
            updateMembraneSelectionInfo();
            updateMaterialPropertyDisplay();
            updateMembraneHighlights(); // Apply Red/Thick lines
        }

        function clearMembraneSelection() {
            selectedMembranes = [];
            updateMembraneSelectionInfo();
            updateMaterialPropertyDisplay();
            updateMembraneHighlights(); // Reset all to default
            console.log("Membrane selection cleared.");
        }
        function clearFeSelection() { if (selectedFeNodes.length > 0) { selectedFeNodes = []; console.log("FE Node selection cleared."); updateFeSelectionInfo(); drawMesh(); toggleBcInputArea(); } }
        function updateStatus(message) { const statusElement = document.getElementById('status-message'); if (statusElement) { statusElement.textContent = message; } else { console.warn("Status message element not found."); } }
        function updateSelectionInfo() { const infoDiv = document.getElementById('selection-info'); if (!infoDiv) return; if (selectedNodes.length === 0) { infoDiv.textContent = 'None.'; } else { infoDiv.innerHTML = `Node IDs (${selectedNodes.length}):<br>`; selectedNodes.forEach((node, index) => { if (node && typeof node.id !== 'undefined') { infoDiv.innerHTML += `${index + 1}. ${node.id} <br>`; } else { infoDiv.innerHTML += `${index + 1}. ? <br>`; console.error("Error displaying node data:", node); } }); } }
        function updateSpringPointsInfo() { const infoDiv = document.getElementById('spring-points-info'); if (!infoDiv) return; if (geometricSpringNodes.length === 0) { infoDiv.textContent = 'None.'; } else { infoDiv.innerHTML = `Node IDs: ${geometricSpringNodes.join(', ')}`; } }
        function updateMembraneSelectionInfo() { const infoDiv = document.getElementById('membrane-selection-info'); if (!infoDiv) return; if (selectedMembranes.length === 0) { infoDiv.textContent = 'None.'; } else { infoDiv.innerHTML = `Membrane IDs: ${selectedMembranes.join(', ')}`; } }
        function updateFeSelectionInfo() { const infoDiv = document.getElementById('fe-selection-info'); if (!infoDiv) return; if (selectedFeNodes.length === 0) { infoDiv.textContent = 'None.'; } else { infoDiv.innerHTML = `Count: ${selectedFeNodes.length}<br>IDs: ${selectedFeNodes.slice(0, 10).join(', ')} ${selectedFeNodes.length > 10 ? '...' : ''}`; } }
        function toggleBcInputArea() { const bcArea = document.getElementById('bc-input-area'); if (!bcArea) return; const hasSelection = selectedFeNodes.length > 0; bcArea.hidden = !hasSelection; if (hasSelection) { document.getElementById('bc-type-select').value = 'none'; handleBcTypeChange(); } }
        function handleBcTypeChange() { const selectedType = document.getElementById('bc-type-select')?.value; document.getElementById('bc-fixed-options')?.setAttribute('hidden', ''); document.getElementById('bc-enforced-options')?.setAttribute('hidden', ''); document.getElementById('bc-load-options')?.setAttribute('hidden', ''); if (selectedType === 'fixed') { document.getElementById('bc-fixed-options')?.removeAttribute('hidden'); } else if (selectedType === 'enforced') { document.getElementById('bc-enforced-options')?.removeAttribute('hidden'); } else if (selectedType === 'load') { document.getElementById('bc-load-options')?.removeAttribute('hidden'); } }
        function createMembrane() {
            if (currentMode !== 'add-membrane') { updateStatus("Switch to 'Add Membrane' mode first."); return; } if (selectedNodes.length < 3) { updateStatus(`Select at least 3 nodes first using 'Select Geo Node' mode.`); return; } console.log(`Attempting to create ${selectedNodes.length}-sided membrane from selection`);
            // --- Call the refactored function ---
            const success = createMembraneWithNodes(selectedNodes);
            if (success) {
                clearSelection(true); // Clear selection only if membrane creation was successful
            }
        }

        // --- NEW: Helper to sync Membrane Fill visibility ---
        function drawMembraneFill() {
            membranes.forEach(m => {
                if (m.konvaShape) {
                    m.konvaShape.visible(m.visible !== false); // Default true
                }
            });
            if (membraneFillLayer) membraneFillLayer.batchDraw();
        }

        // --- REFACTORED: createMembrane to accept node data array ---
        function createMembraneWithNodes(nodesDataArray) {
            if (!nodesDataArray || nodesDataArray.length < 3) {
                console.error("Invalid node data array passed to createMembraneWithNodes:", nodesDataArray);
                updateStatus("Error: Invalid nodes for membrane creation.");
                return false; // Indicate failure
            }
            console.log(`Attempting to create ${nodesDataArray.length}-sided membrane with nodes: ${nodesDataArray.map(n => n.id).join(',')}`);

            let nodesAreValid = true;
            const nodeIds = [];
            const points = [];
            const uniqueNodeIds = new Set();

            for (const nodeData of nodesDataArray) {
                if (!nodeData || !nodeData.id || typeof nodeData.x !== 'number' || typeof nodeData.x !== 'number') {
                    console.error("Invalid node data found in array:", nodeData);
                    nodesAreValid = false;
                    break;
                }
                if (uniqueNodeIds.has(nodeData.id)) {
                    console.error("Duplicate node ID found in array:", nodeData.id);
                    updateStatus("Error: Duplicate nodes provided for membrane.");
                    nodesAreValid = false;
                    break;
                }
                uniqueNodeIds.add(nodeData.id);
                nodeIds.push(nodeData.id);
                points.push(nodeData.x, nodeData.y);
            }

            if (!nodesAreValid) {
                console.error("Membrane creation failed due to invalid node data.");
                updateStatus("Error: Invalid node data for membrane.");
                return false; // Indicate failure
            }

            if (typeof Konva === 'undefined' || !Konva.Line) {
                console.error("Konva.Line is not available.");
                alert("Error: Konva.Line constructor not found!");
                return false; // Indicate failure
            }

            let membraneFillShape;
            try {
                membraneFillShape = new Konva.Line({
                    points: points,
                    fill: 'rgba(173, 216, 230, 0.5)',
                    stroke: MEMBRANE_DEFAULT_STROKE,
                    strokeWidth: MEMBRANE_DEFAULT_STROKE_WIDTH, // Use base pixel width
                    strokeScaleEnabled: false, // <--- ADD THIS LINE
                    closed: true,
                    listening: false,
                    draggable: false,
                    opacity: MEMBRANE_DEFAULT_OPACITY,
                    name: 'membrane'
                });
            } catch (error) {
                console.error("Error creating Konva.Line for membrane fill:", error);
                return false; // Indicate failure
            }

            const membraneId = nextMembraneId++;
            const newMembrane = {
                id: membraneId,
                nodeIds: nodeIds,
                konvaShape: membraneFillShape,
                isMeshed: false,
                // Initialize with default material properties
                materialE: DEFAULT_MATERIAL_E,
                materialNu: DEFAULT_MATERIAL_NU,
                materialT: DEFAULT_MATERIAL_T
            };
            membranes.push(newMembrane);

            if (membraneFillLayer) {
                membraneFillLayer.add(membraneFillShape);
                membraneFillLayer.batchDraw();
            } else {
                console.error("Membrane fill layer not available.");
                membranes.pop(); // Rollback if layer is missing
                return false; // Indicate failure
            }

            console.log(`Membrane ${membraneId} created (${nodeIds.length} nodes: ${nodeIds.join(', ')})`);
            updateStatus(`Membrane ${membraneId} created.`);
            updateModelTree(); // Update Model Tree
            return true; // Indicate success
        }
        // --- End Refactored Function ---

        function requestMeshInput() { console.log("Mesh button clicked. Requesting input."); const meshInputArea = document.getElementById('mesh-input-area'); const meshSeparator = document.getElementById('mesh-input-separator'); if (selectedMembranes.length === 0) { alert("Please select one or more membranes first using 'Select Membrane' mode."); updateStatus("Select membranes before meshing."); return; } if (meshInputArea) { meshInputArea.hidden = false; if (meshSeparator) meshSeparator.hidden = false; updateStatus("Enter M(X-dir) x N(Y-dir) divisions and click Confirm."); } else { console.error("Mesh input area not found!"); updateStatus("Error: UI component missing."); } }
        function handleConfirmMesh() { console.log("Confirm Mesh button clicked."); const mInput = document.getElementById('mesh-m-input'); const nInput = document.getElementById('mesh-n-input'); const meshInputArea = document.getElementById('mesh-input-area'); const meshSeparator = document.getElementById('mesh-input-separator'); if (!mInput || !nInput || !meshInputArea) { console.error("Mesh input fields or area not found!"); alert("Error: Cannot find mesh input UI elements."); return; } const M = parseInt(mInput.value, 10); const N = parseInt(nInput.value, 10); console.log("Read M:", M, "Read N:", N); if (isNaN(M) || isNaN(N) || M <= 0 || N <= 0) { alert("Invalid divisions. Both M and N must be positive integers."); updateStatus("Invalid mesh divisions entered."); return; } meshInputArea.hidden = true; if (meshSeparator) meshSeparator.hidden = true; performMeshing(M, N); }
        function performMeshing(M, N) { if (selectedMembranes.length === 0) { console.log("No membranes selected for meshing."); updateStatus("No membranes selected to mesh."); return; } console.log(`Attempting to mesh ${selectedMembranes.length} selected membranes with ${M}x${N} divisions.`); updateStatus(`Meshing selected membranes (${M}x${N})...`); let meshedCount = 0; let skippedCount = 0; let nonQuadCount = 0; selectedMembranes.forEach(membraneId => { const membrane = findMembraneById(membraneId); if (!membrane) { console.warn(`Selected membrane ID ${membraneId} not found.`); skippedCount++; return; } if (membrane.nodeIds.length !== 4) { console.log(`Skipping membrane ${membrane.id}: Not 4-sided.`); nonQuadCount++; return; } if (membrane.isMeshed) { console.log(`Skipping membrane ${membrane.id}: Already meshed.`); skippedCount++; return; } generateStructuredMesh(membrane, M, N); meshedCount++; }); drawMesh(); let meshStatus = `Meshing complete. Meshed: ${meshedCount}.`; if (nonQuadCount > 0) meshStatus += ` Skipped ${nonQuadCount} (not 4-sided).`; if (skippedCount > 0) meshStatus += ` Skipped ${skippedCount} (already meshed/not found).`; updateStatus(meshStatus); console.log(meshStatus); }
        function clearMeshForAffectedMembranes(movedNodeId) { console.log(`Checking for meshes affected by moved node ${movedNodeId}`); const affectedMembranes = membranes.filter(m => m.nodeIds.includes(movedNodeId) && m.isMeshed); if (affectedMembranes.length === 0) { console.log("No currently meshed membranes affected."); return; } console.log(`Found ${affectedMembranes.length} affected meshed membranes:`, affectedMembranes.map(m => m.id)); const feNodesToRemove = new Set(); const feElementsToRemove = new Set(); const feSpringsToRemove = new Set(); affectedMembranes.forEach(membrane => { feNodes.forEach(feN => { if (feN.membraneId === membrane.id) { feNodesToRemove.add(feN.id); } }); feElements.forEach(feE => { if (feE.membraneId === membrane.id) { feElementsToRemove.add(feE.id); } }); membrane.isMeshed = false; console.log(`Marked membrane ${membrane.id} as not meshed.`); }); if (feNodesToRemove.size > 0) { feSprings.forEach(feS => { if (feNodesToRemove.has(feS.feNodeId1) || feNodesToRemove.has(feS.feNodeId2)) { feSpringsToRemove.add(feS.id); } }); } const originalNodeCount = feNodes.length; const originalElementCount = feElements.length; const originalSpringCount = feSprings.length; feNodes = feNodes.filter(feN => !feNodesToRemove.has(feN.id)); feElements = feElements.filter(feE => !feElementsToRemove.has(feE.id)); feSprings = feSprings.filter(feS => !feSpringsToRemove.has(feS.id)); console.log(`Removed ${originalNodeCount - feNodes.length} FE nodes.`); console.log(`Removed ${originalElementCount - feElements.length} FE elements.`); console.log(`Removed ${originalSpringCount - feSprings.length} FE springs.`); }
        function clearMeshData() { feNodes = []; feElements = []; feSprings = []; membranes.forEach(m => m.isMeshed = false); if (meshLayer) { meshLayer.destroyChildren(); meshLayer.batchDraw(); } if (springLayer) { springLayer.destroyChildren(); springLayer.batchDraw(); } if (stressLayer) { stressLayer.destroyChildren(); stressLayer.batchDraw(); } if (reactionLayer) { reactionLayer.destroyChildren(); reactionLayer.batchDraw(); } clearFeSelection(); clearSpringSelection(); console.log("Cleared ALL existing FE mesh, spring, and stress data."); }
        function generateStructuredMesh(membrane, M, N) {
            console.log(`Generating mesh for membrane ${membrane.id}`);
            const cornerNodeIds = membrane.nodeIds;
            let cornerNodes = cornerNodeIds.map(id => findNodeDataById(id));

            if (cornerNodes.some(node => !node)) {
                console.error(`Membrane ${membrane.id} has missing geometric node data.`);
                updateStatus(`Error: Mesh failed for Mem ${membrane.id} (Missing node data).`);
                return; // Stop meshing this membrane
            }

            // --- ADDED: Ensure cornerNodes are sorted Counter-Clockwise (CCW) ---
            if (cornerNodes.length === 4) {
                // 1. Calculate centroid
                let cx = 0, cy = 0;
                cornerNodes.forEach(n => { cx += n.x; cy += n.y; });
                cx /= 4;
                cy /= 4;

                // 2. Calculate angle for each node relative to centroid
                cornerNodes.forEach(n => {
                    n.angle = Math.atan2(n.y - cy, n.x - cx);
                });

                // 3. Sort nodes by angle
                cornerNodes.sort((a, b) => a.angle - b.angle);
                console.log(`Membrane ${membrane.id}: Reordered corner nodes to CCW order: ${cornerNodes.map(n => n.id).join(', ')}`);
            } else {
                console.warn(`Membrane ${membrane.id} is not a quadrilateral. Mesh generation assumes quadrilateral.`);
                // Proceeding anyway, but Jacobians might still be problematic if not quad.
            }
            // --- End Added Section ---

            // Use the (potentially reordered) cornerNodes for mapping
            const [p1, p2, p3, p4] = cornerNodes;

            // The rest of the function remains the same...
            const gridFeNodeIds = Array(M + 1).fill(null).map(() => Array(N + 1).fill(null));
            // ... loop to create feNodes ...
            for (let i = 0; i <= M; i++) {
                for (let j = 0; j <= N; j++) {
                    const u = i / M;
                    const v = j / N;
                    // Ensure mapping uses the potentially reordered p1, p2, p3, p4
                    const x = (1 - u) * (1 - v) * p1.x + u * (1 - v) * p2.x + u * v * p3.x + (1 - u) * v * p4.x;
                    const y = (1 - u) * (1 - v) * p1.y + u * (1 - v) * p2.y + u * v * p3.y + (1 - u) * v * p4.y;
                    const feNodeId = feNodeIdCounter++;
                    // ... rest of node creation ...
                    feNodes.push({ id: feNodeId, x: x, y: y, isBoundary: (i === 0 || i === M || j === 0 || j === N), isSpringConnectionPoint: false, originatingGeometricNodeId: null, membraneId: membrane.id, bc: null }); // Simplified for brevity
                    gridFeNodeIds[i][j] = feNodeId;
                }
            }
            // Assign spring point status and originating IDs after node creation loop
            feNodes.filter(n => n.membraneId === membrane.id).forEach(feN => {
                let originatingGeoId = null;
                // Use a small tolerance for floating point comparison
                const TOL = 1e-6;
                if (Math.abs(feN.x - p1.x) < TOL && Math.abs(feN.y - p1.y) < TOL) originatingGeoId = p1.id;
                else if (Math.abs(feN.x - p2.x) < TOL && Math.abs(feN.y - p2.y) < TOL) originatingGeoId = p2.id;
                else if (Math.abs(feN.x - p3.x) < TOL && Math.abs(feN.y - p3.y) < TOL) originatingGeoId = p3.id;
                else if (Math.abs(feN.x - p4.x) < TOL && Math.abs(feN.y - p4.y) < TOL) originatingGeoId = p4.id;

                if (originatingGeoId !== null) {
                    feN.originatingGeometricNodeId = originatingGeoId;
                    if (geometricSpringNodes.includes(originatingGeoId)) {
                        feN.isSpringConnectionPoint = true;
                    }
                }
            });

            // --- REINSERTED: Element Creation Loop ---
            console.log(`Membrane ${membrane.id}: Creating ${M}x${N} elements...`);
            let elementsCreatedCount = 0;
            for (let i = 0; i < M; i++) {
                for (let j = 0; j < N; j++) {
                    const node_bl = gridFeNodeIds[i]?.[j];
                    const node_br = gridFeNodeIds[i + 1]?.[j];
                    const node_tr = gridFeNodeIds[i + 1]?.[j + 1];
                    const node_tl = gridFeNodeIds[i]?.[j + 1];

                    // Basic check for valid node IDs before creating element
                    if (node_bl === null || node_bl === undefined ||
                        node_br === null || node_br === undefined ||
                        node_tr === null || node_tr === undefined ||
                        node_tl === null || node_tl === undefined) {
                        console.error(`Error creating element (${i},${j}) for membrane ${membrane.id}: Missing node ID.`);
                        continue; // Skip this element if node IDs are invalid
                    }

                    feElements.push({
                        id: feElementIdCounter++,
                        type: 'quad',
                        nodeIds: [node_bl, node_br, node_tr, node_tl], // CCW order
                        membraneId: membrane.id
                    });
                    elementsCreatedCount++;
                }
            }
            console.log(`Membrane ${membrane.id}: Successfully created ${elementsCreatedCount} elements.`);
            // --- End Reinserted Loop ---

            membrane.isMeshed = true;
        }
        function drawMesh() {
            if (!meshLayer || !stage) return;
            const scale = stage.scaleX(); // Get current scale
            meshLayer.destroyChildren();
            const selectedFeSet = new Set(selectedFeNodes);

            feElements.forEach(element => {
                const membrane = findMembraneById(element.membraneId);
                if (membrane && membrane.visible === false) {
                    return; // Skip drawing elements of hidden membranes
                }

                if (element.type === 'quad' && element.nodeIds.length === 4) {
                    const elementNodes = element.nodeIds.map(nodeId => findFeNodeById(nodeId));
                    if (elementNodes.every(n => n)) {
                        const points = elementNodes.flatMap(n => [n.x, n.y]);
                        const meshLine = new Konva.Line({
                            points: points,
                            stroke: isElementSelected(element.id) ? 'orange' : MESH_LINE_COLOR,
                            strokeWidth: isElementSelected(element.id) ? LINE_STROKE_WIDTH_TARGET_PX * 2 : LINE_STROKE_WIDTH_TARGET_PX, // Target pixel width
                            strokeScaleEnabled: false, // Keep constant pixel width
                            closed: true,
                            listening: true, // ENABLE LISTENING for click events/hover
                            id: `element-${element.id}` // Add ID for finding it later if needed (Konva id)
                        });

                        // Add hover pointer
                        meshLine.on('mouseenter', () => { if (currentMode === 'select-element' || currentMode === 'delete-item') stage.container().style.cursor = 'pointer'; });
                        meshLine.on('mouseleave', () => { if (currentMode === 'select-element' || currentMode === 'delete-item') stage.container().style.cursor = 'default'; });

                        // Add click handler
                        meshLine.on('click tap', (e) => {
                            if (currentMode === 'select-element' || currentMode === 'delete-item') {
                                e.cancelBubble = true; // Prevent stage click only in these modes
                                handleElementClick(element);
                            }
                            // Otherwise let it bubble to stage/membrane
                        });

                        meshLayer.add(meshLine);
                    } else { console.warn(`Skipping drawing element ${element.id}, missing node data.`); }
                }
            });

            feNodes.forEach(node => {
                const membrane = findMembraneById(node.membraneId);
                if (membrane && membrane.visible === false) {
                    return; // Skip drawing nodes of hidden membranes
                }

                const isSelected = selectedFeSet.has(node.id);

                // --- Calculate scaled radius ---
                const radiusPx = isSelected ? FE_NODE_SELECTED_RADIUS_TARGET_PX : FE_NODE_RADIUS_TARGET_PX;
                const radius = radiusPx / scale;

                const nodeCircle = new Konva.Circle({
                    x: node.x,
                    y: node.y,
                    radius: radius, // Use scaled radius
                    fill: isSelected ? FE_NODE_SELECTED_COLOR : (node.isSpringConnectionPoint ? SPRING_NODE_COLOR : FE_NODE_COLOR),
                    listening: false
                });
                meshLayer.add(nodeCircle);
                if (node.bc) {
                    drawBcSymbol(node.x, node.y, node.bc); // Pass scale to BC drawing
                }
            });
            meshLayer.batchDraw();
            console.log(`Drew mesh with ${feNodes.length} nodes and ${feElements.length} elements.`);
        }
        function drawBcSymbol(x, y, bcData) {
            if (!meshLayer || !stage) return;
            const scale = stage.scaleX();

            // --- Scale symbol size and offset ---
            const symbolSize = BC_SYMBOL_SIZE_TARGET_PX / scale;
            const nodeRadius = (FE_NODE_RADIUS_TARGET_PX / scale); // Use FE node base radius for offset calc
            const symbolOffset = nodeRadius + (BC_SYMBOL_OFFSET_TARGET_PX / scale);
            const strokeWidth = LINE_STROKE_WIDTH_TARGET_PX; // Target pixel width

            /* Adjusted offset */
            if (bcData.type === 'fixed') {
                if (bcData.value.fixX) {
                    const fixedX = new Konva.RegularPolygon({
                        x: x - symbolOffset, y: y, sides: 3, radius: symbolSize / 2, rotation: 90, fill: 'black',
                        stroke: 'black', strokeWidth: strokeWidth, strokeScaleEnabled: false, // Constant pixel stroke
                        listening: false,
                    });
                    meshLayer.add(fixedX);
                }
                if (bcData.value.fixY) {
                    const fixedY = new Konva.RegularPolygon({
                        x: x, y: y + symbolOffset, sides: 3, radius: symbolSize / 2, rotation: 0, fill: 'black',
                        stroke: 'black', strokeWidth: strokeWidth, strokeScaleEnabled: false, // Constant pixel stroke
                        listening: false,
                    });
                    meshLayer.add(fixedY);
                }
            } else if (bcData.type === 'enforced' || bcData.type === 'load') {
                const isLoad = bcData.type === 'load';
                const val = bcData.value;
                const color = isLoad ? 'red' : 'green';
                const valueX = isLoad ? val.fx : val.dx;
                const valueY = isLoad ? val.fy : val.dy;

                const pointerLength = 4 / scale; // Scale pointer size too
                const pointerWidth = 4 / scale;

                if (valueX !== null && valueX !== 0) {
                    const signX = Math.sign(valueX);
                    // Adjust arrow points based on scaled offset and size
                    const arrowX = new Konva.Arrow({
                        points: [x + signX * symbolOffset / 1.5, y, x + signX * (symbolOffset + symbolSize), y], // Adjusted start point slightly
                        pointerLength: pointerLength, pointerWidth: pointerWidth,
                        fill: color, stroke: color, strokeWidth: strokeWidth, strokeScaleEnabled: false, // Constant pixel pixel stroke
                        listening: false
                    });
                    meshLayer.add(arrowX);
                }
                if (valueY !== null && valueY !== 0) {
                    const signY = Math.sign(valueY);
                    // Adjust arrow points based on scaled offset and size
                    const arrowY = new Konva.Arrow({
                        points: [x, y + signY * symbolOffset / 1.5, x, y + signY * (symbolOffset + symbolSize)], // Adjusted start point slightly
                        pointerLength: pointerLength, pointerWidth: pointerWidth,
                        fill: color, stroke: color, strokeWidth: strokeWidth, strokeScaleEnabled: false, // Constant pixel stroke
                        listening: false
                    });
                    meshLayer.add(arrowY);
                }
            }
        }
        function requestSpringInput() {
            console.log("Create Springs button clicked. Requesting input.");
            if (feNodes.length === 0) {
                alert("Please mesh the membranes first before creating springs.");
                updateStatus("Mesh required before creating springs.");
                return;
            }
            // --- UPDATED: Check for Spring Groups instead of old marked nodes ---
            if (springPointGroups.length === 0) {
                alert("Please create a Spring Grid Group first.");
                updateStatus("No spring groups found.");
                return;
            }
            // Optional: Warn if no group is selected?
            if (!springPointGroups.some(g => g.isSelected)) {
                alert("Please select a Spring Group from the Model Explorer first.");
                updateStatus("No spring group selected.");
                return;
            }

            const springInputArea = document.getElementById('spring-input-area');
            if (springInputArea) {
                springInputArea.hidden = false;
                updateStatus("Enter spring stiffness (k) and click Confirm.");
            } else {
                console.error("Spring input area not found!");
                updateStatus("Error: UI component missing.");
            }
        }
        function handleConfirmSprings() { console.log("Confirm Springs button clicked."); const kInput = document.getElementById('spring-k-input'); const springInputArea = document.getElementById('spring-input-area'); if (!kInput || !springInputArea) { console.error("Spring input field or area not found!"); alert("Error: Cannot find spring input UI elements."); return; } const stiffness = parseFloat(kInput.value); if (isNaN(stiffness) || stiffness <= 0) { alert("Invalid stiffness. Please enter a positive number."); updateStatus("Invalid spring stiffness entered."); return; } springInputArea.hidden = true; performSpringCreation(stiffness); }
        // --- UPDATED: Spring Creation (Append Mode, Check Duplicates) ---
        function performSpringCreation(stiffness) {
            console.log("Creating springs using closest node approach. Stiffness k =", stiffness);
            // feSprings = []; // REMOVED: Do not clear existing springs
            // if (springLayer) springLayer.destroyChildren(); // REMOVED: Do not destroy visuals yet

            // Ensure counter continues correctly
            if (feSprings.length > 0) {
                feSpringIdCounter = Math.max(...feSprings.map(s => s.id)) + 1;
            } else {
                feSpringIdCounter = 1;
            }

            let springsCreatedCount = 0;

            const selectedGroup = springPointGroups.find(g => g.isSelected);
            if (!selectedGroup) {
                alert("Please select a Spring Group first.");
                return;
            }
            const nodesToProcess = selectedGroup.nodeIds;
            console.log(`Processing selected Spring Group: ${selectedGroup.name} (${nodesToProcess.length} nodes)`);

            nodesToProcess.forEach(geoNodeId => {
                const targetNode = findNodeDataById(geoNodeId);
                if (!targetNode) return;

                const targetX = targetNode.x;
                const targetY = targetNode.y;

                const nearbyMembraneNodes = [];
                // Iterate all meshed membranes
                membranes.filter(m => m.isMeshed).forEach(membrane => {
                    let minDistSq = Infinity;
                    let closestNodeId = null;
                    feNodes.filter(feN => feN.membraneId === membrane.id).forEach(feN => {
                        const distSq = (feN.x - targetX) ** 2 + (feN.y - targetY) ** 2;
                        if (distSq < minDistSq) { minDistSq = distSq; closestNodeId = feN.id; }
                    });
                    if (closestNodeId !== null && minDistSq < SPRING_CONN_TOLERANCE_SQ) {
                        nearbyMembraneNodes.push({ membraneId: membrane.id, feNodeId: closestNodeId });
                    }
                });

                if (nearbyMembraneNodes.length >= 2) {
                    for (let i = 0; i < nearbyMembraneNodes.length; i++) {
                        for (let j = i + 1; j < nearbyMembraneNodes.length; j++) {
                            const nodeInfoA = nearbyMembraneNodes[i];
                            const nodeInfoB = nearbyMembraneNodes[j];

                            if (nodeInfoA.membraneId !== nodeInfoB.membraneId) {
                                // Check for duplicate spring
                                const exists = feSprings.some(s =>
                                    (s.feNodeId1 === nodeInfoA.feNodeId && s.feNodeId2 === nodeInfoB.feNodeId) ||
                                    (s.feNodeId1 === nodeInfoB.feNodeId && s.feNodeId2 === nodeInfoA.feNodeId)
                                );

                                if (!exists) {
                                    // --- NEW: Sanity Check for Spring Length ---
                                    // Theoretically, if both are within TOL radius of P, they cannot be further than 2*TOL apart.
                                    const nodeA = findFeNodeById(nodeInfoA.feNodeId);
                                    const nodeB = findFeNodeById(nodeInfoB.feNodeId);
                                    if (nodeA && nodeB) {
                                        const springLenSq = (nodeA.x - nodeB.x) ** 2 + (nodeA.y - nodeB.y) ** 2;

                                        // STRICTER CHECK
                                        const MAX_SPRING_LEN_SQ = 0.1; // Ensure that tolerance of 0.1" is not violated

                                        if (springLenSq <= MAX_SPRING_LEN_SQ) {
                                            const springId = feSpringIdCounter++;
                                            feSprings.push({ id: springId, feNodeId1: nodeInfoA.feNodeId, feNodeId2: nodeInfoB.feNodeId, stiffness: stiffness });
                                            springsCreatedCount++;
                                        } else {
                                            console.warn(`Skipped spurious long spring between Mem ${nodeInfoA.membraneId} and Mem ${nodeInfoB.membraneId} (LenSq: ${springLenSq.toFixed(1)})`);
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            });

            drawSprings(); // Redraws all springs (new + old)
            updateStatus(`Created ${springsCreatedCount} new springs for group "${selectedGroup.name}". (Total: ${feSprings.length})`);
            console.log(`Finished creating springs. Total: ${feSprings.length}`);
        }

        // --- NEW: Highlight Selected Spring Group Nodes ---
        function updateSpringGroupHighlights() {
            if (!stage) return;
            const scale = stage.scaleX();
            const selectedGroup = springPointGroups.find(g => g.isSelected);
            const selectedNodeIds = selectedGroup ? new Set(selectedGroup.nodeIds) : new Set();

            nodes.forEach(node => {
                if (node.konvaCircle) {
                    // Apply scale to base radius
                    let radius = NODE_RADIUS_TARGET_PX / scale;

                    if (selectedNodeIds.has(node.id)) {
                        // Highlight color (e.g., Bright Green or Magenta)
                        node.konvaCircle.fill('#00FF00'); // Green for selected group
                        node.konvaCircle.stroke('black');
                        radius *= 1.5; // Larger
                        node.isSpringGroupSelected = true; // Flag for zoom updates
                    } else {
                        node.isSpringGroupSelected = false; // Reset flag
                        // Default logic (check if it's in ANY group? or just reset)
                        const isInAnyGroup = springPointGroups.some(g => g.nodeIds.includes(node.id));
                        if (isInAnyGroup) {
                            node.konvaCircle.fill('purple'); // Default for spring nodes
                        } else {
                            node.konvaCircle.fill('black'); // Regular nodes
                        }
                        node.konvaCircle.stroke(null);
                    }
                    node.konvaCircle.radius(radius);
                }
            });
            if (geometryLayer) geometryLayer.batchDraw();
        }
        function drawSprings() {
            // console.log("--- drawSprings() CALLED ---"); // Keep logs minimal if needed
            if (!springLayer || !stage) { return; }
            springLayer.destroyChildren();
            const scale = stage.scaleX(); // Get scale ONLY for calculating initial world offset
            const isFilterOn = document.getElementById('chk-filter-results')?.checked || false;

            feSprings.forEach(spring => {
                const node1 = findFeNodeById(spring.feNodeId1);
                const node2 = findFeNodeById(spring.feNodeId2);

                if (node1 && node2) {
                    let shouldDraw = true;
                    if (isFilterOn && selectedMembranes.length > 0) {
                        const m1 = node1.membraneId;
                        const m2 = node2.membraneId;
                        // A spring is drawn if at least one of its connected FE nodes belongs to a selected membrane.
                        shouldDraw = (m1 && selectedMembranes.includes(m1)) || (m2 && selectedMembranes.includes(m2));
                    }

                    if (!shouldDraw) return; // Skip drawing this spring if filtered out

                    const isSelected = selectedFeSprings.includes(spring.id);

                    const line = new Konva.Line({
                        points: [node1.x, node1.y, node2.x, node2.y],
                        stroke: isSelected ? SPRING_SELECTED_COLOR : SPRING_LINE_COLOR,
                        strokeWidth: isSelected ? SPRING_SELECTED_WIDTH_PX : LINE_STROKE_WIDTH_TARGET_PX,
                        strokeScaleEnabled: false,
                        dash: isSelected ? [] : [8 / scale, 4 / scale], // No dash for selected springs
                        listening: true, // Enable listening for clicks
                        name: `spring-line-${spring.id}`
                    });

                    // Add hover pointer
                    line.on('mouseenter', () => { if (currentMode === 'select-springs-box' || currentMode === 'delete-item') stage.container().style.cursor = 'pointer'; });
                    line.on('mouseleave', () => { if (currentMode === 'select-springs-box' || currentMode === 'delete-item') stage.container().style.cursor = 'default'; });

                    // Add click handler
                    line.on('click tap', (e) => {
                        if (currentMode === 'select-springs-box' || currentMode === 'delete-item') {
                            e.cancelBubble = true; // Prevent stage click only in these modes
                            handleSpringClick(spring);
                        }
                    });

                    // Add to layer
                    springLayer.add(line);

                    // --- Check for and Prepare Spring Label Text ---
                    const springResult = resultsSpringLoads?.find(r => r.id === spring.id);
                    let labelTextContent;
                    let labelFillColor = isSelected ? SPRING_SELECTED_COLOR : SPRING_LABEL_COLOR;

                    if (springResult && springResult.fx !== undefined && springResult.fy !== undefined) {
                        // Get numerical values first
                        const fxNum = Number(springResult.fx);
                        const fyNum = Number(springResult.fy);

                        // Calculate Resultant Force (FR)
                        const frNum = Math.sqrt(fxNum * fxNum + fyNum * fyNum);

                        // Format all values to 2 decimal places
                        const fxFormatted = fxNum.toFixed(2);
                        const fyFormatted = fyNum.toFixed(2);
                        const frFormatted = frNum.toFixed(2); // Format FR

                        // Create the 3-line label text including FR
                        labelTextContent = `Fx: ${fxFormatted}\nFy: ${fyFormatted}\nFR: ${frFormatted}`;
                    } else {
                        labelTextContent = `S${spring.id}\nk=${spring.stiffness}`;
                    }

                    // Calculate midpoint for label positioning
                    const midX = (node1.x + node2.x) / 2;
                    const midY = (node1.y + node2.y) / 2;

                    // Calculate perpendicular offset for label
                    const dx = node2.x - node1.x;
                    const dy = node2.y - node1.y;
                    const len = Math.sqrt(dx * dx + dy * dy);
                    const perpX = -dy / (len || 1);
                    const perpY = dx / (len || 1);

                    // --- Create the Label with Fixed Font Size and Counter-Scaling ---
                    const labelToShow = new Konva.Text({
                        x: midX + perpX * (SPRING_RESULT_LABEL_OFFSET_PX / scale),
                        y: midY + perpY * (SPRING_RESULT_LABEL_OFFSET_PX / scale),
                        text: labelTextContent,
                        fontSize: SPRING_LABEL_FIXED_FONT_SIZE, // Use FIXED pixel font size
                        fill: labelFillColor,
                        listening: false,
                        scaleX: 1 / scale,                    // Apply initial counter-scaling
                        scaleY: 1 / scale,                    // Apply initial counter-scaling
                        verticalAlign: 'middle',             // Center vertically
                        align: 'center'
                    });

                    springLayer.add(labelToShow);

                } // end if(node1 && node2)
            }); // End forEach spring

            springLayer.batchDraw();
            // console.log(`Drew ${feSprings.length} springs (fixed size labels).`);
        }
        function handleApplyBc() { const type = document.getElementById('bc-type-select').value; console.log(`Applying BC Type: ${type} to ${selectedFeNodes.length} nodes.`); if (selectedFeNodes.length === 0) { updateStatus("No FE nodes selected to apply BC."); return; } let bcData = null; try { if (type === 'fixed') { const fixX = document.getElementById('bc-fix-x').checked; const fixY = document.getElementById('bc-fix-y').checked; if (!fixX && !fixY) { alert("For 'Fixed' BC, please select at least one direction (X or Y)."); return; } bcData = { type: 'fixed', value: { fixX: fixX, fixY: fixY } }; } else if (type === 'enforced') { const enforceX = document.getElementById('bc-enforce-x').checked; const enforceY = document.getElementById('bc-enforce-y').checked; const dxStr = document.getElementById('bc-dx-input').value; const dyStr = document.getElementById('bc-dy-input').value; let dx = null; let dy = null; if (!enforceX && !enforceY) { alert("For 'Enforced' BC, please check at least one direction (X or Y) to enforce."); return; } if (enforceX) { if (dxStr.trim() === '') { alert("Please enter a Dx value if 'Enforce X' is checked."); return; } dx = parseFloat(dxStr); if (isNaN(dx)) { alert("Invalid Dx value. Please enter a number."); return; } } if (enforceY) { if (dyStr.trim() === '') { alert("Please enter a Dy value if 'Enforce Y' is checked."); return; } dy = parseFloat(dyStr); if (isNaN(dy)) { alert("Invalid Dy value. Please enter a number."); return; } } bcData = { type: 'enforced', value: { dx: dx, dy: dy } }; } else if (type === 'load') { const fxStr = document.getElementById('bc-fx-input').value; const fyStr = document.getElementById('bc-fy-input').value; if (fxStr.trim() === '' || fyStr.trim() === '') { alert("Please enter values for Fx and Fy."); return; } const fx = parseFloat(fxStr); const fy = parseFloat(fyStr); if (isNaN(fx) || isNaN(fy)) { alert("Invalid Fx or Fy value. Please enter numbers."); return; } bcData = { type: 'load', value: { fx: fx, fy: fy } }; } } catch (error) { console.error("Error processing BC input:", error); alert("An error occurred while processing BC input."); return; } const nodesAffected = selectedFeNodes.length; selectedFeNodes.forEach(feNodeId => { const node = findFeNodeById(feNodeId); if (node) { node.bc = bcData; } else { console.warn(`Could not find FE Node ${feNodeId} to apply BC.`); } }); console.log("Applied BC Data:", bcData); clearFeSelection(); updateStatus(`Applied BC type '${type}' to ${nodesAffected} nodes.`); }
        function handleApplyMaterialProperties() {
            console.log("Applying material properties to selected membranes...");
            if (selectedMembranes.length === 0) {
                updateStatus("No membranes selected to apply properties to.");
                return;
            }

            const inputE = document.getElementById('mem-mat-prop-e');
            const inputNu = document.getElementById('mem-mat-prop-nu');
            const inputT = document.getElementById('mem-mat-prop-t');
            let valid = true;
            const e_val = parseFloat(inputE?.value);
            const nu_val = parseFloat(inputNu?.value);
            const t_val = parseFloat(inputT?.value);

            if (isNaN(e_val) || e_val <= 0) { alert("Invalid Young's Modulus (E). Must be positive number."); valid = false; }
            if (isNaN(nu_val) || nu_val < 0 || nu_val > 0.5) { alert("Invalid Poisson's Ratio (nu). Must be between 0 and 0.5."); valid = false; }
            if (isNaN(t_val) || t_val <= 0) { alert("Invalid Thickness (t). Must be positive number."); valid = false; }

            if (!valid) {
                console.error("Invalid material properties entered.");
                updateStatus("Error: Invalid material properties.");
                return;
            }

            let updatedCount = 0;
            selectedMembranes.forEach(memId => {
                const membrane = findMembraneById(memId);
                if (membrane) {
                    membrane.materialE = e_val;
                    membrane.materialNu = nu_val;
                    membrane.materialT = t_val;
                    updatedCount++;
                    console.log(`Updated material for Membrane ${memId}: E=${e_val}, nu=${nu_val}, t=${t_val}`);
                } else {
                    console.warn(`Could not find membrane ${memId} to update properties.`);
                }
            });

            updateStatus(`Applied properties to ${updatedCount} selected membranes.`);
        }

        // --- NEW: Element Selection Helpers ---
        function isElementSelected(id) {
            return selectedFeElements.includes(id);
        }

        function toggleElementSelection(element) {
            if (!element) return;
            const index = selectedFeElements.indexOf(element.id);
            if (index > -1) {
                selectedFeElements.splice(index, 1);
                console.log(`Deselected Element ${element.id}`);
            } else {
                if (currentMode === 'select-element') {
                    // For now multi-select allowed? Or singular? Let's allow multi for bulk delete, maybe singular for properties to avoid confusion initially.
                    // For property editing, usually singular is safer OR bulk apply.
                    // Let's allow multi-select.
                    selectedFeElements.push(element.id);
                    console.log(`Selected Element ${element.id}`);
                }
            }
            updateElementSelectionInfo();
            updateElementPropertyDisplay(); // Show/Hide panel
            drawMesh(); // Redraw to update highlight
        }

        function clearFeElementSelection() {
            selectedFeElements = [];
            updateElementSelectionInfo();
            updateElementPropertyDisplay();
            drawMesh();
        }

        function handleElementClick(element) {
            console.log(`Clicked Element ${element.id} in mode ${currentMode}`);
            if (currentMode === 'select-element') {
                toggleElementSelection(element);
            } else if (currentMode === 'delete-item') {
                if (confirm(`Delete Element ${element.id}?`)) {
                    deleteElement(element.id);
                }
            }
        }

        function deleteElement(id) {
            console.log(`Deleting Element ${id}`);
            const idx = feElements.findIndex(e => e.id === id);
            if (idx > -1) {
                feElements.splice(idx, 1);
                // Also should remove it from selection if present
                const selIdx = selectedFeElements.indexOf(id);
                if (selIdx > -1) selectedFeElements.splice(selIdx, 1);

                // Note: We are NOT removing the nodes, just the element connectivity.
                // This creates a hole in the mesh.

                updateElementSelectionInfo();
                updateElementPropertyDisplay();
                cleanupOrphanFeNodes(); // Clean up orphans
                drawMesh(); // Redraw after cleanup
                updateStatus(`Element ${id} deleted.`);
            }
        }

        // --- New Spring Bulk Operations ---
        function deleteSelectedSprings() {
            if (selectedFeSprings.length === 0) return;
            if (!confirm(`Delete ${selectedFeSprings.length} selected springs?`)) return;

            const initialCount = feSprings.length;
            feSprings = feSprings.filter(s => !selectedFeSprings.includes(s.id));
            const deletedCount = initialCount - feSprings.length;

            console.log(`Deleted ${deletedCount} springs.`);
            updateStatus(`Deleted ${deletedCount} springs.`);

            clearSpringSelection();
            // drawSprings(); // handled by clearSpringSelection
        }

        function updateSelectedSpringsStiffness() {
            if (selectedFeSprings.length === 0) return;
            const kVal = parseFloat(document.getElementById('spring-prop-k').value);
            if (isNaN(kVal)) { alert("Invalid Stiffness K"); return; }

            let count = 0;
            feSprings.forEach(s => {
                if (selectedFeSprings.includes(s.id)) {
                    s.stiffness = kVal;
                    count++;
                }
            });

            updateStatus(`Updated stiffness for ${count} springs to k=${kVal}.`);
            drawSprings(); // Redraw (labels might show K)
        }

        function clearFeElementSelection() {
            selectedFeElements = [];
            updateElementSelectionInfo();
            updateElementPropertyDisplay();
            drawMesh();
        }

        function clearSpringSelection() {
            selectedFeSprings = [];
            updateSpringSelectionInfo();
            document.getElementById('spring-properties-area').hidden = true;
            drawSprings();
        }

        function updateSpringSelectionInfo() {
            // Show/Hide panel, update count
            const countSpan = document.getElementById('spring-sel-count');
            const panel = document.getElementById('spring-properties-area');
            if (countSpan) countSpan.textContent = selectedFeSprings.length;

            if (selectedFeSprings.length > 0) {
                panel.hidden = false;
            } else {
                panel.hidden = true;
            }
        }

        // --- FEA Calculations ---
        function zeros(rows, cols) { return Array(rows).fill(0).map(() => Array(cols).fill(0)); }
        function matrixMultiply(A, B) { const A_rows = A.length; const A_cols = A[0]?.length || 0; const B_rows = B.length; const B_cols = B[0]?.length || 0; if (A_cols !== B_rows) { console.error("Incompatible matrices for multiplication", A_cols, B_rows); return null; } const C = zeros(A_rows, B_cols); for (let i = 0; i < A_rows; i++) { for (let j = 0; j < B_cols; j++) { for (let k = 0; k < A_cols; k++) { C[i][j] += (A[i]?.[k] || 0) * (B[k]?.[j] || 0); } } } return C; }
        function matrixTranspose(A) { const A_rows = A.length; const A_cols = A[0]?.length || 0; const C = zeros(A_cols, A_rows); for (let i = 0; i < A_rows; i++) { for (let j = 0; j < A_cols; j++) { C[j][i] = A[i][j]; } } return C; }
        function matrixAdd(A, B) { const A_rows = A.length; const A_cols = A[0]?.length || 0; const C = zeros(A_rows, A_cols); for (let i = 0; i < A_rows; i++) { for (let j = 0; j < A_cols; j++) { C[i][j] = (A[i]?.[j] || 0) + (B[i]?.[j] || 0); } } return C; }
        function scalarMultiply(scalar, A) { const A_rows = A.length; const A_cols = A[0]?.length || 0; const C = zeros(A_rows, A_cols); for (let i = 0; i < A_rows; i++) { for (let j = 0; j < A_cols; j++) { C[i][j] = scalar * (A[i]?.[j] || 0); } } return C; }
        function matrixVectorMultiply(A, v) { const A_rows = A.length; const A_cols = A[0]?.length || 0; const v_rows = v.length; if (A_cols !== v_rows) { console.error("Incompatible matrix/vector for multiplication"); return null; } const C = Array(A_rows).fill(0); for (let i = 0; i < A_rows; i++) { for (let k = 0; k < A_cols; k++) { C[i] += (A[i]?.[k] || 0) * (v[k] || 0); } } return C; }
        function calculateQuadElementStiffness(elementNodes, E, nu, t) { /* console.log(`Calculating stiffness for quad element [${elementNodes.map(n=>n.id).join(',')}]`); */ const Ke = zeros(8, 8); const coords = elementNodes.map(n => ({ x: n.x, y: n.y })); const D = zeros(3, 3); const E_factor = E / (1.0 - nu * nu); D[0][0] = E_factor; D[0][1] = E_factor * nu; D[1][0] = E_factor * nu; D[1][1] = E_factor; D[2][2] = E_factor * (1.0 - nu) / 2.0; const gpVal = 1.0 / Math.sqrt(3.0); const gaussPoints = [{ xi: -gpVal, eta: -gpVal }, { xi: gpVal, eta: -gpVal }, { xi: gpVal, eta: gpVal }, { xi: -gpVal, eta: gpVal }]; const gaussWeights = [1.0, 1.0, 1.0, 1.0]; for (let gp = 0; gp < gaussPoints.length; gp++) { const xi = gaussPoints[gp].xi; const eta = gaussPoints[gp].eta; const weight = gaussWeights[gp]; const dNdXiEta = [[-0.25 * (1 - eta), 0.25 * (1 - eta), 0.25 * (1 + eta), -0.25 * (1 + eta)], [-0.25 * (1 - xi), -0.25 * (1 + xi), 0.25 * (1 + xi), 0.25 * (1 - xi)]]; const J = zeros(2, 2); for (let i = 0; i < 4; i++) { J[0][0] += dNdXiEta[0][i] * coords[i].x; J[0][1] += dNdXiEta[0][i] * coords[i].y; J[1][0] += dNdXiEta[1][i] * coords[i].x; J[1][1] += dNdXiEta[1][i] * coords[i].y; } const detJ = J[0][0] * J[1][1] - J[0][1] * J[1][0]; if (detJ <= 1e-9) { console.error(`Element ${elementNodes.map(n => n.id).join(',')} has zero/negative Jacobian det (${detJ.toFixed(3)}) at GP ${gp}. Skipping GP.`); continue; } const invDetJ = 1.0 / detJ; const invJ = [[invDetJ * J[1][1], -invDetJ * J[0][1]], [-invDetJ * J[1][0], invDetJ * J[0][0]]]; const dNdXY = zeros(4, 2); for (let i = 0; i < 4; i++) { dNdXY[i][0] = invJ[0][0] * dNdXiEta[0][i] + invJ[0][1] * dNdXiEta[1][i]; dNdXY[i][1] = invJ[1][0] * dNdXiEta[0][i] + invJ[1][1] * dNdXiEta[1][i]; } const B = zeros(3, 8); for (let i = 0; i < 4; i++) { B[0][2 * i] = dNdXY[i][0]; B[0][2 * i + 1] = 0; B[1][2 * i] = 0; B[1][2 * i + 1] = dNdXY[i][1]; B[2][2 * i] = dNdXY[i][1]; B[2][2 * i + 1] = dNdXY[i][0]; } const B_T = matrixTranspose(B); const D_B = matrixMultiply(D, B); const B_T_D_B = matrixMultiply(B_T, D_B); if (B_T_D_B) { const scalarFactor = t * detJ * weight * weight; const Ke_gp = scalarMultiply(scalarFactor, B_T_D_B); for (let r = 0; r < 8; r++) { for (let c = 0; c < 8; c++) { Ke[r][c] += Ke_gp[r][c]; } } } else { console.error(`Matrix multiplication failed for element ${elementNodes.map(n => n.id).join(',')}, GP ${gp}`); } } return Ke; }
        function calculateSpringElementStiffness(node1, node2, k) { const k_matrix = [[k, 0, -k, 0], [0, k, 0, -k], [-k, 0, k, 0], [0, -k, 0, k]]; return k_matrix; }
        // --- Revert to Dense assembleGlobalMatrices ---
        // --- Assemble Global Matrices using math.js sparse ---
        function assembleGlobalMatrices() {
            console.log("Assembling global matrices (math.js Sparse)...");
            if (feNodes.length === 0) { console.error("No FE nodes exist for assembly."); return null; }
            const numNodes = feNodes.length;
            const N_DOF = numNodes * 2;
            console.log(`System size: ${numNodes} nodes, ${N_DOF} DOFs`);

            // Initialize math.js sparse matrix and dense vector
            let K_global = math.sparse(); // Correct: Initialize empty sparse matrix
            let F_global = math.zeros(N_DOF); // Initialize dense force vector (math.js matrix object)
            const nodeIndexMap = new Map();
            feNodes.forEach((node, index) => nodeIndexMap.set(node.id, index));

            // Helper to add entries to the sparse matrix (math.js handles summing duplicates)
            const addSparseEntry = (r, c, value) => {
                if (Math.abs(value) > 1e-12) { // Avoid adding explicit zeros (optional optimization)
                    try {
                        // Get existing value, add new, then set
                        K_global.set([r, c], (K_global.get([r, c]) || 0) + value);
                    } catch (e) {
                        // If get fails (entry doesn't exist), just set the new value
                        if (e.message && e.message.includes("Index out of range")) { // More specific check if needed
                            K_global.set([r, c], value);
                        } else {
                            console.error(`Error setting sparse matrix entry at (${r}, ${c}):`, e);
                        }
                    }
                }
            };

            // Process elements
            feElements.forEach(element => {
                if (element.type === 'quad' && element.nodeIds.length === 4) {
                    const elementNodes = element.nodeIds.map(id => findFeNodeById(id));
                    if (elementNodes.every(n => n)) {
                        const membrane = findMembraneById(element.membraneId);
                        if (!membrane) { console.error(`Membrane ${element.membraneId} not found for element ${element.id}. Skipping.`); return; }
                        const E = element.propE !== undefined ? element.propE : (membrane.materialE ?? DEFAULT_MATERIAL_E);
                        const nu = element.propNu !== undefined ? element.propNu : (membrane.materialNu ?? DEFAULT_MATERIAL_NU);
                        const t = element.propT !== undefined ? element.propT : (membrane.materialT ?? DEFAULT_MATERIAL_T);
                        if (isNaN(E) || isNaN(nu) || isNaN(t) || E <= 0 || t <= 0 || nu < 0 || nu >= 0.5) {
                            console.error(`Invalid material for membrane ${membrane.id}, element ${element.id}. Skipping.`);
                            updateStatus(`Error: Invalid material on Membrane ${membrane.id}`);
                            throw new Error(`Invalid material on Membrane ${membrane.id}`); // Halt assembly
                        }
                        const Ke = calculateQuadElementStiffness(elementNodes, E, nu, t); // Ke is standard JS array

                        // Assemble into global matrix using the helper
                        element.nodeIds.forEach((nodeId_i, i) => {
                            const globalRowIndex = nodeIndexMap.get(nodeId_i);
                            if (globalRowIndex === undefined) return;
                            element.nodeIds.forEach((nodeId_j, j) => {
                                const globalColIndex = nodeIndexMap.get(nodeId_j);
                                if (globalColIndex === undefined) return;
                                // Add all 4 entries for the K_ij block
                                addSparseEntry(2 * globalRowIndex, 2 * globalColIndex, Ke[2 * i]?.[2 * j] || 0);
                                addSparseEntry(2 * globalRowIndex, 2 * globalColIndex + 1, Ke[2 * i]?.[2 * j + 1] || 0);
                                addSparseEntry(2 * globalRowIndex + 1, 2 * globalColIndex, Ke[2 * i + 1]?.[2 * j] || 0);
                                addSparseEntry(2 * globalRowIndex + 1, 2 * globalColIndex + 1, Ke[2 * i + 1]?.[2 * j + 1] || 0);
                            });
                        });
                    }
                }
            });

            // Process springs
            feSprings.forEach(spring => {
                const node1 = findFeNodeById(spring.feNodeId1);
                const node2 = findFeNodeById(spring.feNodeId2);
                if (node1 && node2) {
                    const Ks = calculateSpringElementStiffness(node1, node2, spring.stiffness); // Ks is standard JS array
                    const globalIndex1 = nodeIndexMap.get(node1.id);
                    const globalIndex2 = nodeIndexMap.get(node2.id);
                    if (globalIndex1 !== undefined && globalIndex2 !== undefined) {
                        const dofMap = [2 * globalIndex1, 2 * globalIndex1 + 1, 2 * globalIndex2, 2 * globalIndex2 + 1];
                        for (let i = 0; i < 4; i++) {
                            for (let j = 0; j < 4; j++) {
                                addSparseEntry(dofMap[i], dofMap[j], Ks[i]?.[j] || 0);
                            }
                        }
                    }
                }
            });

            // Populate the dense force vector using math.subset and math.index
            feNodes.forEach(node => {
                if (node.bc && node.bc.type === 'load') {
                    const globalIndex = nodeIndexMap.get(node.id);
                    if (globalIndex !== undefined) {
                        const currentFx = math.subset(F_global, math.index(2 * globalIndex)) || 0;
                        const currentFy = math.subset(F_global, math.index(2 * globalIndex + 1)) || 0;
                        F_global = math.subset(F_global, math.index(2 * globalIndex), currentFx + (node.bc.value.fx ?? 0));
                        F_global = math.subset(F_global, math.index(2 * globalIndex + 1), currentFy + (node.bc.value.fy ?? 0));
                    }
                }
            });

            console.log(`Global matrices assembled (math.js Sparse: ${K_global.size()[0]}x${K_global.size()[1]}, ${K_global.toJSON().values.length} non-zeros).`);
            return { K_global, F_global, nodeIndexMap, N_DOF }; // Return math.js sparse K and dense F
        }

        // --- MODIFIED: applyBoundaryConditions using Hybrid Method (Direct for Fixed, Penalty for Enforced) ---
        function applyBoundaryConditions(K_global, F_global, nodeIndexMap, N_DOF) {
            console.log("Applying boundary conditions (Hybrid: Direct-Fixed, Penalty-Enforced)...");
            const K_modified = math.clone(K_global); // K_global is math.js sparse matrix
            let F_modified = math.clone(F_global);   // F_global is math.js dense vector/matrix - USE LET
            const knownDisplacementIndices = new Set(); // Keep track of constrained DOFs

            const PENALTY_MAGNITUDE = 1e10; // Reintroduce penalty magnitude

            try {
                feNodes.forEach(node => {
                    if (node.bc && (node.bc.type === 'fixed' || node.bc.type === 'enforced')) {
                        const globalIndex = nodeIndexMap.get(node.id);
                        if (globalIndex === undefined) { console.warn(`Node ID ${node.id} not found in map.`); return; }

                        const dofX = 2 * globalIndex;
                        const dofY = 2 * globalIndex + 1;
                        if (dofX >= N_DOF || dofY >= N_DOF) { console.error(`DOF index out of bounds for node ${node.id}.`); return; }

                        // --- Fixed BCs (Direct Method - Zeroing) ---
                        if (node.bc.type === 'fixed') {
                            const fixX = node.bc.value.fixX;
                            const fixY = node.bc.value.fixY;

                            if (fixX) {
                                // console.log(`Applying direct BC to DOF ${dofX} (Node ${node.id} X), value=0`);
                                // Zero out row dofX & col dofX (Optional: subset method might be faster)
                                for (let j = 0; j < N_DOF; j++) { if (j !== dofX) K_modified.set([dofX, j], 0); }
                                for (let i = 0; i < N_DOF; i++) { if (i !== dofX) K_modified.set([i, dofX], 0); }
                                K_modified.set([dofX, dofX], 1); // Set diagonal to 1
                                F_modified = math.subset(F_modified, math.index(dofX), 0); // Set force to 0
                                knownDisplacementIndices.add(dofX);
                            }
                            if (fixY) {
                                // console.log(`Applying direct BC to DOF ${dofY} (Node ${node.id} Y), value=0`);
                                // Zero out row dofY & col dofY
                                for (let j = 0; j < N_DOF; j++) { if (j !== dofY) K_modified.set([dofY, j], 0); }
                                for (let i = 0; i < N_DOF; i++) { if (i !== dofY) K_modified.set([i, dofY], 0); }
                                K_modified.set([dofY, dofY], 1); // Set diagonal to 1
                                F_modified = math.subset(F_modified, math.index(dofY), 0); // Set force to 0
                                knownDisplacementIndices.add(dofY);
                            }
                        }
                        // --- Enforced BCs (Penalty Method) ---
                        else if (node.bc.type === 'enforced') {
                            const enforceX = node.bc.value.dx !== null;
                            const enforceY = node.bc.value.dy !== null;
                            const dx = node.bc.value.dx ?? 0;
                            const dy = node.bc.value.dy ?? 0;
                            const penalty = PENALTY_MAGNITUDE;

                            if (enforceX) {
                                console.log(`Applying penalty BC to DOF ${dofX} (Node ${node.id} X), value=${dx}`);
                                const currentDiagX = K_modified.get([dofX, dofX]) || 0;
                                K_modified.set([dofX, dofX], currentDiagX + penalty); // K[k,k] += penalty

                                const currentForceX = math.subset(F_modified, math.index(dofX)) || 0;
                                F_modified = math.subset(F_modified, math.index(dofX), currentForceX + penalty * dx); // F[k] += penalty * d_prescribed
                                knownDisplacementIndices.add(dofX);
                            }
                            if (enforceY) {
                                console.log(`Applying penalty BC to DOF ${dofY} (Node ${node.id} Y), value=${dy}`);
                                const currentDiagY = K_modified.get([dofY, dofY]) || 0;
                                K_modified.set([dofY, dofY], currentDiagY + penalty); // K[k,k] += penalty

                                const currentForceY = math.subset(F_modified, math.index(dofY)) || 0;
                                F_modified = math.subset(F_modified, math.index(dofY), currentForceY + penalty * dy); // F[k] += penalty * d_prescribed
                                knownDisplacementIndices.add(dofY);
                            }
                        }
                    }
                });
            } catch (error) {
                console.error("Error applying BCs (Hybrid Method):", error);
                updateStatus("Error during BC application.");
                return null; // Indicate failure
            }

            console.log(`Boundary conditions applied (Hybrid). ${knownDisplacementIndices.size} DOFs constrained.`);
            return { K_modified, F_modified, knownDisplacementIndices }; // Return math.js sparse K and dense F
        }
        // --- Revert to Dense solveSystem using helper ---
        // --- Update solveSystem for math.js sparse ---
        function solveSystem(K_modified, F_modified, N_DOF) {
            console.log("Solving system (math.js Sparse) ...");
            if (typeof math === 'undefined' || typeof math.lusolve !== 'function') {
                console.error("math.js library or lusolve function not loaded. Cannot solve.");
                alert("Error: math.js library not found or incomplete.");
                return null;
            }
            try {
                // Ensure F_modified is a 1D matrix (column vector) for lusolve if it isn't already
                if (F_modified.size().length > 1 && F_modified.size()[1] !== 1) {
                    console.warn("Reshaping F_modified to column vector for lusolve");
                    F_modified = math.reshape(F_modified, [N_DOF, 1]);
                } else if (F_modified.size().length === 1) {
                    // If it's a flat array, convert to Nx1 matrix
                    F_modified = math.reshape(F_modified, [N_DOF, 1]);
                }

                console.time("MathJsSparseSolve");
                // Solve using sparse LU decomposition provided by math.js
                const d_matrix = math.lusolve(K_modified, F_modified);
                console.timeEnd("MathJsSparseSolve");

                // lusolve returns a Matrix object, convert it to a flat JS array
                const d_vec = d_matrix.toArray().flat();

                if (!d_vec || d_vec.length !== N_DOF) {
                    console.error("Solver returned unexpected format or size.", d_vec);
                    throw new Error(`Solver failed or returned vector of incorrect size. Expected ${N_DOF}, Got ${d_vec?.length}`);
                }
                console.log("System solved successfully (math.js Sparse).");
                return d_vec; // Return standard JS array
            } catch (error) {
                console.error("Error solving sparse system with math.js:", error);
                // Attempt to provide more specific feedback for common math.js errors
                if (error.message && error.message.toLowerCase().includes("matrix is singular")) {
                    alert(`Analysis failed: Matrix is singular. Check boundary conditions (ensure sufficient constraints) and mesh quality.`);
                } else if (error.message && error.message.toLowerCase().includes("dimension mismatch")) {
                    alert(`Analysis failed: Dimension mismatch during solve. K(${K_modified.size().join(',')}), F(${F_modified.size().join(',')})`);
                } else {
                    alert(`Analysis failed: ${error.message}. Check BCs/mesh.`);
                }
                updateStatus("Analysis failed: Solver error.");
                return null;
            }
        }

        // Helper function for Gaussian elimination (already present in the file)
        function solveDenseLinearSystem(A, b) {
            const n = A.length;
            if (n === 0 || A[0].length !== n || b.length !== n) {
                console.error("Invalid input to solveDenseLinearSystem:", A, b);
                return null;
            }
            // Augment matrix (Create a copy to avoid modifying original A if it's needed elsewhere)
            const Aug = A.map((row, i) => [...row, b[i]]);

            // Forward elimination
            for (let i = 0; i < n; i++) {
                let pivot = i;
                for (let j = i + 1; j < n; j++) { if (Math.abs(Aug[j][i]) > Math.abs(Aug[pivot][i])) { pivot = j; } }
                [Aug[i], Aug[pivot]] = [Aug[pivot], Aug[i]]; // Swap rows

                if (Math.abs(Aug[i][i]) < 1e-12) {
                    console.warn(`Zero pivot encountered at row ${i}. Matrix might be singular.`);
                    continue; // Skip this row if pivot is effectively zero
                }

                for (let j = i + 1; j < n; j++) {
                    const factor = Aug[j][i] / Aug[i][i];
                    for (let k = i; k <= n; k++) { // Iterate through the augmented part too
                        Aug[j][k] -= factor * Aug[i][k];
                    }
                }
            }

            // Back substitution
            const x = Array(n);
            for (let i = n - 1; i >= 0; i--) {
                if (Math.abs(Aug[i][i]) < 1e-12) {
                    console.error(`System may be singular or has no unique solution (zero on diagonal at row ${i} after elimination).`);
                    // Decide whether to return null or partial solution based on needs
                    return null; // Indicate failure
                }
                let sum = 0;
                for (let j = i + 1; j < n; j++) { sum += Aug[i][j] * x[j]; }
                x[i] = (Aug[i][n] - sum) / Aug[i][i];
            }
            return x; // Return the solution vector
        }

        // --- Update calculateResults for math.js sparse K_original ---
        // --- Update calculateResults for math.js sparse K_original ---
        function calculateResults(d, K_original, F_original, nodeIndexMap, N_DOF) {
            console.log("Calculating results (math.js Sparse K)...");
            // Convert solution vector d (JS array) back to math.js Matrix for multiplication
            const d_matrix = math.matrix(d);

            if (!d_matrix || !nodeIndexMap || nodeIndexMap.size === 0 || typeof math === 'undefined') {
                console.error("Invalid input or math.js not loaded for calculateResults.");
                resultsSpringLoads = []; resultsReactions = []; resultsElementStresses = []; return;
            }

            resultsSpringLoads = [];
            resultsReactions = [];
            resultsElementStresses = []; // Stresses calculated later

            // --- Calculate Spring Loads (uses d - standard JS array) ---
            feSprings.forEach(spring => {
                const node1 = findFeNodeById(spring.feNodeId1);
                const node2 = findFeNodeById(spring.feNodeId2);
                const idx1 = nodeIndexMap.get(spring.feNodeId1);
                const idx2 = nodeIndexMap.get(spring.feNodeId2);
                if (node1 && node2 && idx1 !== undefined && idx2 !== undefined) {
                    if (2 * idx1 + 1 >= d.length || 2 * idx2 + 1 >= d.length) { console.error(`DOF index out of bounds for spring ${spring.id}.`); return; }
                    const dx1 = d[2 * idx1]; const dy1 = d[2 * idx1 + 1];
                    const dx2 = d[2 * idx2]; const dy2 = d[2 * idx2 + 1];
                    const deltaX = dx2 - dx1; const deltaY = dy2 - dy1;
                    const forceX = spring.stiffness * deltaX;
                    const forceY = spring.stiffness * deltaY;
                    resultsSpringLoads.push({ id: spring.id, fx: forceX.toExponential(3), fy: forceY.toExponential(3) });
                } else { console.warn(`Could not find nodes/indices for spring ${spring.id}`); }
            });
            console.log('Calculated Spring Loads:', resultsSpringLoads);

            // --- Calculate Reaction Forces using math.js operations ---
            console.log("Calculating reaction forces (math.js)...");
            try {
                console.time("MathJsReactionCalc");
                // Ensure F_original is a column vector if it's flat
                let F_orig_matrix = F_original;
                if (F_original.size().length === 1) {
                    F_orig_matrix = math.reshape(F_original, [N_DOF, 1]);
                }

                const K_d = math.multiply(K_original, d_matrix); // K_original * d (sparse * dense)
                const R_matrix = math.subtract(K_d, F_orig_matrix);   // K*d - F_original
                const R_vec = R_matrix.toArray().flat(); // Convert result to standard JS array
                console.timeEnd("MathJsReactionCalc");

                feNodes.forEach(node => {
                    if (node.bc && (node.bc.type === 'fixed' || node.bc.type === 'enforced')) {
                        const globalIndex = nodeIndexMap.get(node.id);
                        if (globalIndex !== undefined) {
                            const dofX = 2 * globalIndex; const dofY = 2 * globalIndex + 1;
                            if (dofX >= R_vec.length || dofY >= R_vec.length) { console.error(`Reaction index out of bounds for node ${node.id}`); return; }
                            let rx = 0, ry = 0;
                            let reportX = (node.bc.type === 'fixed' && node.bc.value.fixX) || (node.bc.type === 'enforced' && node.bc.value.dx !== null);
                            let reportY = (node.bc.type === 'fixed' && node.bc.value.fixY) || (node.bc.type === 'enforced' && node.bc.value.dy !== null);

                            if (reportX) rx = (R_vec[dofX] !== undefined) ? Number(R_vec[dofX]).toExponential(3) : '0.000e+0';
                            if (reportY) ry = (R_vec[dofY] !== undefined) ? Number(R_vec[dofY]).toExponential(3) : '0.000e+0';

                            const tolerance = 1e-6;
                            if (reportX || reportY) {
                                if (Math.abs(Number(rx)) > tolerance || Math.abs(Number(ry)) > tolerance || node.bc.type === 'enforced') {
                                    resultsReactions.push({ feNodeId: node.id, rx: rx, ry: ry });
                                }
                            }
                        }
                    }
                });
                console.log("Reaction forces calculated using math.js.");

            } catch (error) {
                console.error("Error calculating math.js reaction forces:", error);
                resultsReactions = [];
                feNodes.forEach(node => {
                    if (node.bc && (node.bc.type === 'fixed' || node.bc.type === 'enforced')) {
                        resultsReactions.push({ feNodeId: node.id, rx: 'Error', ry: 'Error' });
                    }
                });
            }
            console.log('Calculated Reactions:', resultsReactions);

            // --- Calculate Element Stresses (uses d - standard JS array) ---
            console.log("Calculating element stresses ...");
            resultsElementStresses = [];
            feElements.forEach(element => {
                if (element.type === 'quad' && element.nodeIds.length === 4) {
                    const elementNodes = element.nodeIds.map(id => findFeNodeById(id));
                    if (!elementNodes.every(n => n)) { console.warn(`Skipping stress for element ${element.id}, missing node data.`); return; }
                    const membrane = findMembraneById(element.membraneId);
                    if (!membrane) { console.warn(`Membrane ${element.membraneId} not found for stress calc, elem ${element.id}.`); return; }
                    const E = element.propE !== undefined ? element.propE : (membrane.materialE ?? DEFAULT_MATERIAL_E);
                    const nu = element.propNu !== undefined ? element.propNu : (membrane.materialNu ?? DEFAULT_MATERIAL_NU);
                    if (isNaN(E) || isNaN(nu) || E <= 0 || nu < 0 || nu >= 0.5) { console.warn(`Invalid material for membrane ${membrane.id} during stress calc, elem ${element.id}.`); return; }
                    const D_element = zeros(3, 3);
                    const E_factor_element = E / (1.0 - nu * nu);
                    D_element[0][0] = E_factor_element; D_element[0][1] = E_factor_element * nu;
                    D_element[1][0] = E_factor_element * nu; D_element[1][1] = E_factor_element;
                    D_element[2][2] = E_factor_element * (1.0 - nu) / 2.0;

                    const nodeCoords = elementNodes.map(n => ({ x: n.x, y: n.y }));
                    const elementDisp = zeros(8, 1);
                    let dataComplete = true;
                    element.nodeIds.forEach((nodeId, i) => {
                        const globalIndex = nodeIndexMap.get(nodeId);
                        // Use d (standard JS array) here
                        if (globalIndex === undefined || (2 * globalIndex + 1) >= d.length) { console.warn(`Missing displacement data for node ${nodeId}, elem ${element.id}`); dataComplete = false; return; }
                        elementDisp[2 * i][0] = d[2 * globalIndex];
                        elementDisp[2 * i + 1][0] = d[2 * globalIndex + 1];
                    });
                    if (!dataComplete) return;

                    const xi = 0, eta = 0; // Center stress
                    const dNdXiEta = [[-0.25 * (1 - eta), 0.25 * (1 - eta), 0.25 * (1 + eta), -0.25 * (1 + eta)], [-0.25 * (1 - xi), -0.25 * (1 + xi), 0.25 * (1 + xi), 0.25 * (1 - xi)]];
                    const J = zeros(2, 2);
                    for (let i = 0; i < 4; i++) { J[0][0] += dNdXiEta[0][i] * nodeCoords[i].x; J[0][1] += dNdXiEta[0][i] * nodeCoords[i].y; J[1][0] += dNdXiEta[1][i] * nodeCoords[i].x; J[1][1] += dNdXiEta[1][i] * nodeCoords[i].y; }
                    const detJ = J[0][0] * J[1][1] - J[0][1] * J[1][0];
                    if (detJ <= 1e-9) { console.warn(`Zero/negative Jacobian for stress calc, elem ${element.id}.`); return; }
                    const invDetJ = 1.0 / detJ;
                    const invJ = [[invDetJ * J[1][1], -invDetJ * J[0][1]], [-invDetJ * J[1][0], invDetJ * J[0][0]]];
                    const dNdXY = zeros(4, 2);
                    for (let i = 0; i < 4; i++) { dNdXY[i][0] = invJ[0][0] * dNdXiEta[0][i] + invJ[0][1] * dNdXiEta[1][i]; dNdXY[i][1] = invJ[1][0] * dNdXiEta[0][i] + invJ[1][1] * dNdXiEta[1][i]; }
                    const B = zeros(3, 8);
                    for (let i = 0; i < 4; i++) { B[0][2 * i] = dNdXY[i][0]; B[0][2 * i + 1] = 0; B[1][2 * i] = 0; B[1][2 * i + 1] = dNdXY[i][1]; B[2][2 * i] = dNdXY[i][1]; B[2][2 * i + 1] = dNdXY[i][0]; }

                    // Use existing dense helper for B * d_element
                    const epsilon = matrixVectorMultiply(B, elementDisp.flat()); // Still uses standard arrays
                    if (!epsilon) { console.warn(`Strain calculation failed for element ${element.id}`); return; }

                    // Use existing dense helper for D * epsilon
                    const sigma = matrixVectorMultiply(D_element, epsilon); // Still uses standard arrays
                    if (!sigma) { console.warn(`Stress calculation failed for element ${element.id}`); return; }

                    const sxx = sigma[0]; const syy = sigma[1]; const sxy = sigma[2];
                    const sigmaVM = Math.sqrt(Math.max(0, sxx ** 2 - sxx * syy + syy ** 2 + 3 * sxy ** 2));
                    resultsElementStresses.push({ elementId: element.id, sxx: sxx.toExponential(3), syy: syy.toExponential(3), sxy: sxy.toExponential(3), sigmaVM: sigmaVM });
                }
            });
            console.log(`Calculated stresses for ${resultsElementStresses.length} elements.`);

            resultsDisplacements = d; // Store the final displacement vector (standard JS array)
            console.log("Results calculation finished (math.js).");
        }

        // --- Web Worker Instance ---
        let solverWorker = null;
        let solverWorkerBlobUrl = null;

        // Inline worker code as a string (to work from file:// origin)
        const SOLVER_WORKER_CODE = `
// Import math.js for sparse matrix operations
importScripts('https://cdnjs.cloudflare.com/ajax/libs/mathjs/12.4.1/math.min.js');

const DEFAULT_MATERIAL_E = 10.5e6;
const DEFAULT_MATERIAL_NU = 0.3;
const DEFAULT_MATERIAL_T = 0.05;

function zeros(rows, cols) { return Array(rows).fill(0).map(() => Array(cols).fill(0)); }
function matrixMultiply(A, B) { const A_rows = A.length, A_cols = A[0]?.length || 0, B_rows = B.length, B_cols = B[0]?.length || 0; if (A_cols !== B_rows) return null; const C = zeros(A_rows, B_cols); for (let i = 0; i < A_rows; i++) for (let j = 0; j < B_cols; j++) for (let k = 0; k < A_cols; k++) C[i][j] += (A[i]?.[k] || 0) * (B[k]?.[j] || 0); return C; }
function matrixTranspose(A) { const A_rows = A.length, A_cols = A[0]?.length || 0, C = zeros(A_cols, A_rows); for (let i = 0; i < A_rows; i++) for (let j = 0; j < A_cols; j++) C[j][i] = A[i][j]; return C; }
function scalarMultiply(scalar, A) { const A_rows = A.length, A_cols = A[0]?.length || 0, C = zeros(A_rows, A_cols); for (let i = 0; i < A_rows; i++) for (let j = 0; j < A_cols; j++) C[i][j] = scalar * (A[i]?.[j] || 0); return C; }
function matrixVectorMultiply(A, v) { const A_rows = A.length, A_cols = A[0]?.length || 0; if (A_cols !== v.length) return null; const C = Array(A_rows).fill(0); for (let i = 0; i < A_rows; i++) for (let k = 0; k < A_cols; k++) C[i] += (A[i]?.[k] || 0) * (v[k] || 0); return C; }

function calculateQuadElementStiffness(elementNodes, E, nu, t) {
    const Ke = zeros(8, 8), coords = elementNodes.map(n => ({ x: n.x, y: n.y }));
    const D = zeros(3, 3), E_factor = E / (1.0 - nu * nu);
    D[0][0] = E_factor; D[0][1] = E_factor * nu; D[1][0] = E_factor * nu; D[1][1] = E_factor; D[2][2] = E_factor * (1.0 - nu) / 2.0;
    const gpVal = 1.0 / Math.sqrt(3.0);
    const gaussPoints = [{ xi: -gpVal, eta: -gpVal }, { xi: gpVal, eta: -gpVal }, { xi: gpVal, eta: gpVal }, { xi: -gpVal, eta: gpVal }];
    for (let gp = 0; gp < gaussPoints.length; gp++) {
        const xi = gaussPoints[gp].xi, eta = gaussPoints[gp].eta;
        const dNdXiEta = [[-0.25 * (1 - eta), 0.25 * (1 - eta), 0.25 * (1 + eta), -0.25 * (1 + eta)], [-0.25 * (1 - xi), -0.25 * (1 + xi), 0.25 * (1 + xi), 0.25 * (1 - xi)]];
        const J = zeros(2, 2);
        for (let i = 0; i < 4; i++) { J[0][0] += dNdXiEta[0][i] * coords[i].x; J[0][1] += dNdXiEta[0][i] * coords[i].y; J[1][0] += dNdXiEta[1][i] * coords[i].x; J[1][1] += dNdXiEta[1][i] * coords[i].y; }
        const detJ = J[0][0] * J[1][1] - J[0][1] * J[1][0];
        if (detJ <= 1e-9) continue;
        const invDetJ = 1.0 / detJ, invJ = [[invDetJ * J[1][1], -invDetJ * J[0][1]], [-invDetJ * J[1][0], invDetJ * J[0][0]]];
        const dNdXY = zeros(4, 2);
        for (let i = 0; i < 4; i++) { dNdXY[i][0] = invJ[0][0] * dNdXiEta[0][i] + invJ[0][1] * dNdXiEta[1][i]; dNdXY[i][1] = invJ[1][0] * dNdXiEta[0][i] + invJ[1][1] * dNdXiEta[1][i]; }
        const B = zeros(3, 8);
        for (let i = 0; i < 4; i++) { B[0][2 * i] = dNdXY[i][0]; B[1][2 * i + 1] = dNdXY[i][1]; B[2][2 * i] = dNdXY[i][1]; B[2][2 * i + 1] = dNdXY[i][0]; }
        const B_T = matrixTranspose(B), D_B = matrixMultiply(D, B), B_T_D_B = matrixMultiply(B_T, D_B);
        if (B_T_D_B) { const scalarFactor = t * detJ, Ke_gp = scalarMultiply(scalarFactor, B_T_D_B); for (let r = 0; r < 8; r++) for (let c = 0; c < 8; c++) Ke[r][c] += Ke_gp[r][c]; }
    }
    return Ke;
}

function calculateSpringElementStiffness(k) { return [[k, 0, -k, 0], [0, k, 0, -k], [-k, 0, k, 0], [0, -k, 0, k]]; }

function assembleGlobalMatricesCOO(feNodes, feElements, feSprings, membranes) {
    const numNodes = feNodes.length, N_DOF = numNodes * 2;
    self.postMessage({ type: 'progress', message: 'Assembling: ' + numNodes + ' nodes, ' + N_DOF + ' DOFs, ' + feElements.length + ' elements...' });
    const nodeIndexMap = new Map(), feNodeMap = new Map();
    feNodes.forEach((node, index) => { nodeIndexMap.set(node.id, index); feNodeMap.set(node.id, node); });
    const membraneMap = new Map();
    membranes.forEach(m => membraneMap.set(m.id, m));
    const triplets = [];
    feElements.forEach(element => {
        if (element.type === 'quad' && element.nodeIds.length === 4) {
            const elementNodes = element.nodeIds.map(id => feNodeMap.get(id));
            if (!elementNodes.every(n => n)) return;
            const membrane = membraneMap.get(element.membraneId);
            if (!membrane) return;
            const E = element.propE !== undefined ? element.propE : (membrane.materialE ?? DEFAULT_MATERIAL_E);
            const nu = element.propNu !== undefined ? element.propNu : (membrane.materialNu ?? DEFAULT_MATERIAL_NU);
            const t = element.propT !== undefined ? element.propT : (membrane.materialT ?? DEFAULT_MATERIAL_T);
            if (isNaN(E) || isNaN(nu) || isNaN(t) || E <= 0 || t <= 0 || nu < 0 || nu >= 0.5) throw new Error('Invalid material on Membrane ' + membrane.id);
            const Ke = calculateQuadElementStiffness(elementNodes, E, nu, t);
            element.nodeIds.forEach((nodeId_i, i) => {
                const globalRowIndex = nodeIndexMap.get(nodeId_i);
                if (globalRowIndex === undefined) return;
                element.nodeIds.forEach((nodeId_j, j) => {
                    const globalColIndex = nodeIndexMap.get(nodeId_j);
                    if (globalColIndex === undefined) return;
                    const r0 = 2 * globalRowIndex, c0 = 2 * globalColIndex;
                    if (Math.abs(Ke[2 * i][2 * j]) > 1e-15) triplets.push([r0, c0, Ke[2 * i][2 * j]]);
                    if (Math.abs(Ke[2 * i][2 * j + 1]) > 1e-15) triplets.push([r0, c0 + 1, Ke[2 * i][2 * j + 1]]);
                    if (Math.abs(Ke[2 * i + 1][2 * j]) > 1e-15) triplets.push([r0 + 1, c0, Ke[2 * i + 1][2 * j]]);
                    if (Math.abs(Ke[2 * i + 1][2 * j + 1]) > 1e-15) triplets.push([r0 + 1, c0 + 1, Ke[2 * i + 1][2 * j + 1]]);
                });
            });
        }
    });
    feSprings.forEach(spring => {
        const node1 = feNodeMap.get(spring.feNodeId1), node2 = feNodeMap.get(spring.feNodeId2);
        if (!node1 || !node2) return;
        const Ks = calculateSpringElementStiffness(spring.stiffness);
        const globalIndex1 = nodeIndexMap.get(node1.id), globalIndex2 = nodeIndexMap.get(node2.id);
        if (globalIndex1 !== undefined && globalIndex2 !== undefined) {
            const dofMap = [2 * globalIndex1, 2 * globalIndex1 + 1, 2 * globalIndex2, 2 * globalIndex2 + 1];
            for (let i = 0; i < 4; i++) for (let j = 0; j < 4; j++) if (Math.abs(Ks[i][j]) > 1e-15) triplets.push([dofMap[i], dofMap[j], Ks[i][j]]);
        }
    });
    self.postMessage({ type: 'progress', message: 'Sorting ' + triplets.length + ' matrix entries...' });
    triplets.sort((a, b) => a[0] !== b[0] ? a[0] - b[0] : a[1] - b[1]);
    const condensedTriplets = [];
    for (let i = 0; i < triplets.length; i++) {
        const [r, c, v] = triplets[i];
        if (condensedTriplets.length > 0 && condensedTriplets[condensedTriplets.length - 1][0] === r && condensedTriplets[condensedTriplets.length - 1][1] === c) {
            condensedTriplets[condensedTriplets.length - 1][2] += v;
        } else { condensedTriplets.push([r, c, v]); }
    }
    self.postMessage({ type: 'progress', message: 'Building sparse matrix: ' + condensedTriplets.length + ' unique entries...' });
    let K_global = math.sparse();
    condensedTriplets.forEach(([r, c, v]) => { K_global.set([r, c], v); });
    const F_array = new Array(N_DOF).fill(0);
    feNodes.forEach(node => {
        if (node.bc && node.bc.type === 'load') {
            const globalIndex = nodeIndexMap.get(node.id);
            if (globalIndex !== undefined) { F_array[2 * globalIndex] += (node.bc.value.fx ?? 0); F_array[2 * globalIndex + 1] += (node.bc.value.fy ?? 0); }
        }
    });
    const F_global = math.matrix(F_array);
    console.log('[Worker] Global matrix: ' + N_DOF + 'x' + N_DOF + ', ' + condensedTriplets.length + ' non-zeros');
    return { K_global, F_global, nodeIndexMap, N_DOF, feNodeMap };
}

function applyBoundaryConditions(K_global, F_global, feNodes, nodeIndexMap, N_DOF) {
    console.log("[Worker] Applying boundary conditions...");
    const K_modified = math.clone(K_global);
    let F_modified = math.clone(F_global);
    const PENALTY = 1e10;
    feNodes.forEach(node => {
        if (!node.bc || (node.bc.type !== 'fixed' && node.bc.type !== 'enforced')) return;
        const globalIndex = nodeIndexMap.get(node.id);
        if (globalIndex === undefined) return;
        const dofX = 2 * globalIndex, dofY = 2 * globalIndex + 1;
        if (node.bc.type === 'fixed') {
            if (node.bc.value.fixX) {
                for (let j = 0; j < N_DOF; j++) if (j !== dofX) K_modified.set([dofX, j], 0);
                for (let i = 0; i < N_DOF; i++) if (i !== dofX) K_modified.set([i, dofX], 0);
                K_modified.set([dofX, dofX], 1);
                F_modified = math.subset(F_modified, math.index(dofX), 0);
            }
            if (node.bc.value.fixY) {
                for (let j = 0; j < N_DOF; j++) if (j !== dofY) K_modified.set([dofY, j], 0);
                for (let i = 0; i < N_DOF; i++) if (i !== dofY) K_modified.set([i, dofY], 0);
                K_modified.set([dofY, dofY], 1);
                F_modified = math.subset(F_modified, math.index(dofY), 0);
            }
        } else if (node.bc.type === 'enforced') {
            const dx = node.bc.value.dx, dy = node.bc.value.dy;
            if (dx !== null) { const currentDiag = K_modified.get([dofX, dofX]) || 0; K_modified.set([dofX, dofX], currentDiag + PENALTY); const currentF = math.subset(F_modified, math.index(dofX)) || 0; F_modified = math.subset(F_modified, math.index(dofX), currentF + PENALTY * dx); }
            if (dy !== null) { const currentDiag = K_modified.get([dofY, dofY]) || 0; K_modified.set([dofY, dofY], currentDiag + PENALTY); const currentF = math.subset(F_modified, math.index(dofY)) || 0; F_modified = math.subset(F_modified, math.index(dofY), currentF + PENALTY * dy); }
        }
    });
    return { K_modified, F_modified };
}

function solveSystem(K_modified, F_modified, N_DOF) {
    self.postMessage({ type: 'progress', message: 'Solving ' + N_DOF + 'x' + N_DOF + ' system (LU decomposition)...' });
    try {
        let F_col = F_modified;
        if (F_modified.size().length === 1) F_col = math.reshape(F_modified, [N_DOF, 1]);
        const d_matrix = math.lusolve(K_modified, F_col);
        const d_vec = d_matrix.toArray().flat();
        console.log("[Worker] System solved successfully");
        return d_vec;
    } catch (error) {
        console.error("[Worker] Solve failed:", error.message);
        throw error;
    }
}

function calculateResults(d, K_original, F_original, feNodes, feSprings, feElements, membranes, nodeIndexMap, N_DOF) {
    console.log("[Worker] Calculating results...");
    const feNodeMap = new Map();
    feNodes.forEach(n => feNodeMap.set(n.id, n));
    const membraneMap = new Map();
    membranes.forEach(m => membraneMap.set(m.id, m));
    const springLoads = [];
    feSprings.forEach(spring => {
        const idx1 = nodeIndexMap.get(spring.feNodeId1), idx2 = nodeIndexMap.get(spring.feNodeId2);
        if (idx1 !== undefined && idx2 !== undefined) {
            const dx1 = d[2 * idx1], dy1 = d[2 * idx1 + 1], dx2 = d[2 * idx2], dy2 = d[2 * idx2 + 1];
            const forceX = spring.stiffness * (dx2 - dx1), forceY = spring.stiffness * (dy2 - dy1);
            springLoads.push({ id: spring.id, fx: forceX.toExponential(3), fy: forceY.toExponential(3) });
        }
    });
    const reactions = [];
    try {
        const d_matrix = math.matrix(d);
        let F_orig = F_original;
        if (F_original.size().length === 1) F_orig = math.reshape(F_original, [N_DOF, 1]);
        const K_d = math.multiply(K_original, d_matrix);
        const R_matrix = math.subtract(K_d, F_orig);
        const R_vec = R_matrix.toArray().flat();
        feNodes.forEach(node => {
            if (node.bc && (node.bc.type === 'fixed' || node.bc.type === 'enforced')) {
                const globalIndex = nodeIndexMap.get(node.id);
                if (globalIndex !== undefined) {
                    const dofX = 2 * globalIndex, dofY = 2 * globalIndex + 1;
                    let rx = 0, ry = 0;
                    const reportX = (node.bc.type === 'fixed' && node.bc.value.fixX) || (node.bc.type === 'enforced' && node.bc.value.dx !== null);
                    const reportY = (node.bc.type === 'fixed' && node.bc.value.fixY) || (node.bc.type === 'enforced' && node.bc.value.dy !== null);
                    if (reportX) rx = Number(R_vec[dofX]).toExponential(3);
                    if (reportY) ry = Number(R_vec[dofY]).toExponential(3);
                    if (reportX || reportY) reactions.push({ feNodeId: node.id, rx, ry });
                }
            }
        });
    } catch (e) { console.error("[Worker] Reaction calculation failed:", e); }
    const elementStresses = [];
    feElements.forEach(element => {
        if (element.type !== 'quad' || element.nodeIds.length !== 4) return;
        const elementNodes = element.nodeIds.map(id => feNodeMap.get(id));
        if (!elementNodes.every(n => n)) return;
        const membrane = membraneMap.get(element.membraneId);
        if (!membrane) return;
        const E = element.propE !== undefined ? element.propE : (membrane.materialE ?? DEFAULT_MATERIAL_E);
        const nu = element.propNu !== undefined ? element.propNu : (membrane.materialNu ?? DEFAULT_MATERIAL_NU);
        const D = zeros(3, 3);
        const E_factor = E / (1.0 - nu * nu);
        D[0][0] = E_factor; D[0][1] = E_factor * nu; D[1][0] = E_factor * nu; D[1][1] = E_factor; D[2][2] = E_factor * (1.0 - nu) / 2.0;
        const coords = elementNodes.map(n => ({ x: n.x, y: n.y }));
        const elemDisp = [];
        let valid = true;
        element.nodeIds.forEach(nodeId => { const idx = nodeIndexMap.get(nodeId); if (idx === undefined) { valid = false; return; } elemDisp.push(d[2 * idx], d[2 * idx + 1]); });
        if (!valid) return;
        const xi = 0, eta = 0;
        const dNdXiEta = [[-0.25 * (1 - eta), 0.25 * (1 - eta), 0.25 * (1 + eta), -0.25 * (1 + eta)], [-0.25 * (1 - xi), -0.25 * (1 + xi), 0.25 * (1 + xi), 0.25 * (1 - xi)]];
        const J = zeros(2, 2);
        for (let i = 0; i < 4; i++) { J[0][0] += dNdXiEta[0][i] * coords[i].x; J[0][1] += dNdXiEta[0][i] * coords[i].y; J[1][0] += dNdXiEta[1][i] * coords[i].x; J[1][1] += dNdXiEta[1][i] * coords[i].y; }
        const detJ = J[0][0] * J[1][1] - J[0][1] * J[1][0];
        if (detJ <= 1e-9) return;
        const invDetJ = 1.0 / detJ, invJ = [[invDetJ * J[1][1], -invDetJ * J[0][1]], [-invDetJ * J[1][0], invDetJ * J[0][0]]];
        const dNdXY = zeros(4, 2);
        for (let i = 0; i < 4; i++) { dNdXY[i][0] = invJ[0][0] * dNdXiEta[0][i] + invJ[0][1] * dNdXiEta[1][i]; dNdXY[i][1] = invJ[1][0] * dNdXiEta[0][i] + invJ[1][1] * dNdXiEta[1][i]; }
        const B = zeros(3, 8);
        for (let i = 0; i < 4; i++) { B[0][2 * i] = dNdXY[i][0]; B[1][2 * i + 1] = dNdXY[i][1]; B[2][2 * i] = dNdXY[i][1]; B[2][2 * i + 1] = dNdXY[i][0]; }
        const epsilon = matrixVectorMultiply(B, elemDisp);
        if (!epsilon) return;
        const sigma = matrixVectorMultiply(D, epsilon);
        if (!sigma) return;
        const sxx = sigma[0], syy = sigma[1], sxy = sigma[2];
        const sigmaVM = Math.sqrt(Math.max(0, sxx ** 2 - sxx * syy + syy ** 2 + 3 * sxy ** 2));
        elementStresses.push({ elementId: element.id, sxx: sxx.toExponential(3), syy: syy.toExponential(3), sxy: sxy.toExponential(3), sigmaVM });
    });
    return { springLoads, reactions, elementStresses, displacements: d };
}

self.onmessage = function(e) {
    const { type, data } = e.data;
    console.log("[Worker] Received message:", type);
    if (type === 'solve') {
        try {
            const { feNodes, feElements, feSprings, membranes } = data;
            self.postMessage({ type: 'progress', message: 'Starting analysis... (' + feNodes.length + ' nodes, ' + feElements.length + ' elements)' });
            const assembly = assembleGlobalMatricesCOO(feNodes, feElements, feSprings, membranes);
            const { K_global, F_global, nodeIndexMap, N_DOF } = assembly;
            const K_original = math.clone(K_global), F_original = math.clone(F_global);
            self.postMessage({ type: 'progress', message: 'Applying boundary conditions (' + N_DOF + ' DOFs)...' });
            const { K_modified, F_modified } = applyBoundaryConditions(K_global, F_global, feNodes, nodeIndexMap, N_DOF);
            const d = solveSystem(K_modified, F_modified, N_DOF);
            self.postMessage({ type: 'progress', message: 'Computing stresses, reactions, spring loads...' });
            const results = calculateResults(d, K_original, F_original, feNodes, feSprings, feElements, membranes, nodeIndexMap, N_DOF);
            self.postMessage({ type: 'done', results: results });
        } catch (error) {
            self.postMessage({ type: 'error', message: error.message });
        }
    }
};
console.log("[Worker] Solver worker initialized");
`;

        function initSolverWorker() {
            if (solverWorker) {
                solverWorker.terminate();
            }
            if (solverWorkerBlobUrl) {
                URL.revokeObjectURL(solverWorkerBlobUrl);
            }
            try {
                // Create Blob from inline code
                const blob = new Blob([SOLVER_WORKER_CODE], { type: 'application/javascript' });
                solverWorkerBlobUrl = URL.createObjectURL(blob);
                solverWorker = new Worker(solverWorkerBlobUrl);
                solverWorker.onmessage = handleWorkerMessage;
                solverWorker.onerror = (e) => {
                    console.error("Worker error:", e);
                    updateStatus(`Worker error: ${e.message}`);
                    alert(`Analysis failed: Worker error - ${e.message}`);
                    document.getElementById('btn-solve').disabled = false;
                };
                console.log("Solver Worker initialized (Blob URL).");
            } catch (e) {
                console.error("Failed to create Web Worker:", e);
                solverWorker = null;
            }
        }

        function handleWorkerMessage(e) {
            const { type, message, results } = e.data;
            console.log("[Main] Worker message:", type);

            if (type === 'progress') {
                updateStatus(message);
            } else if (type === 'done') {
                console.log("[Main] Analysis complete from worker");

                // Store results globally
                resultsSpringLoads = results.springLoads || [];
                resultsReactions = results.reactions || [];
                resultsElementStresses = results.elementStresses || [];
                resultsDisplacements = results.displacements;

                const d = results.displacements;

                // Calculate scale factor for deformed mesh
                let maxDisp = 0;
                for (let i = 0; i < d.length; i += 2) {
                    const dispMag = Math.sqrt((d[i] ** 2) + (d[i + 1] ** 2));
                    if (dispMag > maxDisp) maxDisp = dispMag;
                }
                console.log("Maximum displacement:", maxDisp);

                let avgElementSideLength = 50;
                if (feElements.length > 0 && feElements[0].nodeIds.length >= 2) {
                    const nodeA = findFeNodeById(feElements[0].nodeIds[0]);
                    const nodeB = findFeNodeById(feElements[0].nodeIds[1]);
                    if (nodeA && nodeB) {
                        avgElementSideLength = Math.sqrt((nodeA.x - nodeB.x) ** 2 + (nodeA.y - nodeB.y) ** 2);
                    }
                }

                const DISP_TOL = 1e-9;
                let scaleFactor = 1;
                if (maxDisp > DISP_TOL) {
                    scaleFactor = avgElementSideLength / maxDisp;
                    scaleFactor = Math.min(scaleFactor, 500);
                    scaleFactor = Math.max(scaleFactor, 1);
                }
                console.log("Deformation scale factor:", scaleFactor);

                updateStatus("Analysis complete. Updating display...");
                console.time("DrawResults");
                updateResultsDisplay();
                drawDeformedMesh(d, scaleFactor);
                drawSprings();
                drawReactions();
                drawStressResults(resultsElementStresses);
                handleResultsViewChange();
                console.timeEnd("DrawResults");

                document.getElementById('btn-solve').disabled = false;
                console.log("--- Analysis Finished (Web Worker) ---");

            } else if (type === 'error') {
                console.error("[Main] Worker error:", message);
                updateStatus(`Analysis failed: ${message}`);
                alert(`Analysis failed: ${message}`);
                document.getElementById('btn-solve').disabled = false;
            }
        }

        // --- runAnalysis using Web Worker ---
        function runAnalysis() {
            console.log("--- Starting Analysis (Web Worker) ---");
            updateStatus("Running analysis...");

            // --- Validation checks ---
            if (feNodes.length === 0 || feElements.length === 0) {
                alert("Mesh required.");
                updateStatus("Analysis failed: Mesh required.");
                return;
            }

            const hasBCs = feNodes.some(n => n.bc && n.bc.type === 'fixed');
            if (!hasBCs) {
                alert("Warning: No fixed BCs found.");
                console.warn("No fixed BCs found.");
            }

            let allMaterialsValid = true;
            membranes.forEach(membrane => {
                if (membrane.isMeshed && (isNaN(membrane.materialE) || isNaN(membrane.materialNu) || isNaN(membrane.materialT) ||
                    membrane.materialE <= 0 || membrane.materialT <= 0 || membrane.materialNu < 0 || membrane.materialNu >= 0.5)) {
                    console.error(`Membrane ${membrane.id} has invalid material properties`);
                    allMaterialsValid = false;
                }
            });
            if (!allMaterialsValid) {
                updateStatus("Analysis failed: Invalid material properties.");
                alert("Analysis failed: Check material properties for all meshed membranes.");
                return;
            }

            // Disable solve button during analysis
            document.getElementById('btn-solve').disabled = true;

            // Initialize worker if needed
            if (!solverWorker) {
                initSolverWorker();
            }

            if (!solverWorker) {
                // Fallback to inline solver if worker failed to load
                console.warn("Web Worker unavailable, falling back to inline solver");
                runAnalysisInline();
                return;
            }

            // Prepare data for worker (strip Konva objects, keep only plain data)
            const workerData = {
                feNodes: feNodes.map(n => ({
                    id: n.id,
                    x: n.x,
                    y: n.y,
                    bc: n.bc,
                    membraneId: n.membraneId
                })),
                feElements: feElements.map(e => ({
                    id: e.id,
                    type: e.type,
                    nodeIds: e.nodeIds,
                    membraneId: e.membraneId,
                    propE: e.propE,
                    propNu: e.propNu,
                    propT: e.propT
                })),
                feSprings: feSprings.map(s => ({
                    id: s.id,
                    feNodeId1: s.feNodeId1,
                    feNodeId2: s.feNodeId2,
                    stiffness: s.stiffness
                })),
                membranes: membranes.map(m => ({
                    id: m.id,
                    materialE: m.materialE ?? DEFAULT_MATERIAL_E,
                    materialNu: m.materialNu ?? DEFAULT_MATERIAL_NU,
                    materialT: m.materialT ?? DEFAULT_MATERIAL_T
                }))
            };

            console.log("[Main] Sending data to worker:", {
                nodes: workerData.feNodes.length,
                elements: workerData.feElements.length,
                springs: workerData.feSprings.length
            });

            solverWorker.postMessage({ type: 'solve', data: workerData });
        }

        // --- Fallback inline solver (legacy code path) ---
        function runAnalysisInline() {
            console.log("--- Starting Analysis (Inline Fallback) ---");
            // This is the original runAnalysis code, kept as fallback
            try {
                updateStatus("Assembling global matrices...");
                const assemblyResult = assembleGlobalMatrices();
                if (!assemblyResult) { updateStatus("Analysis failed: Matrix assembly error."); document.getElementById('btn-solve').disabled = false; return; }

                const { K_global, F_global, nodeIndexMap, N_DOF } = assemblyResult;
                const K_original = math.clone(K_global);
                const F_original = math.clone(F_global);

                updateStatus("Applying boundary conditions...");
                const bcResult = applyBoundaryConditions(K_global, F_global, nodeIndexMap, N_DOF);
                if (!bcResult) { updateStatus("Analysis failed: Error applying BCs."); document.getElementById('btn-solve').disabled = false; return; }
                const { K_modified, F_modified } = bcResult;

                updateStatus("Solving system...");
                const d = solveSystem(K_modified, F_modified, N_DOF);
                if (!d) { updateStatus("Analysis failed: System solve error."); document.getElementById('btn-solve').disabled = false; return; }

                let maxDisp = 0;
                for (let i = 0; i < d.length; i += 2) {
                    const dispMag = Math.sqrt((d[i] ** 2) + (d[i + 1] ** 2));
                    if (dispMag > maxDisp) maxDisp = dispMag;
                }
                let avgElementSideLength = 50;
                if (feElements.length > 0 && feElements[0].nodeIds.length >= 2) {
                    const nodeA = findFeNodeById(feElements[0].nodeIds[0]);
                    const nodeB = findFeNodeById(feElements[0].nodeIds[1]);
                    if (nodeA && nodeB) { avgElementSideLength = Math.sqrt((nodeA.x - nodeB.x) ** 2 + (nodeA.y - nodeB.y) ** 2); }
                }
                const DISP_TOL = 1e-9; let scaleFactor = 1;
                if (maxDisp > DISP_TOL) { scaleFactor = avgElementSideLength / maxDisp; scaleFactor = Math.min(scaleFactor, 500); scaleFactor = Math.max(scaleFactor, 1); }

                updateStatus("Calculating results...");
                calculateResults(d, K_original, F_original, nodeIndexMap, N_DOF);

                updateStatus("Analysis complete. Updating display...");
                updateResultsDisplay();
                drawDeformedMesh(d, scaleFactor);
                drawSprings();
                drawReactions();
                drawStressResults(resultsElementStresses);
                handleResultsViewChange();
                document.getElementById('btn-solve').disabled = false;
                console.log("--- Analysis Finished (Inline Fallback) ---");
            } catch (error) {
                console.error("Inline analysis error:", error);
                updateStatus(`Analysis failed: ${error.message}`);
                alert(`Analysis failed: ${error.message}`);
                document.getElementById('btn-solve').disabled = false;
            }
        }

        // --- Save/Load Functions ---
        function handleSaveModel() {
            console.log("Saving model...");
            try {
                // Simplify nodes and membranes for saving, include material props
                const simplifiedNodes = nodes.map(n => ({ id: n.id, x: n.x, y: n.y }));
                const simplifiedMembranes = membranes.map(m => ({
                    id: m.id,
                    nodeIds: m.nodeIds,
                    materialE: m.materialE ?? DEFAULT_MATERIAL_E, // Save actual or default E
                    materialNu: m.materialNu ?? DEFAULT_MATERIAL_NU, // Save actual or default nu
                    materialT: m.materialT ?? DEFAULT_MATERIAL_T   // Save actual or default t
                }));
                // FE data can be saved directly as they are simple objects (BCs included)
                const simplifiedFeNodes = feNodes; // No simplification needed if BCs are simple objects
                const simplifiedFeElements = feElements;
                const simplifiedFeSprings = feSprings;

                const saveData = {
                    nodes: simplifiedNodes,
                    membranes: simplifiedMembranes,
                    geometricSpringNodes: geometricSpringNodes,
                    springPointGroups: springPointGroups, // NEW: Save Spring Groups
                    feNodes: simplifiedFeNodes,
                    feElements: simplifiedFeElements,
                    feSprings: simplifiedFeSprings,
                    // Save ID counters to resume numbering correctly
                    nextCounters: {
                        node: nextNodeId,
                        membrane: nextMembraneId,
                        feNode: feNodeIdCounter,
                        feElement: feElementIdCounter,
                        feSpring: feSpringIdCounter,
                        springGroup: nextSpringGroupId // NEW: Save counter
                    }
                };

                const jsonString = JSON.stringify(saveData, null, 2);
                if (navigator.clipboard && navigator.clipboard.writeText) {
                    navigator.clipboard.writeText(jsonString).then(() => {
                        console.log("Model JSON copied to clipboard.");
                        alert("Model JSON copied to clipboard. Paste it into a text file to save.");
                        updateStatus("Model JSON copied to clipboard.");
                    }).catch(err => {
                        console.error('Failed to copy model JSON: ', err);
                        alert("Failed to copy model JSON. See console. Check permissions?");
                        updateStatus("Error copying model JSON.");
                    });
                } else {
                    console.warn("Clipboard API not available. Displaying JSON in textarea.");
                    document.getElementById('load-textarea').value = jsonString;
                    updateStatus("Clipboard unavailable. JSON shown in Load textarea.");
                    alert("Clipboard not available. JSON data placed in Load textarea for manual copy.");
                }
            } catch (error) {
                console.error("Error during save process:", error);
                alert("An error occurred while saving the model.");
                updateStatus("Error saving model.");
            }
        }
        function handleLoadText() {
            console.log("Loading model from text area...");
            const textArea = document.getElementById('load-textarea');
            const jsonString = textArea.value;
            if (!jsonString || jsonString.trim() === '') { alert("Please paste the model JSON data into the text area first."); return; }
            try {
                const loadedData = JSON.parse(jsonString);

                // --- Enhanced Validation ---
                if (!loadedData || typeof loadedData !== 'object' ||
                    !Array.isArray(loadedData.nodes) ||
                    !Array.isArray(loadedData.membranes) ||
                    !Array.isArray(loadedData.geometricSpringNodes) ||
                    !Array.isArray(loadedData.feNodes) ||
                    !Array.isArray(loadedData.feElements) ||
                    !Array.isArray(loadedData.feSprings) ||
                    typeof loadedData.nextCounters !== 'object') {
                    throw new Error("Invalid file format or missing required properties.");
                }

                clearAllData(); // Clear existing data AND reset counters
                console.log("Restoring model state...");

                // --- Restore Geometry Nodes ---
                let maxNodeId = 0;
                const loadedNodesMap = new Map();
                nodes = []; // Ensure nodes array is empty after clearAllData
                loadedData.nodes.forEach(nodeData => {
                    // Pass the loaded ID to addNode
                    const newNodeData = addNode(nodeData.x, nodeData.y, nodeData.id);
                    if (newNodeData) {
                        // nodes.push(newNodeData); // addNode already pushes to global nodes array
                        loadedNodesMap.set(newNodeData.id, newNodeData);
                        if (nodeData.id > maxNodeId) maxNodeId = nodeData.id;
                    } else { console.error(`Failed to load node ${nodeData.id}`); }
                });
                // Set next ID based on loaded data, default to 1 if no nodes loaded
                nextNodeId = (loadedData.nextCounters.node > maxNodeId) ? loadedData.nextCounters.node : (maxNodeId + 1);
                console.log(`Restored ${nodes.length} nodes. Next Node ID: ${nextNodeId}`);

                // --- Restore Membranes (with material properties) ---
                let maxMembraneId = 0;
                membranes = []; // Ensure membranes array is empty
                loadedData.membranes.forEach(memData => {
                    const newMembrane = createMembraneFromData(memData.id, memData.nodeIds, memData.materialE, memData.materialNu, memData.materialT);
                    if (newMembrane) {
                        membranes.push(newMembrane); // createMembraneFromData only returns, doesn't push globally
                        if (memData.id > maxMembraneId) maxMembraneId = memData.id;
                    } else { console.error(`Failed to load membrane ${memData.id}`); }
                });
                nextMembraneId = (loadedData.nextCounters.membrane > maxMembraneId) ? loadedData.nextCounters.membrane : (maxMembraneId + 1);
                console.log(`Restored ${membranes.length} membranes. Next Membrane ID: ${nextMembraneId}`);

                // --- Restore Geometric Spring Nodes ---
                geometricSpringNodes = loadedData.geometricSpringNodes;
                console.log(`Restored ${geometricSpringNodes.length} marked spring points.`);

                // --- NEW: Restore Spring Groups ---
                if (loadedData.springPointGroups && Array.isArray(loadedData.springPointGroups)) {
                    springPointGroups = loadedData.springPointGroups;
                    nextSpringGroupId = (loadedData.nextCounters && loadedData.nextCounters.springGroup) ? loadedData.nextCounters.springGroup : (Math.max(...springPointGroups.map(g => g.id), 0) + 1);
                    console.log(`Restored ${springPointGroups.length} Spring Groups. Next ID: ${nextSpringGroupId}`);
                } else {
                    springPointGroups = [];
                    nextSpringGroupId = 1;
                }

                // --- Restore FE Data ---
                feNodes = loadedData.feNodes;
                feElements = loadedData.feElements;
                feSprings = loadedData.feSprings;
                console.log(`Restored ${feNodes.length} FE nodes, ${feElements.length} FE elements, ${feSprings.length} FE springs.`);

                // --- Restore FE Counters ---
                let maxFeNodeId = 0;
                feNodes.forEach(n => { if (n.id > maxFeNodeId) maxFeNodeId = n.id; });
                feNodeIdCounter = (loadedData.nextCounters.feNode > maxFeNodeId) ? loadedData.nextCounters.feNode : (maxFeNodeId + 1);

                let maxFeElementId = 0;
                feElements.forEach(e => { if (e.id > maxFeElementId) maxFeElementId = e.id; });
                feElementIdCounter = (loadedData.nextCounters.feElement > maxFeElementId) ? loadedData.nextCounters.feElement : (maxFeElementId + 1);

                let maxFeSpringId = 0;
                feSprings.forEach(s => { if (s.id > maxFeSpringId) maxFeSpringId = s.id; });
                feSpringIdCounter = (loadedData.nextCounters.feSpring > maxFeSpringId) ? loadedData.nextCounters.feSpring : (maxFeSpringId + 1);

                console.log(`Restored Counters: Next FE Node ID: ${feNodeIdCounter}, Element: ${feElementIdCounter}, Spring: ${feSpringIdCounter}`);

                // --- Mark membranes as meshed if they have FE elements ---
                const meshedMembraneIds = new Set(feElements.map(el => el.membraneId));
                membranes.forEach(mem => {
                    mem.isMeshed = meshedMembraneIds.has(mem.id);
                });

                console.log("Drawing loaded FE data...");

                membraneFillLayer?.batchDraw();
                meshLayer?.batchDraw();
                springLayer?.batchDraw();
                stressLayer?.visible(false); // Ensure stress layer is hidden initially
                stressLayer?.batchDraw();
                reactionLayer?.visible(false); // Ensure reaction layer is hidden initially
                reactionLayer?.batchDraw();
                updateSpringPointsInfo();
                updateMembraneSelectionInfo();
                updateFeSelectionInfo();
                updateSpringSelectionInfo(); // NEW
                updateResultsDisplay(); // Clear old results display
                textArea.value = '';
                updateStatus(`Model loaded successfully. ${nodes.length} nodes, ${membranes.length} membranes, ${feElements.length} elements.`);

                // Update UI Trees
                updateModelTree();
                updateSpringGroupTree();

                // Full redraw (handles geometry, mesh, springs, layers)
                redrawAll();

                // Sanity Check Highlights
                selectedMembranes = [];
                updateMembraneSelectionInfo();

            } catch (error) {
                console.error("Error loading model:", error);
                alert(`Error loading model: ${error.message}`);
                updateStatus("Error loading model.");   // Attempt to clear again in case of partial load before error
                clearAllData();    // Explicitly redraw the cleared state
                geometryLayer?.batchDraw();
                membraneFillLayer?.batchDraw();
                meshLayer?.batchDraw();
                springLayer?.batchDraw();
                stressLayer?.batchDraw();
                reactionLayer?.batchDraw();
            }
        }

        function clearAllData() {
            console.log("Clearing all model data...");
            nodes = [];
            membranes = [];
            geometricSpringNodes = [];
            selectedNodes = [];
            selectedMembranes = [];
            selectedFeSprings = []; // NEW
            selectedFeElements = []; // NEW
            // Clear results
            resultsDisplacements = null;
            resultsSpringLoads = [];
            resultsReactions = [];
            resultsElementStresses = [];

            clearMeshData(); // Clears FE nodes, elements, springs

            // Reset ID counters
            nextNodeId = 1;
            nextMembraneId = 1;
            feNodeIdCounter = 1;
            feElementIdCounter = 1;
            feSpringIdCounter = 1;

            // Clear Konva Layers (except background)
            geometryLayer?.destroyChildren();
            membraneFillLayer?.destroyChildren();
            meshLayer?.destroyChildren(); // Included in clearMeshData, but safe to repeat
            springLayer?.destroyChildren(); // Included in clearMeshData, but safe to repeat
            stressLayer?.destroyChildren(); // Included in clearMeshData, but safe to repeat
            reactionLayer?.destroyChildren(); // NEW: Clear reaction layer
            selectionLayer?.destroyChildren();

            // Redraw background
            const background = backgroundLayer?.findOne('Rect');
            backgroundLayer?.destroyChildren();
            if (background) backgroundLayer?.add(background);

            // Batch draw to apply clearing
            geometryLayer?.batchDraw();
            membraneFillLayer?.batchDraw();
            meshLayer?.batchDraw();
            springLayer?.batchDraw();
            stressLayer?.batchDraw();
            reactionLayer?.batchDraw(); // NEW: Batch draw reaction layer
            selectionLayer?.batchDraw();
            backgroundLayer?.batchDraw();

            // Update UI displays
            updateSelectionInfo();
            updateMembraneSelectionInfo();
            updateFeSelectionInfo();
            updateSpringPointsInfo();
            updateSpringSelectionInfo(); // NEW
            updateElementSelectionInfo(); // NEW
            updateResultsDisplay();
            setMode('add-node'); // Reset mode
            updateStatus("Model cleared.");
        }

        function createMembraneFromData(id, nodeIds, matE, matNu, matT) {
            const membraneNodes = nodeIds.map(nid => findNodeDataById(nid));
            if (membraneNodes.some(n => !n)) { console.error(`Cannot create membrane ${id}, missing node data.`); return null; }
            const points = membraneNodes.flatMap(n => [n.x, n.y]);
            if (typeof Konva === 'undefined' || !Konva.Line) { console.error("Konva.Line not available."); return null; }

            let membraneFillShape;
            try {
                membraneFillShape = new Konva.Line({
                    points: points,
                    fill: 'rgba(173, 216, 230, 0.5)',
                    stroke: MEMBRANE_DEFAULT_STROKE,
                    strokeWidth: MEMBRANE_DEFAULT_STROKE_WIDTH,
                    strokeScaleEnabled: false,
                    closed: true,
                    listening: false,
                    draggable: false,
                    opacity: MEMBRANE_DEFAULT_OPACITY,
                    name: 'membrane'
                });
                // --- ADD THIS LINE: ---
                // Shape created but not added to layer yet. redrawAll() handles addition.
                // --- END ADDED LINE ---
            } catch (error) { console.error("Error creating Konva.Line for membrane fill from data:", error); return null; }

            const newMembrane = {
                id: id,
                nodeIds: nodeIds,
                konvaShape: membraneFillShape,
                isMeshed: false,
                materialE: matE ?? DEFAULT_MATERIAL_E,
                materialNu: matNu ?? DEFAULT_MATERIAL_NU,
                materialT: matT ?? DEFAULT_MATERIAL_T
            };

            // REMOVE adding to layer here, it's done above now.
            return newMembrane;
        }

        // --- Renamed and Enhanced Redraw Function ---
        function redrawAll() {
            console.log("Redrawing full model state...");
            if (!stage) return; // Needed for scale check
            const scale = stage.scaleX();

            // 1. Clear Layers (visuals only, data is already loaded)
            geometryLayer?.destroyChildren();
            membraneFillLayer?.destroyChildren();
            meshLayer?.destroyChildren();
            springLayer?.destroyChildren();
            stressLayer?.destroyChildren();
            reactionLayer?.destroyChildren(); // NEW: Clear reaction layer

            // --- CRITICAL: Reset Konva references in data objects ---
            // Since we destroyed the children, the old references are invalid.
            nodes.forEach(n => n.konvaCircle = null);
            membranes.forEach(m => m.konvaShape = null);
            feElements.forEach(e => e.konvaShape = null); // Used for stress plotting
            // feSprings/feNodes generally recreate anyway in drawSprings/drawMesh, but good practice if safe.
            // feNodes.forEach(n => n.konvaCircle = null); // drawMesh handles this internally usually?
            // drawMesh does: const circle = new Konva.Circle... it re-creates.

            // 2. Redraw Geometry Nodes
            nodes.forEach(node => {
                if (!node.konvaCircle) { // Will always be true now
                    // Try to recreate if necessary (optional)
                    const konvaCircle = new Konva.Circle({
                        x: node.x, y: node.y,
                        radius: NODE_RADIUS_TARGET_PX / scale, // Use scaled radius
                        stroke: 'black',
                        strokeWidth: NODE_STROKE_WIDTH_TARGET_PX, // Target pixel width
                        strokeScaleEnabled: false, // Keep stroke constant
                        draggable: true, id: `node-${node.id}`
                    });
                    node.konvaCircle = konvaCircle;
                    konvaCircle.on('click tap', (e) => { e.cancelBubble = true; handleNodeClick(node); });
                    konvaCircle.on('dragend', () => { /* Add drag logic back if needed */ });
                }
                const isMarked = geometricSpringNodes.includes(node.id);
                node.konvaCircle.fill(isMarked ? SPRING_NODE_COLOR : DEFAULT_NODE_COLOR);
                geometryLayer.add(node.konvaCircle);
            });

            // 3. Redraw Membranes
            membranes.forEach(membrane => {
                if (!membrane.konvaShape) { // Will always be true
                    // Try to recreate
                    const points = membrane.nodeIds.map(nid => findNodeDataById(nid)).flatMap(n => [n.x, n.y]);
                    membrane.konvaShape = new Konva.Line({
                        points: points, fill: 'rgba(173, 216, 230, 0.5)',
                        stroke: MEMBRANE_DEFAULT_STROKE,
                        strokeWidth: MEMBRANE_DEFAULT_STROKE_WIDTH, // Target pixel width
                        strokeScaleEnabled: false, // Keep stroke constant
                        closed: true, listening: false, draggable: false, opacity: MEMBRANE_DEFAULT_OPACITY, name: 'membrane'
                    });
                }
                membraneFillLayer.add(membrane.konvaShape);
            });

            // 4. Redraw Mesh (FE Nodes, Elements, BCs)
            drawMesh(); // This function already handles drawing based on global feNodes/feElements

            // 5. Redraw Springs
            drawSprings(); // This function already handles drawing based on global feSprings

            // 6. Redraw Reactions (if any results exist)
            drawReactions(); // NEW: Call drawReactions

            // 7. Batch Draw All Layers
            geometryLayer?.batchDraw();
            membraneFillLayer?.batchDraw();
            meshLayer?.batchDraw();
            springLayer?.batchDraw();
            stressLayer?.visible(false); // Hide stress layer initially after load
            stressLayer?.batchDraw();
            reactionLayer?.visible(false); // Hide reaction layer initially after load
            reactionLayer?.batchDraw();

            console.log("Finished redrawing full model state.");
        }

        // --- ADDED: drawDeformedMesh --- MOVE THIS UP
        function drawDeformedMesh(displacementVector, scaleFactor) {
            console.log(`Drawing deformed mesh with scale factor: ${scaleFactor}`);
            if (!meshLayer || !displacementVector) return;
            // Clear previous deformed mesh visuals if they exist (e.g., add a name property)
            // Correct way to destroy nodes found by find()
            const oldDeformed = meshLayer.find('.deformed-mesh-element');
            oldDeformed.forEach(node => {
                node.destroy();
            });
            // meshLayer.find('.deformed-mesh-element').destroy(); // Incorrect: find() returns a Collection
            const nodeIndexMap = new Map();
            feNodes.forEach((node, index) => nodeIndexMap.set(node.id, index));

            feElements.forEach(element => {
                const membrane = findMembraneById(element.membraneId);
                if (membrane && membrane.visible === false) {
                    return; // Skip drawing deformed elements of hidden membranes
                }

                if (element.type === 'quad' && element.nodeIds.length === 4) {
                    const deformedPoints = [];
                    let geometryValid = true;
                    element.nodeIds.forEach(nodeId => {
                        const node = findFeNodeById(nodeId);
                        const globalIndex = nodeIndexMap.get(nodeId);
                        if (node && globalIndex !== undefined && (2 * globalIndex + 1) < displacementVector.length) {
                            const dx = displacementVector[2 * globalIndex] * scaleFactor;
                            const dy = displacementVector[2 * globalIndex + 1] * scaleFactor;
                            deformedPoints.push(node.x + dx, node.y + dy);
                        } else {
                            console.warn(`Missing node or displacement data for FE Node ${nodeId} in element ${element.id}`);
                            geometryValid = false;
                        }
                    });

                    if (geometryValid) {
                        const deformedLine = new Konva.Line({
                            points: deformedPoints,
                            stroke: 'rgba(255, 0, 0, 0.7)', // Red for deformed shape
                            strokeWidth: LINE_STROKE_WIDTH_TARGET_PX, // Use target width
                            strokeScaleEnabled: false, // Keep stroke width constant
                            closed: true,
                            listening: false,
                            name: 'deformed-mesh-element' // Name for easy removal
                        });
                        meshLayer.add(deformedLine);
                    }
                }
            });
            meshLayer.batchDraw();
            console.log("Deformed mesh drawn.");
        }

        function drawStressResults(elementStresses) {
            console.log("Drawing stress results...");
            // const stressLayer = window.stressLayer; // REMOVED: Use scoped variable

            // Check for data availability
            if (!stressLayer || !elementStresses || elementStresses.length === 0) {
                console.log("No stress data to draw or stress layer missing.");
                stressLayer?.destroyChildren();
                stressLayer?.visible(false);
                stressLayer?.batchDraw();
                // Hide Legend
                const legend = document.getElementById('stress-legend');
                if (legend) legend.hidden = true;
                return;
            }
            stressLayer.destroyChildren();

            const stressType = document.getElementById('stress-type-select')?.value || 'sigmaVM';
            let propKey = stressType;

            // Calculate Min/Max for the selected property
            let minVal = Infinity;
            let maxVal = -Infinity;

            // Helper to extract value safely
            const getValue = (record) => {
                let val = record[propKey];
                // Check if string and parse
                if (typeof val === 'string') val = parseFloat(val);
                return val;
            };

            // Filter relevant elements first (membranes visible)
            const visibleElements = [];
            feElements.forEach(el => {
                const mem = findMembraneById(el.membraneId);
                if (mem && mem.visible !== false) {
                    const res = elementStresses.find(r => r.elementId === el.id);
                    if (res) {
                        const val = getValue(res);
                        if (!isNaN(val)) {
                            if (val < minVal) minVal = val;
                            if (val > maxVal) maxVal = val;
                            visibleElements.push({ el, val });
                        }
                    }
                }
            });

            if (visibleElements.length === 0) {
                stressLayer.batchDraw();
                // Hide Legend if no visible elements
                const legend = document.getElementById('stress-legend');
                if (legend) legend.hidden = true;
                return;
            }

            // Handle range edge case (flat stress)
            if (minVal === maxVal) {
                maxVal = minVal + (minVal === 0 ? 1.0 : Math.abs(minVal) * 0.0001);
            }
            const range = maxVal - minVal;

            console.log(`Plotting ${propKey}. Range: [${minVal.toExponential(2)}, ${maxVal.toExponential(2)}]`);

            // Update Legend
            const legend = document.getElementById('stress-legend');
            if (legend) {
                legend.hidden = false;
                let titleText = "Stress";
                if (propKey === 'sigmaVM') titleText = "Von Mises (SE)";
                else if (propKey === 'sxx') titleText = "Stress X (SX)";
                else if (propKey === 'syy') titleText = "Stress Y (SY)";
                else if (propKey === 'sxy') titleText = "Shear XY (SXY)";

                document.getElementById('legend-title').textContent = titleText + " (psi)";
                document.getElementById('legend-max').textContent = maxVal.toExponential(3);
                document.getElementById('legend-min').textContent = minVal.toExponential(3);
                document.getElementById('legend-mid').textContent = ((minVal + maxVal) / 2).toExponential(3);

                const gradientDiv = document.getElementById('legend-gradient');
                if (gradientDiv) {
                    // Match the HSL interpolation used below: Blue(240)->Cyan->Lime->Yellow->Red(0)
                    gradientDiv.style.background = 'linear-gradient(to top, blue, cyan, lime, yellow, red)';
                }
            }

            // Draw Elements
            visibleElements.forEach(item => {
                const { el, val } = item;
                const norm = (val - minVal) / range; // 0 to 1
                // Map to Hue: 240 (Blue, min) -> 0 (Red, max)
                const hue = 240 * (1 - norm);
                const color = `hsl(${hue}, 100%, 50%)`;

                const nodeCoords = el.nodeIds.map(id => findFeNodeById(id));
                if (nodeCoords.some(n => !n)) return;
                const points = nodeCoords.flatMap(n => [n.x, n.y]);

                // Reuse or create shape (recreating is safer with destroyChildren)
                const poly = new Konva.Line({
                    points: points,
                    fill: color,
                    strokeWidth: 0,
                    closed: true,
                    listening: false
                });
                stressLayer.add(poly);

                // Update cache/reference if needed? No, purely visual here.
                el.konvaShape = poly; // Keep ref for internal use if needed
            });

            stressLayer.visible(true);
            stressLayer.batchDraw();
            console.log(`Stress results drawn for ${visibleElements.length} elements.`);
        }

        // --- ADDED: handleResultsViewChange --- MOVE THIS UP
        // --- ADDED: handleResultsViewChange --- MOVE THIS UP
        function handleResultsViewChange(event) {
            // FIX: event.target.value might differ if called manually or via click
            const selectedValue = document.querySelector('input[name="results-view"]:checked')?.value || 'springs';
            console.log("Results view changed to:", selectedValue);

            document.getElementById('results-springs').hidden = (selectedValue !== 'springs');
            document.getElementById('results-reactions').hidden = (selectedValue !== 'reactions');
            document.getElementById('results-stress').hidden = (selectedValue !== 'stress');

            // Show/Hide Stress Type Selector
            const stressSelect = document.getElementById('stress-type-select');
            if (stressSelect) {
                stressSelect.hidden = (selectedValue !== 'stress');
            }
            // Show/Hide Stress Legend
            const stressLegend = document.getElementById('stress-legend');
            if (stressLegend) {
                // Initial hide. drawStressResults will show it if there is data.
                // But if we switch away from stress, force hide.
                if (selectedValue !== 'stress') {
                    stressLegend.hidden = true;
                } else {
                    // Only show if we actually have results? 
                    // Let drawStressResults handle showing it.
                    // But we must ensure it's hidden if we switch to 'springs'
                }
            }

            // Toggle visibility of Konva layers
            if (stressLayer) stressLayer.visible(selectedValue === 'stress');
            if (reactionLayer) reactionLayer.visible(selectedValue === 'reactions');

            // VISIBILITY FIX: Toggle springLayer based on view
            if (springLayer) springLayer.visible(selectedValue === 'springs');

            stressLayer?.batchDraw();
            reactionLayer?.batchDraw();
            springLayer?.batchDraw();
        }

        // --- Delete Functions ---
        function deleteNode(nodeId, silent = false) {
            console.log(`Attempting to delete node ${nodeId}`);
            const isUsed = membranes.some(m => m.nodeIds.includes(nodeId));
            if (isUsed) {
                if (!silent) alert(`Cannot delete Node ${nodeId} because it is used by one or more membranes. Delete the membrane(s) first.`);
                updateStatus(`Cannot delete Node ${nodeId}: Used by membrane(s).`);
                console.warn(`Deletion of node ${nodeId} prevented: used by membrane.`);
                return;
            }
            const springIndex = geometricSpringNodes.indexOf(nodeId);
            if (springIndex > -1) {
                geometricSpringNodes.splice(springIndex, 1);
                updateSpringPointsInfo();
            }
            const nodeIndex = nodes.findIndex(n => n.id === nodeId);
            if (nodeIndex > -1) {
                const nodeToRemove = nodes[nodeIndex];
                nodeToRemove.konvaCircle?.destroy();
                nodes.splice(nodeIndex, 1);
                console.log(`Node ${nodeId} deleted.`);
                if (!silent) updateStatus(`Node ${nodeId} deleted.`);
                geometryLayer?.batchDraw();
                updateSelectionInfo();
            } else {
                console.warn(`Node ${nodeId} not found for deletion.`);
            }
        }
        /**
         * Deletes a membrane data object and its associated visual shape.
         * Also clears any FE mesh data (nodes, elements, springs) associated
         * specifically with this membrane BEFORE deleting the membrane data.
         *
         * NOTE: This function deletes MEMBRANES. To delete geometric points/nodes,
         * the `deleteNode` function is used (and only works if the node
         * is not part of any existing membrane definition).
         *
         * @param {number} membraneId The ID of the membrane to delete.
         */
        function deleteMembrane(membraneId) {
            console.log(`Attempting to delete membrane ${membraneId}`);
            const memIndex = membranes.findIndex(m => m.id === membraneId);

            if (memIndex > -1) {
                const membraneToRemove = membranes[memIndex];

                // --- Step 1: Clear associated FE data first (if any) ---
                // This is important to do before removing the membrane data itself.
                // clearMeshForSingleMembrane also sets membraneToRemove.isMeshed = false internally.
                if (membraneToRemove.isMeshed) {
                    clearMeshForSingleMembrane(membraneId);
                }

                // --- Step 2: Clean up the Konva visual shape ---
                if (membraneToRemove.konvaShape) {
                    // Try explicitly removing from layer first before destroying,
                    // as suggested by some Konva warnings to help internal cleanup.
                    membraneToRemove.konvaShape.remove();
                    membraneToRemove.konvaShape.destroy();
                    membraneToRemove.konvaShape = null; // Clear the reference in the data object
                }

                // --- Step 3: Remove the membrane data object from the global array ---
                const nodeIdsToRemove = [...membraneToRemove.nodeIds]; // Copy nodes to delete after
                membranes.splice(memIndex, 1);

                // --- Step 3.5: Attempt to delete defining nodes (if orphans) ---
                nodeIdsToRemove.forEach(nid => deleteNode(nid, true));

                // --- Step 4: Update selection state if necessary ---
                // Remove the deleted membrane's ID from the selectedMembranes array if present.
                const selectionIndex = selectedMembranes.indexOf(membraneId);
                if (selectionIndex > -1) {
                    selectedMembranes.splice(selectionIndex, 1);
                }

                // --- Step 5: Update UI and log success ---
                console.log(`Membrane ${membraneId} deleted.`);
                updateStatus(`Membrane ${membraneId} deleted.`);

                // --- Step 6: Redraw layers affected by the deletion ---
                // We need to redraw to reflect the removed shapes and potentially cleared mesh/springs.
                membraneFillLayer?.batchDraw(); // Update membrane visuals (fill is gone)
                meshLayer?.batchDraw();        // Update mesh visuals (elements/nodes might be gone)
                springLayer?.batchDraw();      // Update spring visuals (springs might be gone)
                updateMembraneSelectionInfo(); // Update the list of selected membranes in the UI

            } else {
                // Handle case where membrane ID wasn't found (should generally not happen if called correctly)
                console.warn(`Membrane ${membraneId} not found for deletion.`);
                updateStatus(`Membrane ${membraneId} not found.`); // Optional: Update status
            }
        }
        function clearMeshForSingleMembrane(membraneId) { console.log(`Clearing mesh data for membrane ${membraneId}`); const feNodesToRemove = new Set(); const feElementsToRemove = new Set(); const feSpringsToRemove = new Set(); feNodes.forEach(feN => { if (feN.membraneId === membraneId) { feNodesToRemove.add(feN.id); } }); feElements.forEach(feE => { if (feE.membraneId === membraneId) { feElementsToRemove.add(feE.id); } }); if (feNodesToRemove.size > 0) { feSprings.forEach(feS => { if (feNodesToRemove.has(feS.feNodeId1) || feNodesToRemove.has(feS.feNodeId2)) { feSpringsToRemove.add(feS.id); } }); } const nodeCount = feNodes.length; const elemCount = feElements.length; const springCount = feSprings.length; feNodes = feNodes.filter(feN => !feNodesToRemove.has(feN.id)); feElements = feElements.filter(feE => !feElementsToRemove.has(feE.id)); feSprings = feSprings.filter(feS => !feSpringsToRemove.has(feS.id)); const membrane = findMembraneById(membraneId); if (membrane) membrane.isMeshed = false; console.log(`Removed ${nodeCount - feNodes.length} FE nodes, ${elemCount - feElements.length} FE elements, ${springCount - feSprings.length} FE springs for membrane ${membraneId}.`); }

        // --- Start the application ---
        document.addEventListener('DOMContentLoaded', () => {
            console.log("DOMContentLoaded fired, calling initializeKonva...");
            initializeKonva();
        });

        // --- ADDED: Handler for applying edited node coordinates ---
        function handleApplyNodeCoords() {
            if (editingNodeId === null) {
                console.warn("Apply Node Coords called but no node is being edited.");
                updateStatus("No node selected for coordinate editing.");
                return;
            }

            const nodeToEdit = findNodeDataById(editingNodeId);
            if (!nodeToEdit || !nodeToEdit.konvaCircle) {
                console.error(`Node ${editingNodeId} not found or invalid during coordinate apply.`);
                updateStatus(`Error: Node ${editingNodeId} data missing.`);
                editingNodeId = null; // Reset state
                return;
            }

            const xInput = document.getElementById('edit-node-x-input');
            const yInput = document.getElementById('edit-node-y-input');
            const newX = parseFloat(xInput?.value);
            const newY = parseFloat(yInput?.value);

            if (isNaN(newX) || isNaN(newY)) {
                alert("Invalid coordinates. Please enter numeric values for X and Y.");
                updateStatus("Error: Invalid coordinate values entered.");
                return;
            }

            console.log(`Applying new coordinates (${newX.toFixed(3)}, ${newY.toFixed(3)}) to Node ${editingNodeId}`);

            // Update node data
            nodeToEdit.x = newX;
            nodeToEdit.y = newY;

            // Update Konva shape position
            nodeToEdit.konvaCircle.position({ x: newX, y: newY });

            // Update connected elements
            updateConnectedMembranes(editingNodeId);
            clearMeshForAffectedMembranes(editingNodeId); // Clear mesh data if node moved

            // Redraw layers
            geometryLayer?.batchDraw();
            membraneFillLayer?.batchDraw();
            drawMesh();    // Redraw mesh layer (needed if mesh was cleared)
            drawSprings(); // Redraw springs layer

            updateStatus(`Node ${editingNodeId} coordinates updated.`);

            // Optional: Hide input area and reset state after applying
            // const inputArea = document.getElementById('edit-node-coords-input-area');
            // if (inputArea) inputArea.hidden = true;
            // editingNodeId = null;
            // setMode('add-node'); // Or stay in edit mode? User preference. Currently stays.
        }
        // --- End Added Function ---

        // --- MOVED: Function to update the results text areas ---
        function updateResultsDisplay() {
            const springsDiv = document.getElementById('results-springs')?.querySelector('pre');
            const reactionsDiv = document.getElementById('results-reactions')?.querySelector('pre');
            const stressDiv = document.getElementById('results-stress')?.querySelector('pre');

            // Filtering removed per user request

            if (springsDiv) {
                if (resultsSpringLoads === null || resultsSpringLoads.length === 0) {
                    springsDiv.textContent = "Not run yet or no springs.";
                } else {
                    springsDiv.textContent = resultsSpringLoads.map(r => `Spring ${r.id}: Fx=${r.fx}, Fy=${r.fy}`).join('\n');
                }
            }
            if (reactionsDiv) {
                if (resultsReactions === null || resultsReactions.length === 0) {
                    reactionsDiv.textContent = "Not run yet or no fixed/enforced BCs.";
                } else {
                    // Recalculate Summation
                    let sumRx = 0, sumRy = 0;
                    resultsReactions.forEach(r => {
                        const rxVal = parseFloat(r.rx);
                        const ryVal = parseFloat(r.ry);
                        if (!isNaN(rxVal)) sumRx += rxVal;
                        if (!isNaN(ryVal)) sumRy += ryVal;
                    });

                    const header = `Total Rx: ${sumRx.toExponential(3)}\nTotal Ry: ${sumRy.toExponential(3)}\n-------------------\n`;
                    reactionsDiv.textContent = header + resultsReactions.map(r => `Node ${r.feNodeId}: Rx=${r.rx}, Ry=${r.ry}`).join('\n');
                }
            }
            if (stressDiv) {
                if (resultsElementStresses === null || resultsElementStresses.length === 0) {
                    stressDiv.textContent = "Not run yet or no elements.";
                } else {
                    // Display all stress components: SX, SY, SXY, SE (von Mises)
                    stressDiv.textContent = resultsElementStresses.map(r =>
                        `Elem ${r.elementId}: SX=${r.sxx} SY=${r.syy} SXY=${r.sxy} SE=${Number(r.sigmaVM).toExponential(3)}`
                    ).join('\n');
                }
            }
        }

        // --- NEW: drawReactions Function ---
        function drawReactions() {
            if (!reactionLayer || !stage) return;
            reactionLayer.destroyChildren();

            if (!resultsReactions || resultsReactions.length === 0) {
                reactionLayer.batchDraw();
                return;
            }

            const scale = stage.scaleX();
            const arrowLengthPixels = 40; // Target visual length for arrows
            const labelOffsetPixels = 5; // Offset for labels from arrow tip

            resultsReactions.forEach(r => {
                const node = findFeNodeById(r.feNodeId);
                if (!node) return;

                const rx = parseFloat(r.rx);
                const ry = parseFloat(r.ry);

                if (isNaN(rx) || isNaN(ry)) return;

                const arrowLengthWorld = arrowLengthPixels / scale;
                const pointerSizeWorld = 6 / scale;
                const strokeWidthWorld = 2 / scale;
                const fontSizeWorld = 10 / scale;
                const labelOffsetWorld = labelOffsetPixels / scale;

                // Draw Arrow for Rx
                if (Math.abs(rx) > 1e-9) {
                    const dir = rx > 0 ? 1 : -1;
                    const arrow = new Konva.Arrow({
                        points: [node.x, node.y, node.x + dir * arrowLengthWorld, node.y],
                        pointerLength: pointerSizeWorld,
                        pointerWidth: pointerSizeWorld,
                        fill: 'red',
                        stroke: 'red',
                        strokeWidth: strokeWidthWorld,
                        listening: false
                    });
                    reactionLayer.add(arrow);

                    // Label
                    const label = new Konva.Text({
                        x: node.x + dir * (arrowLengthWorld + labelOffsetWorld),
                        y: node.y,
                        text: `Rx:${r.rx}`,
                        fontSize: fontSizeWorld,
                        fill: 'red',
                        listening: false,
                        align: dir > 0 ? 'left' : 'right',
                        offsetY: fontSizeWorld / 2 // Center vertically
                    });
                    reactionLayer.add(label);
                }

                // Draw Arrow for Ry
                if (Math.abs(ry) > 1e-9) {
                    // Konva Y increases downwards. If Ry is positive (upwards in engineering),
                    // then the arrow should point towards smaller Y values in Konva.
                    // If Ry is positive (downwards in Konva), arrow points towards larger Y values.
                    const dir = ry > 0 ? 1 : -1; // +1 for positive Ry (down), -1 for negative Ry (up)

                    const arrow = new Konva.Arrow({
                        points: [node.x, node.y, node.x, node.y + dir * arrowLengthWorld],
                        pointerLength: pointerSizeWorld,
                        pointerWidth: pointerSizeWorld,
                        fill: 'red',
                        stroke: 'red',
                        strokeWidth: strokeWidthWorld,
                        listening: false
                    });
                    reactionLayer.add(arrow);

                    // Label
                    const label = new Konva.Text({
                        x: node.x,
                        y: node.y + dir * (arrowLengthWorld + labelOffsetWorld),
                        text: `Ry:${r.ry}`,
                        fontSize: fontSizeWorld,
                        fill: 'red',
                        listening: false,
                        align: 'center',
                        offsetX: fontSizeWorld * 2, // Adjust horizontally
                        offsetY: dir > 0 ? 0 : fontSizeWorld // Adjust vertically based on direction
                    });
                    reactionLayer.add(label);
                }
            });

            reactionLayer.batchDraw();
        }
        // --- FEA Calculations ---
        function zeros(rows, cols) { return Array(rows).fill(0).map(() => Array(cols).fill(0)); }

    </script>

</body>

</html>